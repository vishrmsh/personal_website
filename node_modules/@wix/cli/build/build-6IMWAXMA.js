import { createRequire as _createRequire } from 'node:module';
const require = _createRequire(import.meta.url);
import {
  esm_exports,
  esm_exports2,
  init_esm,
  init_esm2
} from "./chunk-Z4MHKCET.js";
import {
  __commonJS,
  __require,
  __toCommonJS,
  init_esm_shims
} from "./chunk-4EFJZ3GQ.js";

// ../../node_modules/opentelemetry-instrumentation-fetch-node/build/index.js
var require_build = __commonJS({
  "../../node_modules/opentelemetry-instrumentation-fetch-node/build/index.js"(exports) {
    init_esm_shims();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchInstrumentation = void 0;
    var node_diagnostics_channel_1 = __importDefault(__require("node:diagnostics_channel"));
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function getMessage(error) {
      if (error instanceof AggregateError) {
        return error.errors.map((e) => e.message).join(", ");
      }
      return error.message;
    }
    function contentLengthFromResponseHeaders(headers) {
      const name = "content-length";
      for (let i = 0; i < headers.length; i += 2) {
        const k = headers[i];
        if (k.length === name.length && k.toString().toLowerCase() === name) {
          const v = Number(headers[i + 1]);
          if (!Number.isNaN(Number(v))) {
            return v;
          }
          return void 0;
        }
      }
      return void 0;
    }
    async function loadFetch() {
      try {
        await fetch("");
      } catch (_) {
      }
    }
    var FetchInstrumentation = class {
      // Keep ref to avoid https://github.com/nodejs/node/issues/42170 bug and for
      // unsubscribing.
      channelSubs;
      spanFromReq = /* @__PURE__ */ new WeakMap();
      tracer;
      config;
      meter;
      instrumentationName = "opentelemetry-instrumentation-node-18-fetch";
      instrumentationVersion = "1.0.0";
      instrumentationDescription = "Instrumentation for Node 18 fetch via diagnostics_channel";
      subscribeToChannel(diagnosticChannel, onMessage) {
        const channel = node_diagnostics_channel_1.default.channel(diagnosticChannel);
        channel.subscribe(onMessage);
        this.channelSubs.push({
          name: diagnosticChannel,
          channel,
          onMessage
        });
      }
      constructor(config) {
        loadFetch();
        this.channelSubs = [];
        this.meter = api_1.metrics.getMeter(this.instrumentationName, this.instrumentationVersion);
        this.tracer = api_1.trace.getTracer(this.instrumentationName, this.instrumentationVersion);
        this.config = { ...config };
      }
      disable() {
        this.channelSubs?.forEach((sub) => sub.channel.unsubscribe(sub.onMessage));
      }
      enable() {
        this.subscribeToChannel("undici:request:create", (args) => this.onRequest(args));
        this.subscribeToChannel("undici:request:headers", (args) => this.onHeaders(args));
        this.subscribeToChannel("undici:request:trailers", (args) => this.onDone(args));
        this.subscribeToChannel("undici:request:error", (args) => this.onError(args));
      }
      setTracerProvider(tracerProvider) {
        this.tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
      }
      setMeterProvider(meterProvider) {
        this.meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
      }
      setConfig(config) {
        this.config = { ...config };
      }
      getConfig() {
        return this.config;
      }
      onRequest({ request }) {
        if (request.method === "CONNECT") {
          return;
        }
        if (this.config.ignoreRequestHook && this.config.ignoreRequestHook(request) === true) {
          return;
        }
        const span = this.tracer.startSpan(`HTTP ${request.method}`, {
          kind: api_1.SpanKind.CLIENT,
          attributes: {
            [semantic_conventions_1.SemanticAttributes.HTTP_URL]: getAbsoluteUrl(request.origin, request.path),
            [semantic_conventions_1.SemanticAttributes.HTTP_METHOD]: request.method,
            [semantic_conventions_1.SemanticAttributes.HTTP_TARGET]: request.path,
            "http.client": "fetch"
          }
        });
        const requestContext = api_1.trace.setSpan(api_1.context.active(), span);
        const addedHeaders = {};
        api_1.propagation.inject(requestContext, addedHeaders);
        if (this.config.onRequest) {
          this.config.onRequest({ request, span, additionalHeaders: addedHeaders });
        }
        if (Array.isArray(request.headers)) {
          request.headers.push(...Object.entries(addedHeaders).flat());
        } else {
          request.headers += Object.entries(addedHeaders).map(([k, v]) => `${k}: ${v}\r
`).join("");
        }
        this.spanFromReq.set(request, span);
      }
      onHeaders({ request, response }) {
        const span = this.spanFromReq.get(request);
        if (span !== void 0) {
          const cLen = contentLengthFromResponseHeaders(response.headers);
          const attrs = {
            [semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE]: response.statusCode
          };
          if (cLen) {
            attrs[semantic_conventions_1.SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH] = cLen;
          }
          span.setAttributes(attrs);
          span.setStatus({
            code: response.statusCode >= 400 ? api_1.SpanStatusCode.ERROR : api_1.SpanStatusCode.OK,
            message: String(response.statusCode)
          });
        }
      }
      onDone({ request }) {
        const span = this.spanFromReq.get(request);
        if (span !== void 0) {
          span.end();
          this.spanFromReq.delete(request);
        }
      }
      onError({ request, error }) {
        const span = this.spanFromReq.get(request);
        if (span !== void 0) {
          span.recordException(error);
          span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: getMessage(error)
          });
          span.end();
        }
      }
    };
    exports.FetchInstrumentation = FetchInstrumentation;
    function getAbsoluteUrl(origin, path = "/") {
      const url = `${origin}`;
      if (origin.endsWith("/") && path.startsWith("/")) {
        return `${url}${path.slice(1)}`;
      }
      if (!origin.endsWith("/") && !path.startsWith("/")) {
        return `${url}/${path.slice(1)}`;
      }
      return `${url}${path}`;
    }
  }
});
export default require_build();
//# sourceMappingURL=build-6IMWAXMA.js.map