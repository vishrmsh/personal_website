import { createRequire as _createRequire } from 'node:module';
const require = _createRequire(import.meta.url);
import {
  __commonJS,
  __require,
  __toESM,
  init_esm_shims
} from "./chunk-4EFJZ3GQ.js";

// ../../node_modules/assert-plus/assert.js
var require_assert = __commonJS({
  "../../node_modules/assert-plus/assert.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var assert = __require("assert");
    var Stream = __require("stream").Stream;
    var util = __require("util");
    var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
    function _capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    function _toss(name, expected, oper, arg, actual) {
      throw new assert.AssertionError({
        message: util.format("%s (%s) is required", name, expected),
        actual: actual === void 0 ? typeof arg : actual(arg),
        expected,
        operator: oper || "===",
        stackStartFunction: _toss.caller
      });
    }
    function _getClass(arg) {
      return Object.prototype.toString.call(arg).slice(8, -1);
    }
    function noop() {
    }
    var types = {
      bool: {
        check: function(arg) {
          return typeof arg === "boolean";
        }
      },
      func: {
        check: function(arg) {
          return typeof arg === "function";
        }
      },
      string: {
        check: function(arg) {
          return typeof arg === "string";
        }
      },
      object: {
        check: function(arg) {
          return typeof arg === "object" && arg !== null;
        }
      },
      number: {
        check: function(arg) {
          return typeof arg === "number" && !isNaN(arg);
        }
      },
      finite: {
        check: function(arg) {
          return typeof arg === "number" && !isNaN(arg) && isFinite(arg);
        }
      },
      buffer: {
        check: function(arg) {
          return Buffer.isBuffer(arg);
        },
        operator: "Buffer.isBuffer"
      },
      array: {
        check: function(arg) {
          return Array.isArray(arg);
        },
        operator: "Array.isArray"
      },
      stream: {
        check: function(arg) {
          return arg instanceof Stream;
        },
        operator: "instanceof",
        actual: _getClass
      },
      date: {
        check: function(arg) {
          return arg instanceof Date;
        },
        operator: "instanceof",
        actual: _getClass
      },
      regexp: {
        check: function(arg) {
          return arg instanceof RegExp;
        },
        operator: "instanceof",
        actual: _getClass
      },
      uuid: {
        check: function(arg) {
          return typeof arg === "string" && UUID_REGEXP.test(arg);
        },
        operator: "isUUID"
      }
    };
    function _setExports(ndebug) {
      var keys = Object.keys(types);
      var out;
      if (process.env.NODE_NDEBUG) {
        out = noop;
      } else {
        out = function(arg, msg) {
          if (!arg) {
            _toss(msg, "true", arg);
          }
        };
      }
      keys.forEach(function(k) {
        if (ndebug) {
          out[k] = noop;
          return;
        }
        var type = types[k];
        out[k] = function(arg, msg) {
          if (!type.check(arg)) {
            _toss(msg, k, type.operator, arg, type.actual);
          }
        };
      });
      keys.forEach(function(k) {
        var name = "optional" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        out[name] = function(arg, msg) {
          if (arg === void 0 || arg === null) {
            return;
          }
          if (!type.check(arg)) {
            _toss(msg, k, type.operator, arg, type.actual);
          }
        };
      });
      keys.forEach(function(k) {
        var name = "arrayOf" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        var expected = "[" + k + "]";
        out[name] = function(arg, msg) {
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type.check(arg[i])) {
              _toss(msg, expected, type.operator, arg, type.actual);
            }
          }
        };
      });
      keys.forEach(function(k) {
        var name = "optionalArrayOf" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        var expected = "[" + k + "]";
        out[name] = function(arg, msg) {
          if (arg === void 0 || arg === null) {
            return;
          }
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type.check(arg[i])) {
              _toss(msg, expected, type.operator, arg, type.actual);
            }
          }
        };
      });
      Object.keys(assert).forEach(function(k) {
        if (k === "AssertionError") {
          out[k] = assert[k];
          return;
        }
        if (ndebug) {
          out[k] = noop;
          return;
        }
        out[k] = assert[k];
      });
      out._setExports = _setExports;
      return out;
    }
    module.exports = _setExports(process.env.NODE_NDEBUG);
  }
});

// ../../node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf = __commonJS({
  "../../node_modules/extsprintf/lib/extsprintf.js"(exports) {
    "use strict";
    init_esm_shims();
    var mod_assert = __require("assert");
    var mod_util = __require("util");
    exports.sprintf = jsSprintf;
    exports.printf = jsPrintf;
    exports.fprintf = jsFprintf;
    function jsSprintf(ofmt) {
      var regex = [
        "([^%]*)",
        /* normal text */
        "%",
        /* start of format */
        "(['\\-+ #0]*?)",
        /* flags (optional) */
        "([1-9]\\d*)?",
        /* width (optional) */
        "(\\.([1-9]\\d*))?",
        /* precision (optional) */
        "[lhjztL]*?",
        /* length mods (ignored) */
        "([diouxXfFeEgGaAcCsSp%jr])"
        /* conversion */
      ].join("");
      var re = new RegExp(regex);
      var args = Array.prototype.slice.call(arguments, 1);
      var fmt = ofmt;
      var flags, width, precision, conversion;
      var left, pad, sign, arg, match;
      var ret = "";
      var argn = 1;
      var posn = 0;
      var convposn;
      var curconv;
      mod_assert.equal(
        "string",
        typeof fmt,
        "first argument must be a format string"
      );
      while ((match = re.exec(fmt)) !== null) {
        ret += match[1];
        fmt = fmt.substring(match[0].length);
        curconv = match[0].substring(match[1].length);
        convposn = posn + match[1].length + 1;
        posn += match[0].length;
        flags = match[2] || "";
        width = match[3] || 0;
        precision = match[4] || "";
        conversion = match[6];
        left = false;
        sign = false;
        pad = " ";
        if (conversion == "%") {
          ret += "%";
          continue;
        }
        if (args.length === 0) {
          throw jsError(
            ofmt,
            convposn,
            curconv,
            "has no matching argument (too few arguments passed)"
          );
        }
        arg = args.shift();
        argn++;
        if (flags.match(/[\' #]/)) {
          throw jsError(
            ofmt,
            convposn,
            curconv,
            "uses unsupported flags"
          );
        }
        if (precision.length > 0) {
          throw jsError(
            ofmt,
            convposn,
            curconv,
            "uses non-zero precision (not supported)"
          );
        }
        if (flags.match(/-/))
          left = true;
        if (flags.match(/0/))
          pad = "0";
        if (flags.match(/\+/))
          sign = true;
        switch (conversion) {
          case "s":
            if (arg === void 0 || arg === null) {
              throw jsError(
                ofmt,
                convposn,
                curconv,
                "attempted to print undefined or null as a string (argument " + argn + " to sprintf)"
              );
            }
            ret += doPad(pad, width, left, arg.toString());
            break;
          case "d":
            arg = Math.floor(arg);
          /*jsl:fallthru*/
          case "f":
            sign = sign && arg > 0 ? "+" : "";
            ret += sign + doPad(
              pad,
              width,
              left,
              arg.toString()
            );
            break;
          case "x":
            ret += doPad(pad, width, left, arg.toString(16));
            break;
          case "j":
            if (width === 0)
              width = 10;
            ret += mod_util.inspect(arg, false, width);
            break;
          case "r":
            ret += dumpException(arg);
            break;
          default:
            throw jsError(
              ofmt,
              convposn,
              curconv,
              "is not supported"
            );
        }
      }
      ret += fmt;
      return ret;
    }
    function jsError(fmtstr, convposn, curconv, reason) {
      mod_assert.equal(typeof fmtstr, "string");
      mod_assert.equal(typeof curconv, "string");
      mod_assert.equal(typeof convposn, "number");
      mod_assert.equal(typeof reason, "string");
      return new Error('format string "' + fmtstr + '": conversion specifier "' + curconv + '" at character ' + convposn + " " + reason);
    }
    function jsPrintf() {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(process.stdout);
      jsFprintf.apply(null, args);
    }
    function jsFprintf(stream) {
      var args = Array.prototype.slice.call(arguments, 1);
      return stream.write(jsSprintf.apply(this, args));
    }
    function doPad(chr, width, left, str) {
      var ret = str;
      while (ret.length < width) {
        if (left)
          ret += chr;
        else
          ret = chr + ret;
      }
      return ret;
    }
    function dumpException(ex) {
      var ret;
      if (!(ex instanceof Error))
        throw new Error(jsSprintf("invalid type for %%r: %j", ex));
      ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack;
      if (ex.cause && typeof ex.cause === "function") {
        var cex = ex.cause();
        if (cex) {
          ret += "\nCaused by: " + dumpException(cex);
        }
      }
      return ret;
    }
  }
});

// ../../node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "../../node_modules/core-util-is/lib/util.js"(exports) {
    "use strict";
    init_esm_shims();
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// ../../node_modules/verror/lib/verror.js
var require_verror = __commonJS({
  "../../node_modules/verror/lib/verror.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var mod_assertplus = require_assert();
    var mod_util = __require("util");
    var mod_extsprintf = require_extsprintf();
    var mod_isError = require_util().isError;
    var sprintf = mod_extsprintf.sprintf;
    module.exports = VError3;
    VError3.VError = VError3;
    VError3.SError = SError;
    VError3.WError = WError2;
    VError3.MultiError = MultiError;
    function parseConstructorArguments(args) {
      var argv, options, sprintf_args, shortmessage, k;
      mod_assertplus.object(args, "args");
      mod_assertplus.bool(args.strict, "args.strict");
      mod_assertplus.array(args.argv, "args.argv");
      argv = args.argv;
      if (argv.length === 0) {
        options = {};
        sprintf_args = [];
      } else if (mod_isError(argv[0])) {
        options = { "cause": argv[0] };
        sprintf_args = argv.slice(1);
      } else if (typeof argv[0] === "object") {
        options = {};
        for (k in argv[0]) {
          options[k] = argv[0][k];
        }
        sprintf_args = argv.slice(1);
      } else {
        mod_assertplus.string(
          argv[0],
          "first argument to VError, SError, or WError constructor must be a string, object, or Error"
        );
        options = {};
        sprintf_args = argv;
      }
      mod_assertplus.object(options);
      if (!options.strict && !args.strict) {
        sprintf_args = sprintf_args.map(function(a) {
          return a === null ? "null" : a === void 0 ? "undefined" : a;
        });
      }
      if (sprintf_args.length === 0) {
        shortmessage = "";
      } else {
        shortmessage = sprintf.apply(null, sprintf_args);
      }
      return {
        "options": options,
        "shortmessage": shortmessage
      };
    }
    function VError3() {
      var args, obj, parsed, cause, ctor, message, k;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof VError3)) {
        obj = Object.create(VError3.prototype);
        VError3.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      if (parsed.options.name) {
        mod_assertplus.string(
          parsed.options.name,
          `error's "name" must be a string`
        );
        this.name = parsed.options.name;
      }
      this.jse_shortmsg = parsed.shortmessage;
      message = parsed.shortmessage;
      cause = parsed.options.cause;
      if (cause) {
        mod_assertplus.ok(mod_isError(cause), "cause is not an Error");
        this.jse_cause = cause;
        if (!parsed.options.skipCauseMessage) {
          message += ": " + cause.message;
        }
      }
      this.jse_info = {};
      if (parsed.options.info) {
        for (k in parsed.options.info) {
          this.jse_info[k] = parsed.options.info[k];
        }
      }
      this.message = message;
      Error.call(this, message);
      if (Error.captureStackTrace) {
        ctor = parsed.options.constructorOpt || this.constructor;
        Error.captureStackTrace(this, ctor);
      }
      return this;
    }
    mod_util.inherits(VError3, Error);
    VError3.prototype.name = "VError";
    VError3.prototype.toString = function ve_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      return str;
    };
    VError3.prototype.cause = function ve_cause() {
      var cause = VError3.cause(this);
      return cause === null ? void 0 : cause;
    };
    VError3.cause = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      return mod_isError(err.jse_cause) ? err.jse_cause : null;
    };
    VError3.info = function(err) {
      var rv, cause, k;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      cause = VError3.cause(err);
      if (cause !== null) {
        rv = VError3.info(cause);
      } else {
        rv = {};
      }
      if (typeof err.jse_info == "object" && err.jse_info !== null) {
        for (k in err.jse_info) {
          rv[k] = err.jse_info[k];
        }
      }
      return rv;
    };
    VError3.findCauseByName = function(err, name) {
      var cause;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.string(name, "name");
      mod_assertplus.ok(name.length > 0, "name cannot be empty");
      for (cause = err; cause !== null; cause = VError3.cause(cause)) {
        mod_assertplus.ok(mod_isError(cause));
        if (cause.name == name) {
          return cause;
        }
      }
      return null;
    };
    VError3.hasCauseWithName = function(err, name) {
      return VError3.findCauseByName(err, name) !== null;
    };
    VError3.fullStack = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      var cause = VError3.cause(err);
      if (cause) {
        return err.stack + "\ncaused by: " + VError3.fullStack(cause);
      }
      return err.stack;
    };
    VError3.errorFromList = function(errors) {
      mod_assertplus.arrayOfObject(errors, "errors");
      if (errors.length === 0) {
        return null;
      }
      errors.forEach(function(e) {
        mod_assertplus.ok(mod_isError(e));
      });
      if (errors.length == 1) {
        return errors[0];
      }
      return new MultiError(errors);
    };
    VError3.errorForEach = function(err, func) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.func(func, "func");
      if (err instanceof MultiError) {
        err.errors().forEach(function iterError(e) {
          func(e);
        });
      } else {
        func(err);
      }
    };
    function SError() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof SError)) {
        obj = Object.create(SError.prototype);
        SError.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": true
      });
      options = parsed.options;
      VError3.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(SError, VError3);
    function MultiError(errors) {
      mod_assertplus.array(errors, "list of errors");
      mod_assertplus.ok(errors.length > 0, "must be at least one error");
      this.ase_errors = errors;
      VError3.call(this, {
        "cause": errors[0]
      }, "first of %d error%s", errors.length, errors.length == 1 ? "" : "s");
    }
    mod_util.inherits(MultiError, VError3);
    MultiError.prototype.name = "MultiError";
    MultiError.prototype.errors = function me_errors() {
      return this.ase_errors.slice(0);
    };
    function WError2() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof WError2)) {
        obj = Object.create(WError2.prototype);
        WError2.apply(obj, args);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      options = parsed.options;
      options["skipCauseMessage"] = true;
      VError3.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(WError2, VError3);
    WError2.prototype.name = "WError";
    WError2.prototype.toString = function we_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      if (this.jse_cause && this.jse_cause.message)
        str += "; caused by " + this.jse_cause.toString();
      return str;
    };
    WError2.prototype.cause = function we_cause(c) {
      if (mod_isError(c))
        this.jse_cause = c;
      return this.jse_cause;
    };
  }
});

// ../../node_modules/variant/lib/isType.js
var require_isType = __commonJS({
  "../../node_modules/variant/lib/isType.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTypeImpl = void 0;
    function isTypeImpl(key) {
      function isType(instanceOrType, type) {
        if (instanceOrType != void 0) {
          if (typeof instanceOrType === "function" || typeof instanceOrType === "string") {
            const typeArg = instanceOrType;
            const typeStr = typeof typeArg === "string" ? typeArg : typeArg.output.type;
            return (o) => isType(o, typeStr);
          } else {
            const instance = instanceOrType;
            const typeStr = typeof type === "string" ? type : type.output.type;
            return instance != void 0 && instance[key !== null && key !== void 0 ? key : "type"] === typeStr;
          }
        } else {
          return false;
        }
      }
      return { isType };
    }
    exports.isTypeImpl = isTypeImpl;
  }
});

// ../../node_modules/variant/lib/util.js
var require_util2 = __commonJS({
  "../../node_modules/variant/lib/util.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HOI = exports.isPromise = exports.identityFunc = void 0;
    var identityFunc = (x = {}) => x;
    exports.identityFunc = identityFunc;
    function isPromise(x) {
      return x != void 0 && typeof x === "object" && "then" in x && typeof x.then === "function";
    }
    exports.isPromise = isPromise;
    var HOI = () => (definition) => definition;
    exports.HOI = HOI;
  }
});

// ../../node_modules/variant/lib/variant.js
var require_variant = __commonJS({
  "../../node_modules/variant/lib/variant.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.variantImpl = exports.isVariantCreator = exports.scopeType = void 0;
    var util_1 = require_util2();
    var scopeType = (scope, type) => `${scope}/${type}`;
    exports.scopeType = scopeType;
    function descopeType(s) {
      var _a;
      return (_a = s.split("/")[1]) !== null && _a !== void 0 ? _a : s;
    }
    var VARIANT_CREATOR_BRAND = Symbol("Variant Creator");
    function isVariantCreator(func) {
      return VARIANT_CREATOR_BRAND in func;
    }
    exports.isVariantCreator = isVariantCreator;
    function variantImpl(key) {
      function scope(scope2, v) {
        return Object.keys(v).reduce((acc, key2) => {
          return Object.assign(Object.assign({}, acc), { [key2]: variation((0, exports.scopeType)(scope2, key2), typeof v[key2] === "function" ? v[key2] : util_1.identityFunc) });
        }, {});
      }
      function descope(obj) {
        return Object.assign(Object.assign({}, obj), { [key]: descopeType(obj[key]) });
      }
      function variation(type, creator) {
        let maker = (...args) => {
          const returned = (creator !== null && creator !== void 0 ? creator : util_1.identityFunc)(...args);
          if ((0, util_1.isPromise)(returned)) {
            return returned.then((result) => {
              if (key in (result !== null && result !== void 0 ? result : {})) {
                return result;
              } else {
                return Object.assign(result !== null && result !== void 0 ? result : {}, { [key]: type });
              }
            });
          } else {
            if (key in (returned !== null && returned !== void 0 ? returned : {})) {
              return returned;
            } else {
              return Object.assign(returned !== null && returned !== void 0 ? returned : {}, { [key]: type });
            }
          }
        };
        Object.defineProperty(maker, "name", { value: type, writable: false });
        const outputs = { output: { key, type } };
        return Object.assign(maker, outputs, {
          [VARIANT_CREATOR_BRAND]: VARIANT_CREATOR_BRAND,
          toString: function() {
            return this.output.type;
          }
        });
      }
      function variantModule(template) {
        return Object.entries(template).reduce((result, [vmKey, vmVal]) => {
          const creator = typeof vmVal === "function" ? isVariantCreator(vmVal) ? vmVal : variation(vmKey, vmVal) : variation(vmKey, util_1.identityFunc);
          return Object.assign(Object.assign({}, result), { [vmKey]: creator });
        }, {});
      }
      function variantList(template) {
        return template.map((t) => {
          if (typeof t === "string") {
            return variation(t);
          } else if (typeof t === "function") {
            return t;
          }
          return t;
        }).reduce((result, t) => {
          let creator = typeof t === "string" ? variation(t) : t;
          return Object.assign(Object.assign({}, result), { [creator.output.type]: creator });
        }, {});
      }
      function variant2(template) {
        if (Array.isArray(template)) {
          return variantList(template);
        } else {
          return variantModule(template);
        }
      }
      return { descope, scoped: scope, variant: variant2, variantList, variantModule, variation };
    }
    exports.variantImpl = variantImpl;
  }
});

// ../../node_modules/variant/lib/precepts.js
var require_precepts = __commonJS({
  "../../node_modules/variant/lib/precepts.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_KEY = void 0;
    exports.DEFAULT_KEY = "default";
  }
});

// ../../node_modules/variant/lib/match.js
var require_match = __commonJS({
  "../../node_modules/variant/lib/match.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.matchImpl = void 0;
    var variant_1 = require_variant();
    var precepts_1 = require_precepts();
    function matchImpl(key) {
      const prematch = (_) => (handler) => (instance) => match(instance, handler);
      function match(...args) {
        var _a, _b;
        if (args.length === 1) {
          const [handler] = args;
          return (instance) => match(instance, handler);
        } else if (args.length === 2) {
          const [instanceOrTypeOrCreator, handlerParam] = args;
          const instanceOrCreator = typeof instanceOrTypeOrCreator === "string" ? ofLiteral(instanceOrTypeOrCreator) : instanceOrTypeOrCreator;
          const handler = typeof handlerParam === "function" ? handlerParam(instanceOrCreator) : handlerParam;
          const tType = instanceOrCreator == void 0 ? void 0 : (0, variant_1.isVariantCreator)(instanceOrCreator) ? instanceOrCreator.output.type : instanceOrCreator[key];
          if (instanceOrCreator != void 0 && tType !== void 0 && tType in handler) {
            return (_a = handler[tType]) === null || _a === void 0 ? void 0 : _a.call(handler, instanceOrCreator);
          } else if (precepts_1.DEFAULT_KEY in handler) {
            return (_b = handler[precepts_1.DEFAULT_KEY]) === null || _b === void 0 ? void 0 : _b.call(handler, instanceOrCreator);
          }
        }
      }
      const partial = (h) => () => h;
      const onLiteral = ofLiteral;
      function ofLiteral(instance) {
        return {
          [key]: instance
        };
      }
      function lookup(handler) {
        const handlerWithFuncs = Object.keys(handler).reduce((acc, cur) => {
          return Object.assign(Object.assign({}, acc), { [cur]: () => handler[cur] });
        }, {});
        return (_) => handlerWithFuncs;
      }
      function otherwise(branches, elseFunc) {
        return (_) => Object.assign(Object.assign({}, branches), { default: elseFunc });
      }
      function withFallback(handler, fallback) {
        return (_) => Object.assign(Object.assign({}, handler), { default: fallback });
      }
      return { match, ofLiteral, onLiteral, otherwise, partial, prematch, lookup, withFallback };
    }
    exports.matchImpl = matchImpl;
  }
});

// ../../node_modules/variant/lib/types.js
var require_types = __commonJS({
  "../../node_modules/variant/lib/types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.typesImpl = void 0;
    var variant_1 = require_variant();
    function typesImpl(key) {
      function types(content) {
        if (Array.isArray(content)) {
          if (content.length && (0, variant_1.isVariantCreator)(content[0])) {
            return content.map((c) => c.output.type);
          } else {
            return content.map((c) => c[key]);
          }
        } else {
          return Object.values(content).map((c) => c.output.type);
        }
      }
      function inferTypes(_) {
        return new Proxy({}, {
          get: (_2, property) => {
            return property;
          }
        });
      }
      return { types, inferTypes };
    }
    exports.typesImpl = typesImpl;
  }
});

// ../../node_modules/variant/lib/flags.js
var require_flags = __commonJS({
  "../../node_modules/variant/lib/flags.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flagsImpl = void 0;
    function flagsImpl(key) {
      function flags(flags2) {
        return flags2.reduce((o, v) => Object.assign(Object.assign({}, o), { [v[key]]: v }), /* @__PURE__ */ Object.create(null));
      }
      return { flags };
    }
    exports.flagsImpl = flagsImpl;
  }
});

// ../../node_modules/variant/lib/isOfVariant.js
var require_isOfVariant = __commonJS({
  "../../node_modules/variant/lib/isOfVariant.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isOfVariantImpl = void 0;
    function isOfVariantImpl(key) {
      function isOfVariant3(...args) {
        if (args.length === 1) {
          const [variant2] = args;
          return (instance) => instance != void 0 && Object.values(variant2).some((vc) => vc.output.type === instance[key]);
        } else if (args.length === 2) {
          const [instance, variant2] = args;
          return instance != void 0 && Object.values(variant2).some((vc) => vc.output.type === instance[key]);
        }
        return false;
      }
      return { isOfVariant: isOfVariant3 };
    }
    exports.isOfVariantImpl = isOfVariantImpl;
  }
});

// ../../node_modules/variant/lib/remote.js
var require_remote = __commonJS({
  "../../node_modules/variant/lib/remote.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.remoteImpl = exports.CompareResult = void 0;
    var isType_1 = require_isType();
    var match_1 = require_match();
    var variant_1 = require_variant();
    var CompareResult;
    (function(CompareResult2) {
      CompareResult2[CompareResult2["Lesser"] = -1] = "Lesser";
      CompareResult2[CompareResult2["Equal"] = 0] = "Equal";
      CompareResult2[CompareResult2["Greater"] = 1] = "Greater";
    })(CompareResult = exports.CompareResult || (exports.CompareResult = {}));
    function remoteImpl(key) {
      const { isType } = (0, isType_1.isTypeImpl)(key);
      const { match } = (0, match_1.matchImpl)(key);
      const { variantList } = (0, variant_1.variantImpl)(key);
      function isFunctions(vmod) {
        const keys = Object.keys(vmod);
        return keys.reduce((acc, key2) => {
          return Object.assign(Object.assign({}, acc), { [key2]: isType(key2) });
        }, {});
      }
      function remote(vmod) {
        return {
          key,
          is: isFunctions(vmod),
          new: vmod,
          match
        };
      }
      ;
      function getType(input) {
        if (typeof input === "string") {
          return input;
        } else if (typeof input === "function") {
          return input.output.type;
        } else {
          return input[key];
        }
      }
      function _sequence(module2, order) {
        const miniModule = module2;
        const result = remote(miniModule);
        const keyOrder = order.map(getType);
        return Object.assign(Object.assign({}, result), { length: order.length, compare: (a, b) => {
          const ai = keyOrder.findIndex((i) => i === getType(a));
          const bi = keyOrder.findIndex((i) => i === getType(b));
          const diff = ai - bi;
          return diff === 0 ? diff : diff / Math.abs(diff);
        }, get(i) {
          const type = this.types[i];
          return this.new[type];
        }, index: (a) => keyOrder.findIndex((i) => i === getType(a)), types: keyOrder });
      }
      function _sequenceOfList(order) {
        const module2 = variantList(order);
        return _sequence(module2, order);
      }
      function sequence(module2, order) {
        if (Array.isArray(module2)) {
          return _sequenceOfList(module2);
        } else {
          return _sequence(module2, order);
        }
      }
      return { remote, sequence };
    }
    exports.remoteImpl = remoteImpl;
  }
});

// ../../node_modules/variant/lib/typed.js
var require_typed = __commonJS({
  "../../node_modules/variant/lib/typed.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.typedImpl = exports.pass = void 0;
    var pass = (x) => x;
    exports.pass = pass;
    function typedImpl(_key) {
      function typed(defOrFactory) {
        if (typeof defOrFactory === "function") {
          return defOrFactory(exports.pass);
        } else {
          return defOrFactory;
        }
      }
      return { typed };
    }
    exports.typedImpl = typedImpl;
  }
});

// ../../node_modules/variant/lib/match.tools.js
var require_match_tools = __commonJS({
  "../../node_modules/variant/lib/match.tools.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unpack = exports.just = exports.constant = void 0;
    function constant(x) {
      return () => x;
    }
    exports.constant = constant;
    exports.just = constant;
    var unpack = (x) => x.payload;
    exports.unpack = unpack;
  }
});

// ../../node_modules/variant/lib/matcher.js
var require_matcher = __commonJS({
  "../../node_modules/variant/lib/matcher.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.matcherImpl = exports.Matcher = exports.tableToHandler = void 0;
    var match_tools_1 = require_match_tools();
    var variant_1 = require_variant();
    function tableToHandler(table) {
      return Object.keys(table).reduce((acc, cur) => {
        const key = cur;
        return Object.assign(Object.assign({}, acc), { [key]: (0, match_tools_1.just)(table[key]) });
      }, {});
    }
    exports.tableToHandler = tableToHandler;
    var Matcher = class _Matcher {
      /**
       * Create a new matcher from the target
       * @param target the
       * @param handler the initial handler. Use `{}` for standard functionality.
       * @param key the discriminant. Use `'type'` for standard functionality.
       */
      constructor(target, key, handler) {
        this.target = target;
        this.key = key;
        this.handler = handler;
        this.complete = (options) => {
          var _a, _b;
          if (this.target != void 0 && this.target[this.key] in this.handler) {
            return (_b = (_a = this.handler)[this.target[this.key]]) === null || _b === void 0 ? void 0 : _b.call(_a, this.target);
          } else {
            if ((options === null || options === void 0 ? void 0 : options.withFallback) != void 0) {
              return options.withFallback(this.target);
            }
          }
        };
      }
      /**
       * Immediately execute the matcher. Exhaustiveness is not guaranteed.
       *
       * This is a **terminal** and resolves the matcher.
       */
      execute() {
        const chosenHandler = this.handler[this.target[this.key]];
        return chosenHandler === null || chosenHandler === void 0 ? void 0 : chosenHandler(this.target);
      }
      /**
       * Handle all unhandled cases and immediately execute.
       *
       * > **Exhaust** â€” to consume entirely, _Merriam-Webster_
       *
       * This is a **terminal** and resolves the matcher.
       * @param remainingCases an object wiht a method to handle every remaining case.
       * @returns the result of executing the handler, given these final additions.
       */
      exhaust(remainingCases) {
        var _a;
        const combinedHandler = Object.assign(Object.assign({}, this.handler), remainingCases);
        return (_a = combinedHandler[this.target[this.key]]) === null || _a === void 0 ? void 0 : _a.call(combinedHandler, this.target);
      }
      /**
       * Resolve all remaining cases without executing the matcher.
       * @param remainingCases
       * @returns
       */
      remaining(remainingCases) {
        return new _Matcher(this.target, this.key, Object.assign(Object.assign({}, this.handler), remainingCases));
      }
      /**
       * Execute the match. If the target type has been explicitly handled, use that logic.
       * Otherwise use the function passed here.
       *
       * This is a **terminal** and resolves the matcher.
       * @param func
       * @returns
       */
      else(func) {
        var _a, _b;
        if (this.target[this.key] in this.handler) {
          return (_b = (_a = this.handler)[this.target[this.key]]) === null || _b === void 0 ? void 0 : _b.call(_a, this.target);
        } else {
          return func(this.target);
        }
      }
      /**
       * Register a series of options as a lookup table.
       *
       * ```ts
       * const getSound = (a: Animal) => matcher(a)
       *     .register({
       *         cat: 'purr',
       *         dog: 'woof',
       *         snake: 'hiss',
       *     })
       *     .complete()
       * ```
       * @param table
       * @returns
       */
      register(table) {
        const newHandler = Object.assign(Object.assign({}, this.handler), tableToHandler(table));
        return new _Matcher(this.target, this.key, newHandler);
      }
      /**
       * Provide an exhaustive table of the unhandled options and look up which value
       * to use based on the instance.
       *
       * This is a **terminal** and resolves the matcher.
       *
       * ```ts
       * const getSound = (a: Animal) => matcher(a)
       *     .lookup({
       *         cat: 'purr',
       *         dog: 'woof',
       *         snake: 'hiss',
       *     })
       * ```
       * @param table
       * @returns
       */
      lookup(table) {
        var _a;
        const combinedHandler = Object.assign(Object.assign({}, this.handler), tableToHandler(table));
        return (_a = combinedHandler[this.target[this.key]]) === null || _a === void 0 ? void 0 : _a.call(combinedHandler, this.target);
      }
      /**
       * Handle one or more cases, object-style.
       * @param variations
       */
      with(variations) {
        return new _Matcher(this.target, this.key, Object.assign(Object.assign({}, this.handler), variations));
      }
      // actual implementation
      when(variations, handler) {
        if (handler != void 0) {
          const list = Array.isArray(variations) ? variations : [variations];
          const newCases = list.reduce((acc, cur) => {
            const type = typeof cur === "string" ? cur : (0, variant_1.isVariantCreator)(cur) ? cur.output.type : void 0;
            return type != void 0 ? Object.assign(Object.assign({}, acc), { [type]: handler }) : acc;
          }, {});
          return new _Matcher(this.target, this.key, Object.assign(Object.assign({}, this.handler), newCases));
        } else {
          return new _Matcher(this.target, this.key, Object.assign(Object.assign({}, this.handler), variations));
        }
      }
    };
    exports.Matcher = Matcher;
    function matcherImpl(key) {
      function matcher(target) {
        const actualTarget = typeof target === "string" ? { [key]: target } : target;
        return new Matcher(actualTarget, key, {});
      }
      return { matcher };
    }
    exports.matcherImpl = matcherImpl;
  }
});

// ../../node_modules/variant/lib/cosmos.js
var require_cosmos = __commonJS({
  "../../node_modules/variant/lib/cosmos.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.variantCosmos = void 0;
    var isType_1 = require_isType();
    var match_1 = require_match();
    var variant_1 = require_variant();
    var types_1 = require_types();
    var flags_1 = require_flags();
    var isOfVariant_1 = require_isOfVariant();
    var remote_1 = require_remote();
    var typed_1 = require_typed();
    var matcher_1 = require_matcher();
    function variantCosmos({ key }) {
      const { isType } = (0, isType_1.isTypeImpl)(key);
      const { flags } = (0, flags_1.flagsImpl)(key);
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
        key,
        isType,
        flags
      }, (0, isOfVariant_1.isOfVariantImpl)(key)), (0, match_1.matchImpl)(key)), (0, matcher_1.matcherImpl)(key)), (0, remote_1.remoteImpl)(key)), (0, typed_1.typedImpl)(key)), (0, types_1.typesImpl)(key)), (0, variant_1.variantImpl)(key));
    }
    exports.variantCosmos = variantCosmos;
  }
});

// ../../node_modules/variant/lib/type/index.js
var require_type = __commonJS({
  "../../node_modules/variant/lib/type/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withFallback = exports.variation = exports.variantModule = exports.variantList = exports.variant = exports.types = exports.typed = exports.lookup = exports.sequence = exports.scoped = exports.remote = exports.prematch = exports.partial = exports.otherwise = exports.onLiteral = exports.ofLiteral = exports.matcher = exports.match = exports.isType = exports.isOfVariant = exports.inferTypes = exports.flags = exports.descope = void 0;
    var cosmos_1 = require_cosmos();
    _a = (0, cosmos_1.variantCosmos)({ key: "type" }), exports.descope = _a.descope, exports.flags = _a.flags, exports.inferTypes = _a.inferTypes, exports.isOfVariant = _a.isOfVariant, exports.isType = _a.isType, exports.match = _a.match, exports.matcher = _a.matcher, exports.ofLiteral = _a.ofLiteral, exports.onLiteral = _a.onLiteral, exports.otherwise = _a.otherwise, exports.partial = _a.partial, exports.prematch = _a.prematch, exports.remote = _a.remote, exports.scoped = _a.scoped, exports.sequence = _a.sequence, exports.lookup = _a.lookup, exports.typed = _a.typed, exports.types = _a.types, exports.variant = _a.variant, exports.variantList = _a.variantList, exports.variantModule = _a.variantModule, exports.variation = _a.variation, exports.withFallback = _a.withFallback;
  }
});

// ../../node_modules/variant/lib/augment.js
var require_augment = __commonJS({
  "../../node_modules/variant/lib/augment.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.augment = void 0;
    var type_1 = require_type();
    var variant_1 = require_variant();
    function augment(variantDefinition, f) {
      return Object.keys(variantDefinition).reduce((acc, key) => {
        let inputFunc = variantDefinition[key];
        let returnFunc = (0, variant_1.isVariantCreator)(inputFunc) ? (0, type_1.variation)(inputFunc.output.type, (...args) => {
          let result = inputFunc(...args);
          return Object.assign(Object.assign({}, f(result)), result);
        }) : (...args) => {
          const branch = variantDefinition[key];
          let item = typeof branch === "function" ? branch(...args) : {};
          return Object.assign(Object.assign({}, f(item)), item);
        };
        return Object.assign(Object.assign({}, acc), { [key]: returnFunc });
      }, {});
    }
    exports.augment = augment;
  }
});

// ../../node_modules/variant/lib/constrained.js
var require_constrained = __commonJS({
  "../../node_modules/variant/lib/constrained.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.constrained = void 0;
    function constrained(_constraint_, v) {
      return v;
    }
    exports.constrained = constrained;
  }
});

// ../../node_modules/variant/lib/construct.js
var require_construct = __commonJS({
  "../../node_modules/variant/lib/construct.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.construct = void 0;
    function construct(cls) {
      return (...args) => new cls(args);
    }
    exports.construct = construct;
  }
});

// ../../node_modules/variant/lib/generic.js
var require_generic = __commonJS({
  "../../node_modules/variant/lib/generic.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Alpha = exports.onTerms = void 0;
    var flags_1 = require_flags();
    var variant_1 = require_variant();
    var GENERIC_BRAND = Symbol("VARIANT GENERIC TEMPLATE");
    function onTerms(func) {
      return Object.assign(Object.assign({}, func(exports.Alpha)), { [GENERIC_BRAND]: void 0 });
    }
    exports.onTerms = onTerms;
    var GTERM = "__term";
    var genericTerms = (0, variant_1.variantImpl)(GTERM).variant;
    var flags = (0, flags_1.flagsImpl)(GTERM).flags;
    var GP = genericTerms([
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z"
    ]);
    exports.Alpha = flags(Object.values(GP).map((f) => f()));
  }
});

// ../../node_modules/variant/lib/typeCatalog.js
var require_typeCatalog = __commonJS({
  "../../node_modules/variant/lib/typeCatalog.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.typeMap = exports.typeCatalog = void 0;
    function typeCatalog(variant2) {
      return Object.values(variant2).reduce((result, vc) => {
        return Object.assign(Object.assign({}, result), { [vc.output.type]: vc.output.type });
      }, {});
    }
    exports.typeCatalog = typeCatalog;
    function typeMap(variant2) {
      return Object.keys(variant2).reduce((result, key) => {
        return Object.assign(Object.assign({}, result), { [key]: variant2[key].output.type });
      }, {});
    }
    exports.typeMap = typeMap;
  }
});

// ../../node_modules/variant/lib/catalog.js
var require_catalog = __commonJS({
  "../../node_modules/variant/lib/catalog.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.literalist = exports.catalog = void 0;
    function catalog(catalog2, factory) {
      if (Array.isArray(catalog2)) {
        return catalog2.reduce((result, current, index) => {
          return Object.assign(Object.assign({}, result), { [current]: factory != void 0 ? factory(current, index) : current });
        }, {});
      } else {
        return catalog2;
      }
    }
    exports.catalog = catalog;
    exports.literalist = catalog;
  }
});

// ../../node_modules/variant/lib/patterned.js
var require_patterned = __commonJS({
  "../../node_modules/variant/lib/patterned.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.patterned = void 0;
    function patterned(_constraint_, v) {
      return v;
    }
    exports.patterned = patterned;
  }
});

// ../../node_modules/variant/lib/variant.tools.js
var require_variant_tools = __commonJS({
  "../../node_modules/variant/lib/variant.tools.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nil = exports.payload = exports.fields = void 0;
    function fields2(defaults = {}) {
      return (...args) => {
        const [arg] = args;
        return Object.assign(Object.assign({}, defaults), arg);
      };
    }
    exports.fields = fields2;
    function payload(_example) {
      return (payload2) => ({ payload: payload2 });
    }
    exports.payload = payload;
    var nil = () => ({});
    exports.nil = nil;
  }
});

// ../../node_modules/variant/lib/slim.js
var require_slim = __commonJS({
  "../../node_modules/variant/lib/slim.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.payload = exports.nil = exports.fields = exports.HOI = exports.pass = exports.patterned = exports.unpack = exports.just = exports.constant = exports.literalist = exports.catalog = exports.typeCatalog = exports.typeMap = exports.onTerms = exports.variantCosmos = exports.construct = exports.constrained = exports.augment = void 0;
    var augment_1 = require_augment();
    Object.defineProperty(exports, "augment", { enumerable: true, get: function() {
      return augment_1.augment;
    } });
    var constrained_1 = require_constrained();
    Object.defineProperty(exports, "constrained", { enumerable: true, get: function() {
      return constrained_1.constrained;
    } });
    var construct_1 = require_construct();
    Object.defineProperty(exports, "construct", { enumerable: true, get: function() {
      return construct_1.construct;
    } });
    var cosmos_1 = require_cosmos();
    Object.defineProperty(exports, "variantCosmos", { enumerable: true, get: function() {
      return cosmos_1.variantCosmos;
    } });
    var generic_1 = require_generic();
    Object.defineProperty(exports, "onTerms", { enumerable: true, get: function() {
      return generic_1.onTerms;
    } });
    var typeCatalog_1 = require_typeCatalog();
    Object.defineProperty(exports, "typeMap", { enumerable: true, get: function() {
      return typeCatalog_1.typeMap;
    } });
    Object.defineProperty(exports, "typeCatalog", { enumerable: true, get: function() {
      return typeCatalog_1.typeCatalog;
    } });
    var catalog_1 = require_catalog();
    Object.defineProperty(exports, "catalog", { enumerable: true, get: function() {
      return catalog_1.catalog;
    } });
    Object.defineProperty(exports, "literalist", { enumerable: true, get: function() {
      return catalog_1.literalist;
    } });
    var match_tools_1 = require_match_tools();
    Object.defineProperty(exports, "constant", { enumerable: true, get: function() {
      return match_tools_1.constant;
    } });
    Object.defineProperty(exports, "just", { enumerable: true, get: function() {
      return match_tools_1.just;
    } });
    Object.defineProperty(exports, "unpack", { enumerable: true, get: function() {
      return match_tools_1.unpack;
    } });
    var patterned_1 = require_patterned();
    Object.defineProperty(exports, "patterned", { enumerable: true, get: function() {
      return patterned_1.patterned;
    } });
    var typed_1 = require_typed();
    Object.defineProperty(exports, "pass", { enumerable: true, get: function() {
      return typed_1.pass;
    } });
    var util_1 = require_util2();
    Object.defineProperty(exports, "HOI", { enumerable: true, get: function() {
      return util_1.HOI;
    } });
    var variant_tools_1 = require_variant_tools();
    Object.defineProperty(exports, "fields", { enumerable: true, get: function() {
      return variant_tools_1.fields;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return variant_tools_1.nil;
    } });
    Object.defineProperty(exports, "payload", { enumerable: true, get: function() {
      return variant_tools_1.payload;
    } });
  }
});

// ../../node_modules/variant/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/variant/lib/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_slim(), exports);
    __exportStar(require_type(), exports);
  }
});

// ../cli-error/src/index.ts
init_esm_shims();

// ../cli-error/src/cli-error.ts
init_esm_shims();
var import_verror = __toESM(require_verror(), 1);
var { WError } = import_verror.default;
function getNormalizedCause(cause) {
  if (cause == null) {
    return;
  }
  return cause instanceof Error ? cause : new Error(JSON.stringify(cause));
}
var CliError = class extends WError {
  cliCode;
  constructor(options) {
    const normalizedCause = getNormalizedCause(options.cause);
    super(
      {
        name: options.code.type,
        cause: normalizedCause,
        info: options.info
      },
      options.code.type
    );
    this.cliCode = options.code;
    this.name = options.code.type;
    if (false) {
      this.stack = `${this.stack}
caused by: ${import_verror.default.fullStack(normalizedCause)}`;
    }
  }
};

// ../cli-error/src/cli-error-codes.ts
init_esm_shims();
var import_variant = __toESM(require_lib(), 1);
var CliSystemErrorCode = (0, import_variant.variant)({
  FailedToGetDeviceCode: {},
  FailedToGetAuthToken: {},
  FailedToRenewAuthToken: {},
  FailedToRefreshTokenForSite: {},
  FailedToRevokeRefreshToken: (0, import_variant.fields)(),
  UnknownFailure: (0, import_variant.fields)(),
  FailedToFetchPackageJson: {},
  FailedToGetDeveloperApps: {},
  FailedToUpdateTelemetryConfig: {},
  FailedToSyncToRevision: (0, import_variant.fields)(),
  FailedToReadCache: (0, import_variant.fields)(),
  FailedToWriteCache: (0, import_variant.fields)(),
  UploadApplicationFailed: {},
  FailedToCreateDevCenterApp: {},
  FailedToCreateDevCenterOAuthApp: {},
  FailedToUpdateDevCenterOAuthApp: {},
  FailedToAddPermission: {},
  FailedToGetPlacements: {},
  FailedToGetAppSecret: {},
  FailedToCreateTunnel: {},
  FailedToDeleteTunnel: {},
  FailedToGetBlocksExtensionsData: {},
  FailedToGetBlocksStructure: {},
  FailedToUpdateBlocksAfterSync: {},
  GridAppFailedToUpdateFiles: {},
  FailedToCreateGridApp: (0, import_variant.fields)(),
  InvalidResponseData: {},
  InvalidCreateAppResponse: {},
  InvalidDeployAppResponse: {},
  InvalidGetDeploymentResponse: {},
  InvalidGetDeploymentPipelineDescriptionResponse: {},
  FailedToGetPagesDiff: {},
  InvalidViteBuildOutput: {},
  ViteModuleBundleNotFound: {},
  ViteFileNotFoundInOutput: (0, import_variant.fields)(),
  FailedToCreateBackendDeployment: {},
  FailedToUpdateBackendDeployment: {},
  FailedToGetBackendDeployment: {},
  FailedToDeployBackend: {},
  FailedToGetUserInfo: {},
  FailedToGetMyAccount: {},
  FailedToCreateDevelopmentSite: {},
  FailedToCreateMetaSiteFromTemplate: {},
  FailedToGetDevelopmentSites: {},
  FailedToGetDevelopmentSitesLimit: {},
  FailedToGetRequiredApps: {},
  FailedToQueryApps: {},
  FailedToGetMarketListing: {},
  FailedToAddRequiredApp: {},
  FailedToQuerySites: {},
  FailedToGetSite: {},
  FailedToDeploySite: {},
  FailedToDeploySitePreview: {},
  FailedToPublishDeployment: {},
  FailedToGetAppInstallationDetails: (0, import_variant.fields)(),
  TypeErrorInvalidUrl: {},
  FailedToGenerateSelfSignedCertificate: {},
  FailedToResolveViteOrigin: {},
  FailedToReleaseHeadlessProject: {},
  FailedToCreateAppRelease: {},
  FailedToParseHttpErrorResponse: {},
  FailedToUpdateAppRelease: {},
  FailedToCreateComponents: {},
  FailedToGetResolveNpmDependenciesResult: {},
  FailedToResolveNpmDependencies: {},
  FailedToFetchPackageDetails: {},
  FailedToCreateSiteOverride: {},
  FailedToGetDeploymentStatus: {},
  FailedToGetDeploymentPipelineDescription: {},
  FailedToGenerateAppMarketQueryParam: {},
  InvalidDependenciesJsonSchemaError: (0, import_variant.fields)(),
  FailedToParseLog: {},
  FailedToConnectToLogsService: {},
  LogsConnectionTimeout: {},
  FailedToFetchAppForVersion: {},
  InvalidSiteOverrideID: {},
  FailedToFindEsbuildOutputFile: {},
  FailedOptimizingWithEsbuild: {},
  FailedReadingEsbuildOutputFile: {},
  InvalidGitUrl: (0, import_variant.fields)(),
  TemplatePathNotFound: (0, import_variant.fields)(),
  FailedToQueryCliAppTemplates: {},
  FailedToCreateDevCenterAppFromTemplate: {},
  FailedToGetSiteInstalledApps: {},
  FailedToGetSiteInstalledAppInstanceId: {},
  FailedToGetClientSpecMap: {},
  FailedToCreateVeloApp: {},
  FailedToUpdateVeloAppFiles: {},
  FailedToGetFilesFromVelo: {},
  FailedToSyncPagesTypes: {},
  FailedToCreateDraftVersion: {},
  FailedToReleaseDraftVersion: {},
  FailedToDeployDocument: {},
  WaitForEditorInstallationStateFailure: {},
  EditorPendingInstallationCheckTimedout: {},
  FailedToParseLatestVersion: (0, import_variant.fields)(),
  FailedToGetMonitoringLoaderScript: (0, import_variant.fields)(),
  FailedToFetchWixLockFile: {},
  FailedToGetSdkSlotData: {},
  FailedToListComponentByComponentType: {},
  FailedToParseBackofficeExtensionContainer: {},
  FailedToParseBackofficePages: {},
  FailedToPullEnvironment: {},
  FailedToSetEnvironmentVariable: {},
  FailedToRemoveEnvironmentVariable: {},
  FailedToUploadStaticFiles: {},
  FailedCreatingAppProject: {},
  FailedCreatingAppDeployment: {},
  FailedFinalizingAppDeployment: {},
  FailedToFindAstroConfig: {}
});
var CliUserErrorCode = (0, import_variant.variant)({
  LatestVersionOfCreateAppRequired: (0, import_variant.fields)(),
  FailedToCreateProjectFolder: (0, import_variant.fields)(),
  EmptyDirectoryRequiredAppGeneration: (0, import_variant.fields)(),
  InvalidNewPackageName: (0, import_variant.fields)(),
  UnsupportedPackageManager: (0, import_variant.fields)(),
  UnsupportedPackageManagerWorkspaces: (0, import_variant.fields)(),
  FailedAddingPackageToWorkspace: {},
  SitePermissionDenied: (0, import_variant.fields)(),
  AppPermissionDenied: (0, import_variant.fields)(),
  BuiltProjectNeeded: {},
  WixUninstallMissingPackageName: {},
  FailedToReadJson: (0, import_variant.fields)(),
  FailedToReadFile: (0, import_variant.fields)(),
  FailedToWriteJson: (0, import_variant.fields)(),
  FailedToWriteFile: (0, import_variant.fields)(),
  FailedToCreateDir: (0, import_variant.fields)(),
  InvalidJsonFile: (0, import_variant.fields)(),
  FailedToWriteWixLock: {},
  InvalidVeloConfigJson: (0, import_variant.fields)(),
  DashboardPageConfigNotFound: (0, import_variant.fields)(),
  EmbeddedScriptConfigNotFound: (0, import_variant.fields)(),
  NoExtensionsFound: {},
  CustomElementConfigNotFound: (0, import_variant.fields)(),
  SitePluginConfigNotFound: (0, import_variant.fields)(),
  BlocksWidgetApiNotFound: (0, import_variant.fields)(),
  BlocksWidgetConfigNotFound: (0, import_variant.fields)(),
  BlocksWidgetPanelConfigNotFound: (0, import_variant.fields)(),
  NoPagesDirectoryFound: (0, import_variant.fields)(),
  DashboardPluginConfigNotFound: (0, import_variant.fields)(),
  DashboardMenuPluginConfigNotFound: (0, import_variant.fields)(),
  ServicePluginConfigNotFound: (0, import_variant.fields)(),
  DashboardModalConfigNotFound: (0, import_variant.fields)(),
  TSConfigNotFound: (0, import_variant.fields)(),
  InvalidTSConfigError: (0, import_variant.fields)(),
  InvalidConfigSchemaError: (0, import_variant.fields)(),
  InvalidParamsOverrideSchemaError: (0, import_variant.fields)(),
  PermissionDenied: {},
  SiteSelectorTimedout: {},
  FailedToReadProjectFiles: {},
  GridAppFilesMaxLengthExceeded: (0, import_variant.fields)(),
  DeviceCodeTimedOut: {},
  DuplicateComponentIdsError: (0, import_variant.fields)(),
  FailedToSaveDevelopmentSite: (0, import_variant.fields)(),
  FailedToBuildApp: {},
  FailedToInitializeGitRepo: {},
  FailedToInstallDependencies: {},
  FailedToCommitChanges: {},
  FailedToDeleteAuthData: {},
  FailedToDeleteLegacyAuthData: {},
  FailedToSaveAuthData: {},
  FailedToSaveApiKeyAuthData: {},
  FailedToRenewAuthTokenSiteNotFound: (0, import_variant.fields)(),
  FailedToRenewAuthTokenRefreshTokenRevoked: {},
  FailedToInstallPackage: (0, import_variant.fields)(),
  FailedToInstallPackages: {},
  FailedToUninstallPackage: (0, import_variant.fields)(),
  FailedMigrationToAnyNpm: {},
  FailedToCloneRepo: {},
  AuthenticationRequired: {},
  SiteConfiguredRequired: {},
  NonInteractiveTerminal: {},
  FailedToWatchFiles: {},
  InvalidApiKey: {},
  CliAppVersionMismatch: (0, import_variant.fields)(),
  NetworkError: {},
  AppForVersionNotFound: (0, import_variant.fields)(),
  UnknownServicePlugin: (0, import_variant.fields)(),
  InvalidServicePluginFolder: (0, import_variant.fields)(),
  FailedToGetLogsTopology: {},
  FailedInstallCloudflareNoAccess: (0, import_variant.fields)(),
  CliAppTemplateNotFound: (0, import_variant.fields)(),
  LocalTemplatePathNotFound: (0, import_variant.fields)(),
  DeniedPermissionToGetAppSecret: {},
  FailedToOpenBrowser: {},
  DeprecatedVersion: (0, import_variant.fields)(),
  InvalidDashboardPageRoute: (0, import_variant.fields)(),
  InvalidEmbeddedScriptFolder: (0, import_variant.fields)(),
  InvalidEmbeddedScriptTemplate: (0, import_variant.fields)(),
  InvalidCustomElementTagName: (0, import_variant.fields)(),
  InvalidSiteFrontendPackageVersion: (0, import_variant.fields)(),
  InvalidServicePluginImplementation: (0, import_variant.fields)(),
  FailedToInitializeSiteFsManager: {},
  FailedToGetSiteFsManagerCode: {},
  FailedToGetSiteFsManagerDocument: {},
  FailedToApplySiteFsManagerFsUpdates: {},
  FailedToApplySiteFsManagerExternalUpdates: {},
  ServeDeprecated: (0, import_variant.fields)(),
  CannotFindConfigReferencedAsset: (0, import_variant.fields)(),
  CannotReleaseLockedApplication: {},
  FailedToCreateIntellisenseAdapter: {},
  FailedToInitIntellisenseAdapterTypes: {},
  FailedToUpdateIntellisenseAdapterTypes: {},
  WebMethodOutsideOfProjectDirectory: (0, import_variant.fields)(),
  FailedToEvalBackendExtension: (0, import_variant.fields)(),
  DeploymentPipelineFailed: (0, import_variant.fields)(),
  InsufficientNonInterractiveReleaseParameters: {},
  AppNameArgumentIsInvalid: (0, import_variant.fields)(),
  CannotReleaseMinorInNoninteractive: {},
  SiteComponentConfigNotFound: (0, import_variant.fields)(),
  SiteComponentPanelConfigNotFound: (0, import_variant.fields)(),
  SiteComponentPanelDoNotExists: (0, import_variant.fields)(),
  FailedToImportCliApp: {},
  FailedToCleanDistFolder: {},
  FailedToIdentifyProgramFlow: (0, import_variant.fields)(),
  BuildOutputMissing: (0, import_variant.fields)(),
  FailedToCreateMonitoringVitePlugin: (0, import_variant.fields)(),
  FailedToSyncVeloCLIServerDocumentUpdate: {},
  AppReleaseConfigViolations: (0, import_variant.fields)(),
  ProjectIsAlreadyLinked: {},
  ProjectIsNotLinkable: {}
});
var CliErrorCode = (0, import_variant.variant)({
  ...CliSystemErrorCode,
  ...CliUserErrorCode
});

// ../cli-error/src/is-cli-error.ts
init_esm_shims();
var import_variant2 = __toESM(require_lib(), 1);
function isCliError(error) {
  if (error && typeof error === "object" && "cliCode" in error) {
    return (0, import_variant2.isOfVariant)(error.cliCode, CliErrorCode);
  }
  return false;
}
function isCliSystemError(error) {
  return (0, import_variant2.isOfVariant)(error.cliCode, CliSystemErrorCode);
}

// ../cli-error/src/normalize-error.ts
init_esm_shims();
var import_variant3 = __toESM(require_lib(), 1);
var import_verror2 = __toESM(require_verror(), 1);
function getFirstUserError(error) {
  if (isCliError(error) && (0, import_variant3.isOfVariant)(error.cliCode, CliUserErrorCode)) {
    return error;
  }
  const nestedError = import_verror2.default.cause(error);
  return nestedError ? getFirstUserError(nestedError) : null;
}
function normalizeError(error) {
  const cliError = isCliError(error) ? error : new CliError({
    code: CliErrorCode.UnknownFailure({ error }),
    cause: error
  });
  const firstUserError = getFirstUserError(cliError);
  return firstUserError ?? cliError;
}

export {
  require_lib,
  require_verror,
  CliError,
  CliSystemErrorCode,
  CliErrorCode,
  isCliError,
  isCliSystemError,
  normalizeError
};
//# sourceMappingURL=chunk-IVMK6TVY.js.map