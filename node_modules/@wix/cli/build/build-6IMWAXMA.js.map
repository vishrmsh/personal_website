{"version":3,"sources":["../../../node_modules/opentelemetry-instrumentation-fetch-node/src/index.ts"],"sourcesContent":["/*\n * Portions from https://github.com/elastic/apm-agent-nodejs\n * Copyright Elasticsearch B.V. and other contributors where applicable.\n * Licensed under the BSD 2-Clause License; you may not use this file except in\n * compliance with the BSD 2-Clause License.\n *\n */\nimport diagch from 'node:diagnostics_channel';\n\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { Instrumentation, InstrumentationConfig } from '@opentelemetry/instrumentation';\nimport {\n  Attributes,\n  context,\n  Meter,\n  MeterProvider,\n  metrics,\n  propagation,\n  Span,\n  SpanKind,\n  SpanStatusCode,\n  trace,\n  Tracer,\n  TracerProvider,\n} from '@opentelemetry/api';\n\ninterface ListenerRecord {\n  name: string;\n  channel: diagch.Channel;\n  onMessage: diagch.ChannelListener;\n}\n\ninterface FetchRequest {\n  method: string;\n  origin: string;\n  path: string;\n  headers: string | string[];\n}\n\ninterface FetchResponse {\n  headers: Buffer[];\n  statusCode: number;\n}\n\nexport interface FetchInstrumentationConfig extends InstrumentationConfig {\n  ignoreRequestHook?: (request: FetchRequest) => boolean;\n  onRequest?: (args: {\n    request: FetchRequest;\n    span: Span;\n    additionalHeaders: Record<string, string | string[]>;\n  }) => void;\n}\n\nfunction getMessage(error: Error) {\n  if (error instanceof AggregateError) {\n    return error.errors.map((e) => e.message).join(', ');\n  }\n  return error.message;\n}\n\n// Get the content-length from undici response headers.\n// `headers` is an Array of buffers: [k, v, k, v, ...].\n// If the header is not present, or has an invalid value, this returns null.\nfunction contentLengthFromResponseHeaders(headers: Buffer[]) {\n  const name = 'content-length';\n  for (let i = 0; i < headers.length; i += 2) {\n    const k = headers[i];\n    if (k.length === name.length && k.toString().toLowerCase() === name) {\n      const v = Number(headers[i + 1]);\n      if (!Number.isNaN(Number(v))) {\n        return v;\n      }\n      return undefined;\n    }\n  }\n  return undefined;\n}\n\nasync function loadFetch() {\n  try {\n    await fetch('');\n  } catch (_) {\n    //\n  }\n}\n\n// A combination of https://github.com/elastic/apm-agent-nodejs and\n// https://github.com/gadget-inc/opentelemetry-instrumentations/blob/main/packages/opentelemetry-instrumentation-undici/src/index.ts\nexport class FetchInstrumentation implements Instrumentation {\n  // Keep ref to avoid https://github.com/nodejs/node/issues/42170 bug and for\n  // unsubscribing.\n  private channelSubs: Array<ListenerRecord> | undefined;\n\n  private spanFromReq = new WeakMap<FetchRequest, Span>();\n\n  private tracer: Tracer;\n\n  private config: FetchInstrumentationConfig;\n\n  private meter: Meter;\n\n  public readonly instrumentationName = 'opentelemetry-instrumentation-node-18-fetch';\n\n  public readonly instrumentationVersion = '1.0.0';\n\n  public readonly instrumentationDescription =\n    'Instrumentation for Node 18 fetch via diagnostics_channel';\n\n  private subscribeToChannel(diagnosticChannel: string, onMessage: diagch.ChannelListener) {\n    const channel = diagch.channel(diagnosticChannel);\n    channel.subscribe(onMessage);\n    this.channelSubs!.push({\n      name: diagnosticChannel,\n      channel,\n      onMessage,\n    });\n  }\n\n  constructor(config: FetchInstrumentationConfig) {\n    // Force load fetch API (since it's lazy loaded in Node 18)\n    loadFetch();\n    this.channelSubs = [];\n    this.meter = metrics.getMeter(this.instrumentationName, this.instrumentationVersion);\n    this.tracer = trace.getTracer(this.instrumentationName, this.instrumentationVersion);\n    this.config = { ...config };\n  }\n\n  disable(): void {\n    this.channelSubs?.forEach((sub) => sub.channel.unsubscribe(sub.onMessage));\n  }\n\n  enable(): void {\n    this.subscribeToChannel('undici:request:create', (args) =>\n      this.onRequest(args as { request: FetchRequest }),\n    );\n    this.subscribeToChannel('undici:request:headers', (args) =>\n      this.onHeaders(args as { request: FetchRequest; response: FetchResponse }),\n    );\n    this.subscribeToChannel('undici:request:trailers', (args) =>\n      this.onDone(args as { request: FetchRequest }),\n    );\n    this.subscribeToChannel('undici:request:error', (args) =>\n      this.onError(args as { request: FetchRequest; error: Error }),\n    );\n  }\n\n  setTracerProvider(tracerProvider: TracerProvider): void {\n    this.tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);\n  }\n\n  public setMeterProvider(meterProvider: MeterProvider): void {\n    this.meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);\n  }\n\n  setConfig(config: InstrumentationConfig): void {\n    this.config = { ...config };\n  }\n\n  getConfig(): InstrumentationConfig {\n    return this.config;\n  }\n\n  onRequest({ request }: { request: FetchRequest }): void {\n    // Don't instrument CONNECT - see comments at:\n    // https://github.com/elastic/apm-agent-nodejs/blob/c55b1d8c32b2574362fc24d81b8e173ce2f75257/lib/instrumentation/modules/undici.js#L24\n    if (request.method === 'CONNECT') {\n      return;\n    }\n    if (this.config.ignoreRequestHook && this.config.ignoreRequestHook(request) === true) {\n      return;\n    }\n\n    const span = this.tracer.startSpan(`HTTP ${request.method}`, {\n      kind: SpanKind.CLIENT,\n      attributes: {\n        [SemanticAttributes.HTTP_URL]: getAbsoluteUrl(request.origin, request.path),\n        [SemanticAttributes.HTTP_METHOD]: request.method,\n        [SemanticAttributes.HTTP_TARGET]: request.path,\n        'http.client': 'fetch',\n      },\n    });\n    const requestContext = trace.setSpan(context.active(), span);\n    const addedHeaders: Record<string, string> = {};\n    propagation.inject(requestContext, addedHeaders);\n\n    if (this.config.onRequest) {\n      this.config.onRequest({ request, span, additionalHeaders: addedHeaders });\n    }\n\n    if (Array.isArray(request.headers)) {\n      request.headers.push(...Object.entries(addedHeaders).flat());\n    } else {\n      request.headers += Object.entries(addedHeaders)\n        .map(([k, v]) => `${k}: ${v}\\r\\n`)\n        .join('');\n    }\n    this.spanFromReq.set(request, span);\n  }\n\n  onHeaders({ request, response }: { request: FetchRequest; response: FetchResponse }): void {\n    const span = this.spanFromReq.get(request);\n\n    if (span !== undefined) {\n      // We are currently *not* capturing response headers, even though the\n      // intake API does allow it, because none of the other `setHttpContext`\n      // uses currently do.\n\n      const cLen = contentLengthFromResponseHeaders(response.headers);\n      const attrs: Attributes = {\n        [SemanticAttributes.HTTP_STATUS_CODE]: response.statusCode,\n      };\n      if (cLen) {\n        attrs[SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH] = cLen;\n      }\n      span.setAttributes(attrs);\n      span.setStatus({\n        code: response.statusCode >= 400 ? SpanStatusCode.ERROR : SpanStatusCode.OK,\n        message: String(response.statusCode),\n      });\n    }\n  }\n\n  onDone({ request }: { request: FetchRequest }): void {\n    const span = this.spanFromReq.get(request);\n    if (span !== undefined) {\n      span.end();\n      this.spanFromReq.delete(request);\n    }\n  }\n\n  onError({ request, error }: { request: FetchRequest; error: Error }): void {\n    const span = this.spanFromReq.get(request);\n    if (span !== undefined) {\n      span.recordException(error);\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: getMessage(error),\n      });\n      span.end();\n    }\n  }\n}\n\nfunction getAbsoluteUrl(origin: string, path: string = '/'): string {\n  const url = `${origin}`;\n\n  if (origin.endsWith('/') && path.startsWith('/')) {\n    return `${url}${path.slice(1)}`;\n  }\n\n  if (!origin.endsWith('/') && !path.startsWith('/')) {\n    return `${url}/${path.slice(1)}`;\n  }\n\n  return `${url}${path}`;\n}\n"],"mappings":"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","names":[]}