import { createRequire as _createRequire } from 'node:module';
const require = _createRequire(import.meta.url);
import {
  NO_TTY_JSON_OUTPUT_OPTION
} from "./chunk-OXS2RGRR.js";
import {
  Argument,
  Command,
  createCommand
} from "./chunk-J2EPR7DO.js";
import {
  globby
} from "./chunk-PIXNEJ52.js";
import "./chunk-HWVLWVTF.js";
import {
  createBiLogger,
  package_default
} from "./chunk-DBMP7T24.js";
import "./chunk-3WK2RM54.js";
import {
  getUserInfo,
  pTimeout
} from "./chunk-67NUBEMP.js";
import {
  OutdatedVersionMessage,
  createErrorHandler,
  createFsCache,
  getFsCacheFilePath,
  require_prerelease,
  require_semver,
  writeCrashReport
} from "./chunk-WWUS5636.js";
import "./chunk-SJKVYZPL.js";
import "./chunk-UQLHXG4X.js";
import "./chunk-KJ37XZQA.js";
import {
  render
} from "./chunk-RXATQXHV.js";
import {
  require_react
} from "./chunk-NRAQAV6T.js";
import {
  source_default
} from "./chunk-SQ3KPTIH.js";
import "./chunk-Z4MHKCET.js";
import "./chunk-C4SUTB4O.js";
import "./chunk-SE7QGYXZ.js";
import {
  SENTRY_DSN,
  VERSION_CACHE_FILENAME,
  WIX_CONFIG_FILENAME,
  getDebugLogFilePath,
  getUserFeedbackCacheFilePath,
  getWixConfigFilePath
} from "./chunk-TKDDSH55.js";
import "./chunk-62BYZXT7.js";
import {
  getTestOverrides,
  setupTestEnv
} from "./chunk-WYHHEOWO.js";
import {
  pathExists,
  readJson
} from "./chunk-Z3Y5NFYG.js";
import {
  z
} from "./chunk-ZXYGJZOO.js";
import {
  CliError,
  CliErrorCode,
  require_lib
} from "./chunk-IVMK6TVY.js";
import {
  __commonJS,
  __dirname,
  __require,
  __toESM,
  init_esm_shims
} from "./chunk-4EFJZ3GQ.js";

// ../../node_modules/ini/ini.js
var require_ini = __commonJS({
  "../../node_modules/ini/ini.js"(exports) {
    "use strict";
    init_esm_shims();
    exports.parse = exports.decode = decode;
    exports.stringify = exports.encode = encode;
    exports.safe = safe;
    exports.unsafe = unsafe;
    var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
    function encode(obj, opt) {
      var children = [];
      var out = "";
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        };
      } else {
        opt = opt || {};
        opt.whitespace = opt.whitespace === true;
      }
      var separator = opt.whitespace ? " = " : "=";
      Object.keys(obj).forEach(function(k, _, __) {
        var val = obj[k];
        if (val && Array.isArray(val)) {
          val.forEach(function(item) {
            out += safe(k + "[]") + separator + safe(item) + "\n";
          });
        } else if (val && typeof val === "object")
          children.push(k);
        else
          out += safe(k) + separator + safe(val) + eol;
      });
      if (opt.section && out.length)
        out = "[" + safe(opt.section) + "]" + eol + out;
      children.forEach(function(k, _, __) {
        var nk = dotSplit(k).join("\\.");
        var section = (opt.section ? opt.section + "." : "") + nk;
        var child = encode(obj[k], {
          section,
          whitespace: opt.whitespace
        });
        if (out.length && child.length)
          out += eol;
        out += child;
      });
      return out;
    }
    function dotSplit(str) {
      return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
        return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
      });
    }
    function decode(str) {
      var out = {};
      var p = out;
      var section = null;
      var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      var lines = str.split(/[\r\n]+/g);
      lines.forEach(function(line, _, __) {
        if (!line || line.match(/^\s*[;#]/))
          return;
        var match3 = line.match(re);
        if (!match3)
          return;
        if (match3[1] !== void 0) {
          section = unsafe(match3[1]);
          if (section === "__proto__") {
            p = {};
            return;
          }
          p = out[section] = out[section] || {};
          return;
        }
        var key = unsafe(match3[2]);
        if (key === "__proto__")
          return;
        var value = match3[3] ? unsafe(match3[4]) : true;
        switch (value) {
          case "true":
          case "false":
          case "null":
            value = JSON.parse(value);
        }
        if (key.length > 2 && key.slice(-2) === "[]") {
          key = key.substring(0, key.length - 2);
          if (key === "__proto__")
            return;
          if (!p[key])
            p[key] = [];
          else if (!Array.isArray(p[key]))
            p[key] = [p[key]];
        }
        if (Array.isArray(p[key]))
          p[key].push(value);
        else
          p[key] = value;
      });
      Object.keys(out).filter(function(k, _, __) {
        if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k]))
          return false;
        var parts = dotSplit(k);
        var p2 = out;
        var l = parts.pop();
        var nl = l.replace(/\\\./g, ".");
        parts.forEach(function(part, _2, __2) {
          if (part === "__proto__")
            return;
          if (!p2[part] || typeof p2[part] !== "object")
            p2[part] = {};
          p2 = p2[part];
        });
        if (p2 === out && nl === l)
          return false;
        p2[nl] = out[k];
        return true;
      }).forEach(function(del, _, __) {
        delete out[del];
      });
      return out;
    }
    function isQuoted(val) {
      return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
    }
    function safe(val) {
      return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
    }
    function unsafe(val, doUnesc) {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'")
          val = val.substr(1, val.length - 2);
        try {
          val = JSON.parse(val);
        } catch (_) {
        }
      } else {
        var esc = false;
        var unesc = "";
        for (var i = 0, l = val.length; i < l; i++) {
          var c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1)
              unesc += c;
            else
              unesc += "\\" + c;
            esc = false;
          } else if (";#".indexOf(c) !== -1)
            break;
          else if (c === "\\")
            esc = true;
          else
            unesc += c;
        }
        if (esc)
          unesc += "\\";
        return unesc.trim();
      }
      return val;
    }
  }
});

// ../../node_modules/rc/node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS({
  "../../node_modules/rc/node_modules/strip-json-comments/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var singleComment = 1;
    var multiComment = 2;
    function stripWithoutWhitespace() {
      return "";
    }
    function stripWithWhitespace(str, start, end) {
      return str.slice(start, end).replace(/\S/g, " ");
    }
    module.exports = function(str, opts) {
      opts = opts || {};
      var currentChar;
      var nextChar;
      var insideString = false;
      var insideComment = false;
      var offset = 0;
      var ret = "";
      var strip = opts.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
      for (var i = 0; i < str.length; i++) {
        currentChar = str[i];
        nextChar = str[i + 1];
        if (!insideComment && currentChar === '"') {
          var escaped = str[i - 1] === "\\" && str[i - 2] !== "\\";
          if (!escaped) {
            insideString = !insideString;
          }
        }
        if (insideString) {
          continue;
        }
        if (!insideComment && currentChar + nextChar === "//") {
          ret += str.slice(offset, i);
          offset = i;
          insideComment = singleComment;
          i++;
        } else if (insideComment === singleComment && currentChar + nextChar === "\r\n") {
          i++;
          insideComment = false;
          ret += strip(str, offset, i);
          offset = i;
          continue;
        } else if (insideComment === singleComment && currentChar === "\n") {
          insideComment = false;
          ret += strip(str, offset, i);
          offset = i;
        } else if (!insideComment && currentChar + nextChar === "/*") {
          ret += str.slice(offset, i);
          offset = i;
          insideComment = multiComment;
          i++;
          continue;
        } else if (insideComment === multiComment && currentChar + nextChar === "*/") {
          i++;
          insideComment = false;
          ret += strip(str, offset, i + 1);
          offset = i + 1;
          continue;
        }
      }
      return ret + (insideComment ? strip(str.substr(offset)) : str.substr(offset));
    };
  }
});

// ../../node_modules/rc/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/rc/lib/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    var fs = __require("fs");
    var ini = require_ini();
    var path = __require("path");
    var stripJsonComments = require_strip_json_comments();
    var parse = exports.parse = function(content) {
      if (/^\s*{/.test(content))
        return JSON.parse(stripJsonComments(content));
      return ini.parse(content);
    };
    var file = exports.file = function() {
      var args = [].slice.call(arguments).filter(function(arg) {
        return arg != null;
      });
      for (var i in args)
        if ("string" !== typeof args[i])
          return;
      var file2 = path.join.apply(null, args);
      var content;
      try {
        return fs.readFileSync(file2, "utf-8");
      } catch (err) {
        return;
      }
    };
    var json = exports.json = function() {
      var content = file.apply(null, arguments);
      return content ? parse(content) : null;
    };
    var env2 = exports.env = function(prefix, env3) {
      env3 = env3 || process.env;
      var obj = {};
      var l = prefix.length;
      for (var k in env3) {
        if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
          var keypath = k.substring(l).split("__");
          var _emptyStringIndex;
          while ((_emptyStringIndex = keypath.indexOf("")) > -1) {
            keypath.splice(_emptyStringIndex, 1);
          }
          var cursor = obj;
          keypath.forEach(function _buildSubObj(_subkey, i) {
            if (!_subkey || typeof cursor !== "object")
              return;
            if (i === keypath.length - 1)
              cursor[_subkey] = env3[k];
            if (cursor[_subkey] === void 0)
              cursor[_subkey] = {};
            cursor = cursor[_subkey];
          });
        }
      }
      return obj;
    };
    var find = exports.find = function() {
      var rel = path.join.apply(null, [].slice.call(arguments));
      function find2(start, rel2) {
        var file2 = path.join(start, rel2);
        try {
          fs.statSync(file2);
          return file2;
        } catch (err) {
          if (path.dirname(start) !== start)
            return find2(path.dirname(start), rel2);
        }
      }
      return find2(process.cwd(), rel);
    };
  }
});

// ../../node_modules/deep-extend/lib/deep-extend.js
var require_deep_extend = __commonJS({
  "../../node_modules/deep-extend/lib/deep-extend.js"(exports, module) {
    "use strict";
    init_esm_shims();
    function isSpecificValue(val) {
      return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
    }
    function cloneSpecificValue(val) {
      if (val instanceof Buffer) {
        var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
        val.copy(x);
        return x;
      } else if (val instanceof Date) {
        return new Date(val.getTime());
      } else if (val instanceof RegExp) {
        return new RegExp(val);
      } else {
        throw new Error("Unexpected situation");
      }
    }
    function deepCloneArray(arr) {
      var clone = [];
      arr.forEach(function(item, index) {
        if (typeof item === "object" && item !== null) {
          if (Array.isArray(item)) {
            clone[index] = deepCloneArray(item);
          } else if (isSpecificValue(item)) {
            clone[index] = cloneSpecificValue(item);
          } else {
            clone[index] = deepExtend({}, item);
          }
        } else {
          clone[index] = item;
        }
      });
      return clone;
    }
    function safeGetProperty(object, property) {
      return property === "__proto__" ? void 0 : object[property];
    }
    var deepExtend = module.exports = function() {
      if (arguments.length < 1 || typeof arguments[0] !== "object") {
        return false;
      }
      if (arguments.length < 2) {
        return arguments[0];
      }
      var target = arguments[0];
      var args = Array.prototype.slice.call(arguments, 1);
      var val, src, clone;
      args.forEach(function(obj) {
        if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
          return;
        }
        Object.keys(obj).forEach(function(key) {
          src = safeGetProperty(target, key);
          val = safeGetProperty(obj, key);
          if (val === target) {
            return;
          } else if (typeof val !== "object" || val === null) {
            target[key] = val;
            return;
          } else if (Array.isArray(val)) {
            target[key] = deepCloneArray(val);
            return;
          } else if (isSpecificValue(val)) {
            target[key] = cloneSpecificValue(val);
            return;
          } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
            target[key] = deepExtend({}, val);
            return;
          } else {
            target[key] = deepExtend(src, val);
            return;
          }
        });
      });
      return target;
    };
  }
});

// ../../node_modules/minimist/index.js
var require_minimist = __commonJS({
  "../../node_modules/minimist/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    function hasKey(obj, keys) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      var key = keys[keys.length - 1];
      return key in o;
    }
    function isNumber(x) {
      if (typeof x === "number") {
        return true;
      }
      if (/^0x[0-9a-f]+$/i.test(x)) {
        return true;
      }
      return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function isConstructorOrProto(obj, key) {
      return key === "constructor" && typeof obj[key] === "function" || key === "__proto__";
    }
    module.exports = function(args, opts) {
      if (!opts) {
        opts = {};
      }
      var flags = {
        bools: {},
        strings: {},
        unknownFn: null
      };
      if (typeof opts.unknown === "function") {
        flags.unknownFn = opts.unknown;
      }
      if (typeof opts.boolean === "boolean" && opts.boolean) {
        flags.allBools = true;
      } else {
        [].concat(opts.boolean).filter(Boolean).forEach(function(key2) {
          flags.bools[key2] = true;
        });
      }
      var aliases = {};
      function aliasIsBoolean(key2) {
        return aliases[key2].some(function(x) {
          return flags.bools[x];
        });
      }
      Object.keys(opts.alias || {}).forEach(function(key2) {
        aliases[key2] = [].concat(opts.alias[key2]);
        aliases[key2].forEach(function(x) {
          aliases[x] = [key2].concat(aliases[key2].filter(function(y) {
            return x !== y;
          }));
        });
      });
      [].concat(opts.string).filter(Boolean).forEach(function(key2) {
        flags.strings[key2] = true;
        if (aliases[key2]) {
          [].concat(aliases[key2]).forEach(function(k) {
            flags.strings[k] = true;
          });
        }
      });
      var defaults = opts.default || {};
      var argv = { _: [] };
      function argDefined(key2, arg2) {
        return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key2] || flags.bools[key2] || aliases[key2];
      }
      function setKey(obj, keys, value2) {
        var o = obj;
        for (var i2 = 0; i2 < keys.length - 1; i2++) {
          var key2 = keys[i2];
          if (isConstructorOrProto(o, key2)) {
            return;
          }
          if (o[key2] === void 0) {
            o[key2] = {};
          }
          if (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype) {
            o[key2] = {};
          }
          if (o[key2] === Array.prototype) {
            o[key2] = [];
          }
          o = o[key2];
        }
        var lastKey = keys[keys.length - 1];
        if (isConstructorOrProto(o, lastKey)) {
          return;
        }
        if (o === Object.prototype || o === Number.prototype || o === String.prototype) {
          o = {};
        }
        if (o === Array.prototype) {
          o = [];
        }
        if (o[lastKey] === void 0 || flags.bools[lastKey] || typeof o[lastKey] === "boolean") {
          o[lastKey] = value2;
        } else if (Array.isArray(o[lastKey])) {
          o[lastKey].push(value2);
        } else {
          o[lastKey] = [o[lastKey], value2];
        }
      }
      function setArg(key2, val, arg2) {
        if (arg2 && flags.unknownFn && !argDefined(key2, arg2)) {
          if (flags.unknownFn(arg2) === false) {
            return;
          }
        }
        var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
        setKey(argv, key2.split("."), value2);
        (aliases[key2] || []).forEach(function(x) {
          setKey(argv, x.split("."), value2);
        });
      }
      Object.keys(flags.bools).forEach(function(key2) {
        setArg(key2, defaults[key2] === void 0 ? false : defaults[key2]);
      });
      var notFlags = [];
      if (args.indexOf("--") !== -1) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
      }
      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        var key;
        var next;
        if (/^--.+=/.test(arg)) {
          var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
          key = m[1];
          var value = m[2];
          if (flags.bools[key]) {
            value = value !== "false";
          }
          setArg(key, value, arg);
        } else if (/^--no-.+/.test(arg)) {
          key = arg.match(/^--no-(.+)/)[1];
          setArg(key, false, arg);
        } else if (/^--.+/.test(arg)) {
          key = arg.match(/^--(.+)/)[1];
          next = args[i + 1];
          if (next !== void 0 && !/^(-|--)[^-]/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
            setArg(key, next, arg);
            i += 1;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key, next === "true", arg);
            i += 1;
          } else {
            setArg(key, flags.strings[key] ? "" : true, arg);
          }
        } else if (/^-[^-]+/.test(arg)) {
          var letters = arg.slice(1, -1).split("");
          var broken = false;
          for (var j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (next === "-") {
              setArg(letters[j], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && next[0] === "=") {
              setArg(letters[j], next.slice(1), arg);
              broken = true;
              break;
            }
            if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next, arg);
              broken = true;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2), arg);
              broken = true;
              break;
            } else {
              setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
            }
          }
          key = arg.slice(-1)[0];
          if (!broken && key !== "-") {
            if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
              setArg(key, args[i + 1], arg);
              i += 1;
            } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
              setArg(key, args[i + 1] === "true", arg);
              i += 1;
            } else {
              setArg(key, flags.strings[key] ? "" : true, arg);
            }
          }
        } else {
          if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
            argv._.push(flags.strings._ || !isNumber(arg) ? arg : Number(arg));
          }
          if (opts.stopEarly) {
            argv._.push.apply(argv._, args.slice(i + 1));
            break;
          }
        }
      }
      Object.keys(defaults).forEach(function(k) {
        if (!hasKey(argv, k.split("."))) {
          setKey(argv, k.split("."), defaults[k]);
          (aliases[k] || []).forEach(function(x) {
            setKey(argv, x.split("."), defaults[k]);
          });
        }
      });
      if (opts["--"]) {
        argv["--"] = notFlags.slice();
      } else {
        notFlags.forEach(function(k) {
          argv._.push(k);
        });
      }
      return argv;
    };
  }
});

// ../../node_modules/rc/index.js
var require_rc = __commonJS({
  "../../node_modules/rc/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var cc = require_utils();
    var join3 = __require("path").join;
    var deepExtend = require_deep_extend();
    var etc = "/etc";
    var win = process.platform === "win32";
    var home = win ? process.env.USERPROFILE : process.env.HOME;
    module.exports = function(name, defaults, argv, parse) {
      if ("string" !== typeof name)
        throw new Error("rc(name): name *must* be string");
      if (!argv)
        argv = require_minimist()(process.argv.slice(2));
      defaults = ("string" === typeof defaults ? cc.json(defaults) : defaults) || {};
      parse = parse || cc.parse;
      var env2 = cc.env(name + "_");
      var configs = [defaults];
      var configFiles = [];
      function addConfigFile(file) {
        if (configFiles.indexOf(file) >= 0) return;
        var fileConfig = cc.file(file);
        if (fileConfig) {
          configs.push(parse(fileConfig));
          configFiles.push(file);
        }
      }
      if (!win)
        [
          join3(etc, name, "config"),
          join3(etc, name + "rc")
        ].forEach(addConfigFile);
      if (home)
        [
          join3(home, ".config", name, "config"),
          join3(home, ".config", name),
          join3(home, "." + name, "config"),
          join3(home, "." + name + "rc")
        ].forEach(addConfigFile);
      addConfigFile(cc.find("." + name + "rc"));
      if (env2.config) addConfigFile(env2.config);
      if (argv.config) addConfigFile(argv.config);
      return deepExtend.apply(null, configs.concat([
        env2,
        argv,
        configFiles.length ? { configs: configFiles, config: configFiles[configFiles.length - 1] } : void 0
      ]));
    };
  }
});

// ../../node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/polyfills.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var constants = __require("constants");
    var origCwd = process.cwd;
    var cwd3 = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd3)
        cwd3 = origCwd.call(process);
      return cwd3;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd3 = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module.exports = patch;
    function patch(fs) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }
      if (!fs.lutimes) {
        patchLutimes(fs);
      }
      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);
      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);
      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);
      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);
      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);
      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);
      if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
          if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function() {
        };
      }
      if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
          if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb) cb(er);
            });
          }
          if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs.rename);
      }
      fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs.read);
      fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs.readSync);
      function patchLchmod(fs2) {
        fs2.lchmod = function(path, mode, callback) {
          fs2.open(
            path,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback) callback(err);
                return;
              }
              fs2.fchmod(fd, mode, function(err2) {
                fs2.close(fd, function(err22) {
                  if (callback) callback(err2 || err22);
                });
              });
            }
          );
        };
        fs2.lchmodSync = function(path, mode) {
          var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs2.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs2) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
          fs2.lutimes = function(path, at, mt, cb) {
            fs2.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb) cb(er);
                return;
              }
              fs2.futimes(fd, at, mt, function(er2) {
                fs2.close(fd, function(er22) {
                  if (cb) cb(er2 || er22);
                });
              });
            });
          };
          fs2.lutimesSync = function(path, at, mt) {
            var fd = fs2.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs2.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs2.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs2.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs2.futimes) {
          fs2.lutimes = function(_a, _b, _c, cb) {
            if (cb) process.nextTick(cb);
          };
          fs2.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
          return orig.call(fs, target, mode, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
          try {
            return orig.call(fs, target, mode);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig) return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0) stats.uid += 4294967296;
              if (stats.gid < 0) stats.gid += 4294967296;
            }
            if (cb) cb.apply(this, arguments);
          }
          return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig) return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/legacy-streams.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var Stream = __require("stream").Stream;
    module.exports = legacy;
    function legacy(fs) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
        Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/clone.js"(exports, module) {
    "use strict";
    init_esm_shims();
    module.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../../node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../node_modules/@pnpm/network.ca-file/node_modules/graceful-fs/graceful-fs.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var fs = __require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = __require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs, queue);
      fs.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs.close);
      fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs[gracefulQueue]);
          __require("assert").equal(fs[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs[gracefulQueue]);
    }
    module.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
      module.exports = patch(fs);
      fs.__patched = true;
    }
    function patch(fs2) {
      polyfills(fs2);
      fs2.gracefulify = patch;
      fs2.createReadStream = createReadStream;
      fs2.createWriteStream = createWriteStream;
      var fs$readFile = fs2.readFile;
      fs2.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path2, options2, cb2, startTime) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs2.writeFile;
      fs2.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path2, data2, options2, cb2, startTime) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs2.appendFile;
      if (fs$appendFile)
        fs2.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path2, data2, options2, cb2, startTime) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs2.copyFile;
      if (fs$copyFile)
        fs2.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs2.readdir;
      fs2.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, fs$readdirCallback(
            path2,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, options2, fs$readdirCallback(
            path2,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path, options, cb);
        function fs$readdirCallback(path2, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path2, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs2);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs2.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs2.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs2, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs2, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs2, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs2, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new fs2.ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new fs2.WriteStream(path, options);
      }
      var fs$open = fs2.open;
      fs2.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs2;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs[gracefulQueue].length; ++i) {
        if (fs[gracefulQueue][i].length > 2) {
          fs[gracefulQueue][i][3] = now;
          fs[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs[gracefulQueue].length === 0)
        return;
      var elem = fs[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../node_modules/@pnpm/network.ca-file/dist/ca-file.js
var require_ca_file = __commonJS({
  "../../node_modules/@pnpm/network.ca-file/dist/ca-file.js"(exports) {
    "use strict";
    init_esm_shims();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readCAFileSync = void 0;
    var graceful_fs_1 = __importDefault(require_graceful_fs());
    function readCAFileSync(filePath) {
      try {
        const contents = graceful_fs_1.default.readFileSync(filePath, "utf8");
        const delim = "-----END CERTIFICATE-----";
        const output = contents.split(delim).filter((ca) => Boolean(ca.trim())).map((ca) => `${ca.trimLeft()}${delim}`);
        return output;
      } catch (err) {
        if (err.code === "ENOENT")
          return void 0;
        throw err;
      }
    }
    exports.readCAFileSync = readCAFileSync;
  }
});

// ../../node_modules/@pnpm/network.ca-file/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/@pnpm/network.ca-file/dist/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ca_file(), exports);
  }
});

// ../../node_modules/proto-list/proto-list.js
var require_proto_list = __commonJS({
  "../../node_modules/proto-list/proto-list.js"(exports, module) {
    "use strict";
    init_esm_shims();
    module.exports = ProtoList;
    function setProto(obj, proto) {
      if (typeof Object.setPrototypeOf === "function")
        return Object.setPrototypeOf(obj, proto);
      else
        obj.__proto__ = proto;
    }
    function ProtoList() {
      this.list = [];
      var root = null;
      Object.defineProperty(this, "root", {
        get: function() {
          return root;
        },
        set: function(r) {
          root = r;
          if (this.list.length) {
            setProto(this.list[this.list.length - 1], r);
          }
        },
        enumerable: true,
        configurable: true
      });
    }
    ProtoList.prototype = {
      get length() {
        return this.list.length;
      },
      get keys() {
        var k = [];
        for (var i in this.list[0]) k.push(i);
        return k;
      },
      get snapshot() {
        var o = {};
        this.keys.forEach(function(k) {
          o[k] = this.get(k);
        }, this);
        return o;
      },
      get store() {
        return this.list[0];
      },
      push: function(obj) {
        if (typeof obj !== "object") obj = { valueOf: obj };
        if (this.list.length >= 1) {
          setProto(this.list[this.list.length - 1], obj);
        }
        setProto(obj, this.root);
        return this.list.push(obj);
      },
      pop: function() {
        if (this.list.length >= 2) {
          setProto(this.list[this.list.length - 2], this.root);
        }
        return this.list.pop();
      },
      unshift: function(obj) {
        setProto(obj, this.list[0] || this.root);
        return this.list.unshift(obj);
      },
      shift: function() {
        if (this.list.length === 1) {
          setProto(this.list[0], this.root);
        }
        return this.list.shift();
      },
      get: function(key) {
        return this.list[0][key];
      },
      set: function(key, val, save) {
        if (!this.length) this.push({});
        if (save && this.list[0].hasOwnProperty(key)) this.push({});
        return this.list[0][key] = val;
      },
      forEach: function(fn, thisp) {
        for (var key in this.list[0]) fn.call(thisp, key, this.list[0][key]);
      },
      slice: function() {
        return this.list.slice.apply(this.list, arguments);
      },
      splice: function() {
        var ret = this.list.splice.apply(this.list, arguments);
        for (var i = 0, l = this.list.length; i < l; i++) {
          setProto(this.list[i], this.list[i + 1] || this.root);
        }
        return ret;
      }
    };
  }
});

// ../../node_modules/config-chain/index.js
var require_config_chain = __commonJS({
  "../../node_modules/config-chain/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var ProtoList = require_proto_list();
    var path = __require("path");
    var fs = __require("fs");
    var ini = require_ini();
    var EE = __require("events").EventEmitter;
    var url = __require("url");
    var http = __require("http");
    var exports = module.exports = function() {
      var args = [].slice.call(arguments), conf = new ConfigChain();
      while (args.length) {
        var a = args.shift();
        if (a) conf.push("string" === typeof a ? json(a) : a);
      }
      return conf;
    };
    var find = exports.find = function() {
      var rel = path.join.apply(null, [].slice.call(arguments));
      function find2(start, rel2) {
        var file = path.join(start, rel2);
        try {
          fs.statSync(file);
          return file;
        } catch (err) {
          if (path.dirname(start) !== start)
            return find2(path.dirname(start), rel2);
        }
      }
      return find2(__dirname, rel);
    };
    var parse = exports.parse = function(content, file, type) {
      content = "" + content;
      if (!type) {
        try {
          return JSON.parse(content);
        } catch (er) {
          return ini.parse(content);
        }
      } else if (type === "json") {
        if (this.emit) {
          try {
            return JSON.parse(content);
          } catch (er) {
            this.emit("error", er);
          }
        } else {
          return JSON.parse(content);
        }
      } else {
        return ini.parse(content);
      }
    };
    var json = exports.json = function() {
      var args = [].slice.call(arguments).filter(function(arg) {
        return arg != null;
      });
      var file = path.join.apply(null, args);
      var content;
      try {
        content = fs.readFileSync(file, "utf-8");
      } catch (err) {
        return;
      }
      return parse(content, file, "json");
    };
    var env2 = exports.env = function(prefix, env3) {
      env3 = env3 || process.env;
      var obj = {};
      var l = prefix.length;
      for (var k in env3) {
        if (k.indexOf(prefix) === 0)
          obj[k.substring(l)] = env3[k];
      }
      return obj;
    };
    exports.ConfigChain = ConfigChain;
    function ConfigChain() {
      EE.apply(this);
      ProtoList.apply(this, arguments);
      this._awaiting = 0;
      this._saving = 0;
      this.sources = {};
    }
    var extras = {
      constructor: { value: ConfigChain }
    };
    Object.keys(EE.prototype).forEach(function(k) {
      extras[k] = Object.getOwnPropertyDescriptor(EE.prototype, k);
    });
    ConfigChain.prototype = Object.create(ProtoList.prototype, extras);
    ConfigChain.prototype.del = function(key, where) {
      if (where) {
        var target = this.sources[where];
        target = target && target.data;
        if (!target) {
          return this.emit("error", new Error("not found " + where));
        }
        delete target[key];
      } else {
        for (var i = 0, l = this.list.length; i < l; i++) {
          delete this.list[i][key];
        }
      }
      return this;
    };
    ConfigChain.prototype.set = function(key, value, where) {
      var target;
      if (where) {
        target = this.sources[where];
        target = target && target.data;
        if (!target) {
          return this.emit("error", new Error("not found " + where));
        }
      } else {
        target = this.list[0];
        if (!target) {
          return this.emit("error", new Error("cannot set, no confs!"));
        }
      }
      target[key] = value;
      return this;
    };
    ConfigChain.prototype.get = function(key, where) {
      if (where) {
        where = this.sources[where];
        if (where) where = where.data;
        if (where && Object.hasOwnProperty.call(where, key)) return where[key];
        return void 0;
      }
      return this.list[0][key];
    };
    ConfigChain.prototype.save = function(where, type, cb) {
      if (typeof type === "function") cb = type, type = null;
      var target = this.sources[where];
      if (!target || !(target.path || target.source) || !target.data) {
        return this.emit("error", new Error("bad save target: " + where));
      }
      if (target.source) {
        var pref = target.prefix || "";
        Object.keys(target.data).forEach(function(k) {
          target.source[pref + k] = target.data[k];
        });
        return this;
      }
      var type = type || target.type;
      var data = target.data;
      if (target.type === "json") {
        data = JSON.stringify(data);
      } else {
        data = ini.stringify(data);
      }
      this._saving++;
      fs.writeFile(target.path, data, "utf8", function(er) {
        this._saving--;
        if (er) {
          if (cb) return cb(er);
          else return this.emit("error", er);
        }
        if (this._saving === 0) {
          if (cb) cb();
          this.emit("save");
        }
      }.bind(this));
      return this;
    };
    ConfigChain.prototype.addFile = function(file, type, name) {
      name = name || file;
      var marker = { __source__: name };
      this.sources[name] = { path: file, type };
      this.push(marker);
      this._await();
      fs.readFile(file, "utf8", function(er, data) {
        if (er) this.emit("error", er);
        this.addString(data, file, type, marker);
      }.bind(this));
      return this;
    };
    ConfigChain.prototype.addEnv = function(prefix, env3, name) {
      name = name || "env";
      var data = exports.env(prefix, env3);
      this.sources[name] = { data, source: env3, prefix };
      return this.add(data, name);
    };
    ConfigChain.prototype.addUrl = function(req, type, name) {
      this._await();
      var href = url.format(req);
      name = name || href;
      var marker = { __source__: name };
      this.sources[name] = { href, type };
      this.push(marker);
      http.request(req, function(res) {
        var c = [];
        var ct = res.headers["content-type"];
        if (!type) {
          type = ct.indexOf("json") !== -1 ? "json" : ct.indexOf("ini") !== -1 ? "ini" : href.match(/\.json$/) ? "json" : href.match(/\.ini$/) ? "ini" : null;
          marker.type = type;
        }
        res.on("data", c.push.bind(c)).on("end", function() {
          this.addString(Buffer.concat(c), href, type, marker);
        }.bind(this)).on("error", this.emit.bind(this, "error"));
      }.bind(this)).on("error", this.emit.bind(this, "error")).end();
      return this;
    };
    ConfigChain.prototype.addString = function(data, file, type, marker) {
      data = this.parse(data, file, type);
      this.add(data, marker);
      return this;
    };
    ConfigChain.prototype.add = function(data, marker) {
      if (marker && typeof marker === "object") {
        var i = this.list.indexOf(marker);
        if (i === -1) {
          return this.emit("error", new Error("bad marker"));
        }
        this.splice(i, 1, data);
        marker = marker.__source__;
        this.sources[marker] = this.sources[marker] || {};
        this.sources[marker].data = data;
        this._resolve();
      } else {
        if (typeof marker === "string") {
          this.sources[marker] = this.sources[marker] || {};
          this.sources[marker].data = data;
        }
        this._await();
        this.push(data);
        process.nextTick(this._resolve.bind(this));
      }
      return this;
    };
    ConfigChain.prototype.parse = exports.parse;
    ConfigChain.prototype._await = function() {
      this._awaiting++;
    };
    ConfigChain.prototype._resolve = function() {
      this._awaiting--;
      if (this._awaiting === 0) this.emit("load", this);
    };
  }
});

// ../../node_modules/@pnpm/npm-conf/lib/envKeyToSetting.js
var require_envKeyToSetting = __commonJS({
  "../../node_modules/@pnpm/npm-conf/lib/envKeyToSetting.js"(exports, module) {
    "use strict";
    init_esm_shims();
    module.exports = function(x) {
      const colonIndex = x.indexOf(":");
      if (colonIndex === -1) {
        return normalize(x);
      }
      const firstPart = x.substr(0, colonIndex);
      const secondPart = x.substr(colonIndex + 1);
      return `${normalize(firstPart)}:${normalize(secondPart)}`;
    };
    function normalize(s) {
      s = s.toLowerCase();
      if (s === "_authtoken") return "_authToken";
      let r = s[0];
      for (let i = 1; i < s.length; i++) {
        r += s[i] === "_" ? "-" : s[i];
      }
      return r;
    }
  }
});

// ../../node_modules/@pnpm/config.env-replace/dist/env-replace.js
var require_env_replace = __commonJS({
  "../../node_modules/@pnpm/config.env-replace/dist/env-replace.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.envReplace = void 0;
    var ENV_EXPR = /(?<!\\)(\\*)\$\{([^${}]+)\}/g;
    function envReplace(settingValue, env2) {
      return settingValue.replace(ENV_EXPR, replaceEnvMatch.bind(null, env2));
    }
    exports.envReplace = envReplace;
    function replaceEnvMatch(env2, orig, escape, name) {
      if (escape.length % 2) {
        return orig.slice((escape.length + 1) / 2);
      }
      const envValue = getEnvValue(env2, name);
      if (envValue === void 0) {
        throw new Error(`Failed to replace env in config: ${orig}`);
      }
      return `${escape.slice(escape.length / 2)}${envValue}`;
    }
    var ENV_VALUE = /([^:-]+)(:?)-(.+)/;
    function getEnvValue(env2, name) {
      const matched = name.match(ENV_VALUE);
      if (!matched)
        return env2[name];
      const [, variableName, colon, fallback] = matched;
      if (Object.prototype.hasOwnProperty.call(env2, variableName)) {
        return !env2[variableName] && colon ? fallback : env2[variableName];
      }
      return fallback;
    }
  }
});

// ../../node_modules/@pnpm/config.env-replace/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/@pnpm/config.env-replace/dist/index.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.envReplace = void 0;
    var env_replace_1 = require_env_replace();
    Object.defineProperty(exports, "envReplace", { enumerable: true, get: function() {
      return env_replace_1.envReplace;
    } });
  }
});

// ../../node_modules/@pnpm/npm-conf/lib/util.js
var require_util = __commonJS({
  "../../node_modules/@pnpm/npm-conf/lib/util.js"(exports) {
    "use strict";
    init_esm_shims();
    var fs = __require("fs");
    var path = __require("path");
    var { envReplace } = require_dist2();
    var parseKey = (key) => {
      if (typeof key !== "string") {
        return key;
      }
      return envReplace(key, process.env);
    };
    var parseField = (types, field, key) => {
      if (typeof field !== "string") {
        return field;
      }
      const typeList = [].concat(types[key]);
      const isPath = typeList.indexOf(path) !== -1;
      const isBool = typeList.indexOf(Boolean) !== -1;
      const isString = typeList.indexOf(String) !== -1;
      const isNumber = typeList.indexOf(Number) !== -1;
      field = `${field}`.trim();
      if (/^".*"$/.test(field)) {
        try {
          field = JSON.parse(field);
        } catch (error) {
          throw new Error(`Failed parsing JSON config key ${key}: ${field}`);
        }
      }
      if (isBool && !isString && field === "") {
        return true;
      }
      switch (field) {
        // eslint-disable-line default-case
        case "true": {
          return true;
        }
        case "false": {
          return false;
        }
        case "null": {
          return null;
        }
        case "undefined": {
          return void 0;
        }
      }
      field = envReplace(field, process.env);
      if (isPath) {
        const regex = process.platform === "win32" ? /^~(\/|\\)/ : /^~\//;
        if (regex.test(field) && process.env.HOME) {
          field = path.resolve(process.env.HOME, field.substr(2));
        }
        field = path.resolve(field);
      }
      if (isNumber && !isNaN(field)) {
        field = Number(field);
      }
      return field;
    };
    var findPrefix = (name) => {
      name = path.resolve(name);
      let walkedUp = false;
      while (path.basename(name) === "node_modules") {
        name = path.dirname(name);
        walkedUp = true;
      }
      if (walkedUp) {
        return name;
      }
      const find = (name2, original) => {
        const regex = /^[a-zA-Z]:(\\|\/)?$/;
        if (name2 === "/" || process.platform === "win32" && regex.test(name2)) {
          return original;
        }
        try {
          const files = fs.readdirSync(name2);
          if (files.includes("node_modules") || files.includes("package.json") || files.includes("package.json5") || files.includes("package.yaml") || files.includes("pnpm-workspace.yaml")) {
            return name2;
          }
          const dirname = path.dirname(name2);
          if (dirname === name2) {
            return original;
          }
          return find(dirname, original);
        } catch (error) {
          if (name2 === original) {
            if (error.code === "ENOENT") {
              return original;
            }
            throw error;
          }
          return original;
        }
      };
      return find(name, name);
    };
    exports.envReplace = envReplace;
    exports.findPrefix = findPrefix;
    exports.parseField = parseField;
    exports.parseKey = parseKey;
  }
});

// ../../node_modules/@pnpm/npm-conf/lib/types.js
var require_types = __commonJS({
  "../../node_modules/@pnpm/npm-conf/lib/types.js"(exports) {
    "use strict";
    init_esm_shims();
    var path = __require("path");
    var Stream = __require("stream").Stream;
    var url = __require("url");
    var Umask = () => {
    };
    var getLocalAddresses = () => [];
    var semver2 = () => {
    };
    exports.types = {
      access: [null, "restricted", "public"],
      "allow-same-version": Boolean,
      "always-auth": Boolean,
      also: [null, "dev", "development"],
      audit: Boolean,
      "auth-type": ["legacy", "sso", "saml", "oauth"],
      "bin-links": Boolean,
      browser: [null, String],
      ca: [null, String, Array],
      cafile: path,
      cache: path,
      "cache-lock-stale": Number,
      "cache-lock-retries": Number,
      "cache-lock-wait": Number,
      "cache-max": Number,
      "cache-min": Number,
      cert: [null, String],
      cidr: [null, String, Array],
      color: ["always", Boolean],
      depth: Number,
      description: Boolean,
      dev: Boolean,
      "dry-run": Boolean,
      editor: String,
      "engine-strict": Boolean,
      force: Boolean,
      "fetch-retries": Number,
      "fetch-retry-factor": Number,
      "fetch-retry-mintimeout": Number,
      "fetch-retry-maxtimeout": Number,
      git: String,
      "git-tag-version": Boolean,
      "commit-hooks": Boolean,
      global: Boolean,
      globalconfig: path,
      "global-style": Boolean,
      group: [Number, String],
      "https-proxy": [null, url],
      "user-agent": String,
      "ham-it-up": Boolean,
      "heading": String,
      "if-present": Boolean,
      "ignore-prepublish": Boolean,
      "ignore-scripts": Boolean,
      "init-module": path,
      "init-author-name": String,
      "init-author-email": String,
      "init-author-url": ["", url],
      "init-license": String,
      "init-version": semver2,
      json: Boolean,
      key: [null, String],
      "legacy-bundling": Boolean,
      link: Boolean,
      // local-address must be listed as an IP for a local network interface
      // must be IPv4 due to node bug
      "local-address": getLocalAddresses(),
      loglevel: ["silent", "error", "warn", "notice", "http", "timing", "info", "verbose", "silly"],
      logstream: Stream,
      "logs-max": Number,
      long: Boolean,
      maxsockets: Number,
      message: String,
      "metrics-registry": [null, String],
      "node-options": [null, String],
      "node-version": [null, semver2],
      "no-proxy": [null, String, Array],
      offline: Boolean,
      "onload-script": [null, String],
      only: [null, "dev", "development", "prod", "production"],
      optional: Boolean,
      "package-lock": Boolean,
      otp: [null, String],
      "package-lock-only": Boolean,
      parseable: Boolean,
      "prefer-offline": Boolean,
      "prefer-online": Boolean,
      prefix: path,
      production: Boolean,
      progress: Boolean,
      proxy: [null, false, url],
      provenance: Boolean,
      // allow proxy to be disabled explicitly
      "read-only": Boolean,
      "rebuild-bundle": Boolean,
      registry: [null, url],
      rollback: Boolean,
      save: Boolean,
      "save-bundle": Boolean,
      "save-dev": Boolean,
      "save-exact": Boolean,
      "save-optional": Boolean,
      "save-prefix": String,
      "save-prod": Boolean,
      scope: String,
      "script-shell": [null, String],
      "scripts-prepend-node-path": [false, true, "auto", "warn-only"],
      searchopts: String,
      searchexclude: [null, String],
      searchlimit: Number,
      searchstaleness: Number,
      "send-metrics": Boolean,
      shell: String,
      shrinkwrap: Boolean,
      "sign-git-tag": Boolean,
      "sso-poll-frequency": Number,
      "sso-type": [null, "oauth", "saml"],
      "strict-ssl": Boolean,
      tag: String,
      timing: Boolean,
      tmp: path,
      unicode: Boolean,
      "unsafe-perm": Boolean,
      usage: Boolean,
      user: [Number, String],
      userconfig: path,
      umask: Umask,
      version: Boolean,
      "tag-version-prefix": String,
      versions: Boolean,
      viewer: String,
      _exit: Boolean
    };
  }
});

// ../../node_modules/@pnpm/npm-conf/lib/conf.js
var require_conf = __commonJS({
  "../../node_modules/@pnpm/npm-conf/lib/conf.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var { readCAFileSync } = require_dist();
    var fs = __require("fs");
    var path = __require("path");
    var { ConfigChain } = require_config_chain();
    var envKeyToSetting = require_envKeyToSetting();
    var util = require_util();
    var Conf = class extends ConfigChain {
      // https://github.com/npm/cli/blob/latest/lib/config/core.js#L203-L217
      constructor(base, types) {
        super(base);
        this.root = base;
        this._parseField = util.parseField.bind(null, types || require_types());
      }
      // https://github.com/npm/cli/blob/latest/lib/config/core.js#L326-L338
      add(data, marker) {
        try {
          for (const [key, value] of Object.entries(data)) {
            const substKey = util.parseKey(key);
            if (substKey !== key) {
              delete data[key];
            }
            data[substKey] = this._parseField(value, substKey);
          }
        } catch (error) {
          throw error;
        }
        return super.add(data, marker);
      }
      // https://github.com/npm/cli/blob/latest/lib/config/core.js#L306-L319
      addFile(file, name) {
        name = name || file;
        const marker = { __source__: name };
        this.sources[name] = { path: file, type: "ini" };
        this.push(marker);
        this._await();
        try {
          const contents = fs.readFileSync(file, "utf8");
          this.addString(contents, file, "ini", marker);
        } catch (error) {
          if (error.code === "ENOENT") {
            this.add({}, marker);
          } else if (error.code !== "EISDIR") {
            return `Issue while reading "${file}". ${error.message}`;
          }
        }
      }
      // https://github.com/npm/cli/blob/latest/lib/config/core.js#L341-L357
      addEnv(env2) {
        env2 = env2 || process.env;
        const conf = {};
        Object.keys(env2).filter((x) => /^npm_config_/i.test(x)).forEach((x) => {
          if (!env2[x]) {
            return;
          }
          const key = envKeyToSetting(x.substr(11));
          const rawVal = env2[x];
          conf[key] = deserializeEnvVal(key, rawVal);
        });
        return super.addEnv("", conf, "env");
      }
      // https://github.com/npm/cli/blob/latest/lib/config/load-prefix.js
      loadPrefix() {
        const cli = this.list[0];
        Object.defineProperty(this, "prefix", {
          enumerable: true,
          set: (prefix) => {
            const g = this.get("global");
            this[g ? "globalPrefix" : "localPrefix"] = prefix;
          },
          get: () => {
            const g = this.get("global");
            return g ? this.globalPrefix : this.localPrefix;
          }
        });
        Object.defineProperty(this, "globalPrefix", {
          enumerable: true,
          set: (prefix) => {
            this.set("prefix", prefix);
          },
          get: () => {
            return path.resolve(this.get("prefix"));
          }
        });
        let p;
        Object.defineProperty(this, "localPrefix", {
          enumerable: true,
          set: (prefix) => {
            p = prefix;
          },
          get: () => {
            return p;
          }
        });
        if (Object.prototype.hasOwnProperty.call(cli, "prefix")) {
          p = path.resolve(cli.prefix);
        } else {
          try {
            const prefix = util.findPrefix(process.cwd());
            p = prefix;
          } catch (error) {
            throw error;
          }
        }
        return p;
      }
      // https://github.com/npm/cli/blob/latest/lib/config/load-cafile.js
      loadCAFile(file) {
        if (!file) {
          return;
        }
        const ca = readCAFileSync(file);
        if (ca) {
          this.set("ca", ca);
        }
      }
      // https://github.com/npm/cli/blob/latest/lib/config/set-user.js
      loadUser() {
        const defConf = this.root;
        if (this.get("global")) {
          return;
        }
        if (process.env.SUDO_UID) {
          defConf.user = Number(process.env.SUDO_UID);
          return;
        }
        const prefix = path.resolve(this.get("prefix"));
        try {
          const stats = fs.statSync(prefix);
          defConf.user = stats.uid;
        } catch (error) {
          if (error.code === "ENOENT") {
            return;
          }
          throw error;
        }
      }
    };
    function deserializeEnvVal(envKey, envValue) {
      function deserializeList(envValue2) {
        const npmConfigSep = "\n\n";
        if (envValue2.indexOf(npmConfigSep)) {
          return envValue2.split(npmConfigSep);
        }
        return envValue2.split(",");
      }
      switch (envKey) {
        case "hoist-pattern":
        case "public-hoist-pattern":
          return deserializeList(envValue);
      }
      return envValue;
    }
    module.exports = Conf;
  }
});

// ../../node_modules/@pnpm/npm-conf/lib/defaults.js
var require_defaults = __commonJS({
  "../../node_modules/@pnpm/npm-conf/lib/defaults.js"(exports) {
    "use strict";
    init_esm_shims();
    var os = __require("os");
    var path = __require("path");
    var temp = os.tmpdir();
    var uidOrPid = process.getuid ? process.getuid() : process.pid;
    var hasUnicode = () => true;
    var isWindows = process.platform === "win32";
    var osenv = {
      editor: () => process.env.EDITOR || process.env.VISUAL || (isWindows ? "notepad.exe" : "vi"),
      shell: () => isWindows ? process.env.COMSPEC || "cmd.exe" : process.env.SHELL || "/bin/bash"
    };
    var umask = {
      fromString: () => process.umask()
    };
    var home = os.homedir();
    if (home) {
      process.env.HOME = home;
    } else {
      home = path.resolve(temp, "npm-" + uidOrPid);
    }
    var cacheExtra = process.platform === "win32" ? "npm-cache" : ".npm";
    var cacheRoot = process.platform === "win32" && process.env.APPDATA || home;
    var cache = path.resolve(cacheRoot, cacheExtra);
    var defaults;
    var globalPrefix;
    Object.defineProperty(exports, "defaults", {
      get: function() {
        if (defaults) return defaults;
        if (process.env.PREFIX) {
          globalPrefix = process.env.PREFIX;
        } else if (process.platform === "win32") {
          globalPrefix = path.dirname(process.execPath);
        } else {
          globalPrefix = path.dirname(path.dirname(process.execPath));
          if (process.env.DESTDIR) {
            globalPrefix = path.join(process.env.DESTDIR, globalPrefix);
          }
        }
        defaults = {
          access: null,
          "allow-same-version": false,
          "always-auth": false,
          also: null,
          audit: true,
          "auth-type": "legacy",
          "bin-links": true,
          browser: null,
          ca: null,
          cafile: null,
          cache,
          "cache-lock-stale": 6e4,
          "cache-lock-retries": 10,
          "cache-lock-wait": 1e4,
          "cache-max": Infinity,
          "cache-min": 10,
          cert: null,
          cidr: null,
          color: process.env.NO_COLOR == null,
          depth: Infinity,
          description: true,
          dev: false,
          "dry-run": false,
          editor: osenv.editor(),
          "engine-strict": false,
          force: false,
          "fetch-retries": 2,
          "fetch-retry-factor": 10,
          "fetch-retry-mintimeout": 1e4,
          "fetch-retry-maxtimeout": 6e4,
          git: "git",
          "git-tag-version": true,
          "commit-hooks": true,
          global: false,
          globalconfig: path.resolve(globalPrefix, "etc", "npmrc"),
          "global-style": false,
          group: process.platform === "win32" ? 0 : process.env.SUDO_GID || process.getgid && process.getgid(),
          "ham-it-up": false,
          heading: "npm",
          "if-present": false,
          "ignore-prepublish": false,
          "ignore-scripts": false,
          "init-module": path.resolve(home, ".npm-init.js"),
          "init-author-name": "",
          "init-author-email": "",
          "init-author-url": "",
          "init-version": "1.0.0",
          "init-license": "ISC",
          json: false,
          key: null,
          "legacy-bundling": false,
          link: false,
          "local-address": void 0,
          loglevel: "notice",
          logstream: process.stderr,
          "logs-max": 10,
          long: false,
          maxsockets: 50,
          message: "%s",
          "metrics-registry": null,
          "node-options": null,
          // We remove node-version to fix the issue described here: https://github.com/pnpm/pnpm/issues/4203#issuecomment-1133872769
          "offline": false,
          "onload-script": false,
          only: null,
          optional: true,
          otp: null,
          "package-lock": true,
          "package-lock-only": false,
          parseable: false,
          "prefer-offline": false,
          "prefer-online": false,
          prefix: globalPrefix,
          production: true,
          "progress": !process.env.TRAVIS && !process.env.CI,
          provenance: false,
          proxy: null,
          "https-proxy": null,
          "no-proxy": null,
          "user-agent": "npm/{npm-version} node/{node-version} {platform} {arch}",
          "read-only": false,
          "rebuild-bundle": true,
          registry: "https://registry.npmjs.org/",
          rollback: true,
          save: true,
          "save-bundle": false,
          "save-dev": false,
          "save-exact": false,
          "save-optional": false,
          "save-prefix": "^",
          "save-prod": false,
          scope: "",
          "script-shell": null,
          "scripts-prepend-node-path": "warn-only",
          searchopts: "",
          searchexclude: null,
          searchlimit: 20,
          searchstaleness: 15 * 60,
          "send-metrics": false,
          shell: osenv.shell(),
          shrinkwrap: true,
          "sign-git-tag": false,
          "sso-poll-frequency": 500,
          "sso-type": "oauth",
          "strict-ssl": true,
          tag: "latest",
          "tag-version-prefix": "v",
          timing: false,
          tmp: temp,
          unicode: hasUnicode(),
          "unsafe-perm": process.platform === "win32" || process.platform === "cygwin" || !(process.getuid && process.setuid && process.getgid && process.setgid) || process.getuid() !== 0,
          usage: false,
          user: process.platform === "win32" ? 0 : "nobody",
          userconfig: path.resolve(home, ".npmrc"),
          umask: process.umask ? process.umask() : umask.fromString("022"),
          version: false,
          versions: false,
          viewer: process.platform === "win32" ? "browser" : "man",
          _exit: true
        };
        return defaults;
      }
    });
  }
});

// ../../node_modules/@pnpm/npm-conf/index.js
var require_npm_conf = __commonJS({
  "../../node_modules/@pnpm/npm-conf/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var path = __require("path");
    var Conf = require_conf();
    var _defaults = require_defaults();
    module.exports = (opts, types, defaults) => {
      const conf = new Conf(Object.assign({}, _defaults.defaults, defaults), types);
      conf.add(Object.assign({}, opts), "cli");
      const warnings = [];
      let failedToLoadBuiltInConfig = false;
      if (__require.resolve.paths) {
        const paths = __require.resolve.paths("npm");
        let npmPath;
        try {
          npmPath = __require.resolve("npm", { paths: paths.slice(-1) });
        } catch (error) {
          failedToLoadBuiltInConfig = true;
        }
        if (npmPath) {
          warnings.push(conf.addFile(path.resolve(path.dirname(npmPath), "..", "npmrc"), "builtin"));
        }
      }
      conf.addEnv();
      conf.loadPrefix();
      const projectConf = path.resolve(conf.localPrefix, ".npmrc");
      const userConf = conf.get("userconfig");
      if (!conf.get("global") && projectConf !== userConf) {
        warnings.push(conf.addFile(projectConf, "project"));
      } else {
        conf.add({}, "project");
      }
      if (conf.get("workspace-prefix") && conf.get("workspace-prefix") !== projectConf) {
        const workspaceConf = path.resolve(conf.get("workspace-prefix"), ".npmrc");
        warnings.push(conf.addFile(workspaceConf, "workspace"));
      }
      warnings.push(conf.addFile(conf.get("userconfig"), "user"));
      if (conf.get("prefix")) {
        const etc = path.resolve(conf.get("prefix"), "etc");
        conf.root.globalconfig = path.resolve(etc, "npmrc");
        conf.root.globalignorefile = path.resolve(etc, "npmignore");
      }
      warnings.push(conf.addFile(conf.get("globalconfig"), "global"));
      conf.loadUser();
      const caFile = conf.get("cafile");
      if (caFile) {
        conf.loadCAFile(caFile);
      }
      return {
        config: conf,
        warnings: warnings.filter(Boolean),
        failedToLoadBuiltInConfig
      };
    };
    Object.defineProperty(module.exports, "defaults", {
      get() {
        return _defaults.defaults;
      },
      enumerable: true
    });
  }
});

// ../../node_modules/registry-auth-token/index.js
var require_registry_auth_token = __commonJS({
  "../../node_modules/registry-auth-token/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var url = __require("url");
    var npmConf = require_npm_conf();
    var tokenKey = ":_authToken";
    var legacyTokenKey = ":_auth";
    var userKey = ":username";
    var passwordKey = ":_password";
    module.exports = function getRegistryAuthToken() {
      let checkUrl;
      let options;
      if (arguments.length >= 2) {
        checkUrl = arguments[0];
        options = Object.assign({}, arguments[1]);
      } else if (typeof arguments[0] === "string") {
        checkUrl = arguments[0];
      } else {
        options = Object.assign({}, arguments[0]);
      }
      options = options || {};
      const providedNpmrc = options.npmrc;
      options.npmrc = (options.npmrc ? {
        config: {
          get: (key) => providedNpmrc[key]
        }
      } : npmConf()).config;
      checkUrl = checkUrl || options.npmrc.get("registry") || npmConf.defaults.registry;
      return getRegistryAuthInfo(checkUrl, options) || getLegacyAuthInfo(options.npmrc);
    };
    function getRegistryAuthInfo(checkUrl, options) {
      const parsed = url.parse(checkUrl, false, true);
      let pathname;
      while (pathname !== "/" && parsed.pathname !== pathname) {
        pathname = parsed.pathname || "/";
        const regUrl = "//" + parsed.host + pathname.replace(/\/$/, "");
        const authInfo = getAuthInfoForUrl(regUrl, options.npmrc);
        if (authInfo) {
          return authInfo;
        }
        if (!options.recursive) {
          return /\/$/.test(checkUrl) ? void 0 : getRegistryAuthInfo(url.resolve(checkUrl, "."), options);
        }
        parsed.pathname = url.resolve(normalizePath(pathname), "..") || "/";
      }
      return void 0;
    }
    function getLegacyAuthInfo(npmrc) {
      if (!npmrc.get("_auth")) {
        return void 0;
      }
      const token = replaceEnvironmentVariable(npmrc.get("_auth"));
      return { token, type: "Basic" };
    }
    function normalizePath(path) {
      return path[path.length - 1] === "/" ? path : path + "/";
    }
    function getAuthInfoForUrl(regUrl, npmrc) {
      const bearerAuth = getBearerToken(npmrc.get(regUrl + tokenKey) || npmrc.get(regUrl + "/" + tokenKey));
      if (bearerAuth) {
        return bearerAuth;
      }
      const username = npmrc.get(regUrl + userKey) || npmrc.get(regUrl + "/" + userKey);
      const password = npmrc.get(regUrl + passwordKey) || npmrc.get(regUrl + "/" + passwordKey);
      const basicAuth = getTokenForUsernameAndPassword(username, password);
      if (basicAuth) {
        return basicAuth;
      }
      const basicAuthWithToken = getLegacyAuthToken(npmrc.get(regUrl + legacyTokenKey) || npmrc.get(regUrl + "/" + legacyTokenKey));
      if (basicAuthWithToken) {
        return basicAuthWithToken;
      }
      return void 0;
    }
    function replaceEnvironmentVariable(token) {
      return token.replace(/^\$\{?([^}]*)\}?$/, function(fullMatch, envVar) {
        return process.env[envVar];
      });
    }
    function getBearerToken(tok) {
      if (!tok) {
        return void 0;
      }
      const token = replaceEnvironmentVariable(tok);
      return { token, type: "Bearer" };
    }
    function getTokenForUsernameAndPassword(username, password) {
      if (!username || !password) {
        return void 0;
      }
      const pass = Buffer.from(replaceEnvironmentVariable(password), "base64").toString("utf8");
      const token = Buffer.from(username + ":" + pass, "utf8").toString("base64");
      return {
        token,
        type: "Basic",
        password: pass,
        username
      };
    }
    function getLegacyAuthToken(tok) {
      if (!tok) {
        return void 0;
      }
      const token = replaceEnvironmentVariable(tok);
      return { token, type: "Basic" };
    }
  }
});

// ../../node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "../../node_modules/ansi-regex/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    module.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// ../../node_modules/columnify/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "../../node_modules/columnify/node_modules/strip-ansi/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var ansiRegex = require_ansi_regex();
    module.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// ../../node_modules/clone/clone.js
var require_clone2 = __commonJS({
  "../../node_modules/clone/clone.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var clone = function() {
      "use strict";
      function clone2(parent, circular, depth, prototype) {
        var filter;
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          filter = circular.filter;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 == 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent2);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          for (var i in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c = function() {
        };
        c.prototype = parent;
        return new c();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      ;
      clone2.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      ;
      clone2.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      ;
      clone2.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      ;
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global) flags += "g";
        if (re.ignoreCase) flags += "i";
        if (re.multiline) flags += "m";
        return flags;
      }
      ;
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module === "object" && module.exports) {
      module.exports = clone;
    }
  }
});

// ../../node_modules/defaults/index.js
var require_defaults2 = __commonJS({
  "../../node_modules/defaults/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var clone = require_clone2();
    module.exports = function(options, defaults) {
      options = options || {};
      Object.keys(defaults).forEach(function(key) {
        if (typeof options[key] === "undefined") {
          options[key] = clone(defaults[key]);
        }
      });
      return options;
    };
  }
});

// ../../node_modules/wcwidth/combining.js
var require_combining = __commonJS({
  "../../node_modules/wcwidth/combining.js"(exports, module) {
    "use strict";
    init_esm_shims();
    module.exports = [
      [768, 879],
      [1155, 1158],
      [1160, 1161],
      [1425, 1469],
      [1471, 1471],
      [1473, 1474],
      [1476, 1477],
      [1479, 1479],
      [1536, 1539],
      [1552, 1557],
      [1611, 1630],
      [1648, 1648],
      [1750, 1764],
      [1767, 1768],
      [1770, 1773],
      [1807, 1807],
      [1809, 1809],
      [1840, 1866],
      [1958, 1968],
      [2027, 2035],
      [2305, 2306],
      [2364, 2364],
      [2369, 2376],
      [2381, 2381],
      [2385, 2388],
      [2402, 2403],
      [2433, 2433],
      [2492, 2492],
      [2497, 2500],
      [2509, 2509],
      [2530, 2531],
      [2561, 2562],
      [2620, 2620],
      [2625, 2626],
      [2631, 2632],
      [2635, 2637],
      [2672, 2673],
      [2689, 2690],
      [2748, 2748],
      [2753, 2757],
      [2759, 2760],
      [2765, 2765],
      [2786, 2787],
      [2817, 2817],
      [2876, 2876],
      [2879, 2879],
      [2881, 2883],
      [2893, 2893],
      [2902, 2902],
      [2946, 2946],
      [3008, 3008],
      [3021, 3021],
      [3134, 3136],
      [3142, 3144],
      [3146, 3149],
      [3157, 3158],
      [3260, 3260],
      [3263, 3263],
      [3270, 3270],
      [3276, 3277],
      [3298, 3299],
      [3393, 3395],
      [3405, 3405],
      [3530, 3530],
      [3538, 3540],
      [3542, 3542],
      [3633, 3633],
      [3636, 3642],
      [3655, 3662],
      [3761, 3761],
      [3764, 3769],
      [3771, 3772],
      [3784, 3789],
      [3864, 3865],
      [3893, 3893],
      [3895, 3895],
      [3897, 3897],
      [3953, 3966],
      [3968, 3972],
      [3974, 3975],
      [3984, 3991],
      [3993, 4028],
      [4038, 4038],
      [4141, 4144],
      [4146, 4146],
      [4150, 4151],
      [4153, 4153],
      [4184, 4185],
      [4448, 4607],
      [4959, 4959],
      [5906, 5908],
      [5938, 5940],
      [5970, 5971],
      [6002, 6003],
      [6068, 6069],
      [6071, 6077],
      [6086, 6086],
      [6089, 6099],
      [6109, 6109],
      [6155, 6157],
      [6313, 6313],
      [6432, 6434],
      [6439, 6440],
      [6450, 6450],
      [6457, 6459],
      [6679, 6680],
      [6912, 6915],
      [6964, 6964],
      [6966, 6970],
      [6972, 6972],
      [6978, 6978],
      [7019, 7027],
      [7616, 7626],
      [7678, 7679],
      [8203, 8207],
      [8234, 8238],
      [8288, 8291],
      [8298, 8303],
      [8400, 8431],
      [12330, 12335],
      [12441, 12442],
      [43014, 43014],
      [43019, 43019],
      [43045, 43046],
      [64286, 64286],
      [65024, 65039],
      [65056, 65059],
      [65279, 65279],
      [65529, 65531],
      [68097, 68099],
      [68101, 68102],
      [68108, 68111],
      [68152, 68154],
      [68159, 68159],
      [119143, 119145],
      [119155, 119170],
      [119173, 119179],
      [119210, 119213],
      [119362, 119364],
      [917505, 917505],
      [917536, 917631],
      [917760, 917999]
    ];
  }
});

// ../../node_modules/wcwidth/index.js
var require_wcwidth = __commonJS({
  "../../node_modules/wcwidth/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var defaults = require_defaults2();
    var combining = require_combining();
    var DEFAULTS = {
      nul: 0,
      control: 0
    };
    module.exports = function wcwidth2(str) {
      return wcswidth(str, DEFAULTS);
    };
    module.exports.config = function(opts) {
      opts = defaults(opts || {}, DEFAULTS);
      return function wcwidth2(str) {
        return wcswidth(str, opts);
      };
    };
    function wcswidth(str, opts) {
      if (typeof str !== "string") return wcwidth(str, opts);
      var s = 0;
      for (var i = 0; i < str.length; i++) {
        var n = wcwidth(str.charCodeAt(i), opts);
        if (n < 0) return -1;
        s += n;
      }
      return s;
    }
    function wcwidth(ucs, opts) {
      if (ucs === 0) return opts.nul;
      if (ucs < 32 || ucs >= 127 && ucs < 160) return opts.control;
      if (bisearch(ucs)) return 0;
      return 1 + (ucs >= 4352 && (ucs <= 4447 || // Hangul Jamo init. consonants
      ucs == 9001 || ucs == 9002 || ucs >= 11904 && ucs <= 42191 && ucs != 12351 || // CJK ... Yi
      ucs >= 44032 && ucs <= 55203 || // Hangul Syllables
      ucs >= 63744 && ucs <= 64255 || // CJK Compatibility Ideographs
      ucs >= 65040 && ucs <= 65049 || // Vertical forms
      ucs >= 65072 && ucs <= 65135 || // CJK Compatibility Forms
      ucs >= 65280 && ucs <= 65376 || // Fullwidth Forms
      ucs >= 65504 && ucs <= 65510 || ucs >= 131072 && ucs <= 196605 || ucs >= 196608 && ucs <= 262141));
    }
    function bisearch(ucs) {
      var min = 0;
      var max = combining.length - 1;
      var mid;
      if (ucs < combining[0][0] || ucs > combining[max][1]) return false;
      while (max >= min) {
        mid = Math.floor((min + max) / 2);
        if (ucs > combining[mid][1]) min = mid + 1;
        else if (ucs < combining[mid][0]) max = mid - 1;
        else return true;
      }
      return false;
    }
  }
});

// ../../node_modules/columnify/width.js
var require_width = __commonJS({
  "../../node_modules/columnify/width.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var stripAnsi = require_strip_ansi();
    var wcwidth = require_wcwidth();
    module.exports = function(str) {
      return wcwidth(stripAnsi(str));
    };
  }
});

// ../../node_modules/columnify/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/columnify/utils.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var wcwidth = require_width();
    function repeatString(str, len) {
      return Array.apply(null, { length: len + 1 }).join(str).slice(0, len);
    }
    function padRight(str, max, chr) {
      str = str != null ? str : "";
      str = String(str);
      var length = max - wcwidth(str);
      if (length <= 0) return str;
      return str + repeatString(chr || " ", length);
    }
    function padCenter(str, max, chr) {
      str = str != null ? str : "";
      str = String(str);
      var length = max - wcwidth(str);
      if (length <= 0) return str;
      var lengthLeft = Math.floor(length / 2);
      var lengthRight = length - lengthLeft;
      return repeatString(chr || " ", lengthLeft) + str + repeatString(chr || " ", lengthRight);
    }
    function padLeft(str, max, chr) {
      str = str != null ? str : "";
      str = String(str);
      var length = max - wcwidth(str);
      if (length <= 0) return str;
      return repeatString(chr || " ", length) + str;
    }
    function splitIntoLines(str, max) {
      function _splitIntoLines(str2, max2) {
        return str2.trim().split(" ").reduce(function(lines, word) {
          var line = lines[lines.length - 1];
          if (line && wcwidth(line.join(" ")) + wcwidth(word) < max2) {
            lines[lines.length - 1].push(word);
          } else lines.push([word]);
          return lines;
        }, []).map(function(l) {
          return l.join(" ");
        });
      }
      return str.split("\n").map(function(str2) {
        return _splitIntoLines(str2, max);
      }).reduce(function(lines, line) {
        return lines.concat(line);
      }, []);
    }
    function splitLongWords(str, max, truncationChar) {
      str = str.trim();
      var result = [];
      var words = str.split(" ");
      var remainder = "";
      var truncationWidth = wcwidth(truncationChar);
      while (remainder || words.length) {
        if (remainder) {
          var word = remainder;
          remainder = "";
        } else {
          var word = words.shift();
        }
        if (wcwidth(word) > max) {
          var i = 0;
          var wwidth = 0;
          var limit = max - truncationWidth;
          while (i < word.length) {
            var w = wcwidth(word.charAt(i));
            if (w + wwidth > limit) {
              break;
            }
            wwidth += w;
            ++i;
          }
          remainder = word.slice(i);
          word = word.slice(0, i);
          word += truncationChar;
        }
        result.push(word);
      }
      return result.join(" ");
    }
    function truncateString(str, max) {
      str = str != null ? str : "";
      str = String(str);
      if (max == Infinity) return str;
      var i = 0;
      var wwidth = 0;
      while (i < str.length) {
        var w = wcwidth(str.charAt(i));
        if (w + wwidth > max)
          break;
        wwidth += w;
        ++i;
      }
      return str.slice(0, i);
    }
    module.exports.padRight = padRight;
    module.exports.padCenter = padCenter;
    module.exports.padLeft = padLeft;
    module.exports.splitIntoLines = splitIntoLines;
    module.exports.splitLongWords = splitLongWords;
    module.exports.truncateString = truncateString;
  }
});

// ../../node_modules/columnify/columnify.js
var require_columnify = __commonJS({
  "../../node_modules/columnify/columnify.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var wcwidth = require_width();
    var _require = require_utils2();
    var padRight = _require.padRight;
    var padCenter = _require.padCenter;
    var padLeft = _require.padLeft;
    var splitIntoLines = _require.splitIntoLines;
    var splitLongWords = _require.splitLongWords;
    var truncateString = _require.truncateString;
    var DEFAULT_HEADING_TRANSFORM = function DEFAULT_HEADING_TRANSFORM2(key) {
      return key.toUpperCase();
    };
    var DEFAULT_DATA_TRANSFORM = function DEFAULT_DATA_TRANSFORM2(cell, column, index) {
      return cell;
    };
    var DEFAULTS = Object.freeze({
      maxWidth: Infinity,
      minWidth: 0,
      columnSplitter: " ",
      truncate: false,
      truncateMarker: "\u2026",
      preserveNewLines: false,
      paddingChr: " ",
      showHeaders: true,
      headingTransform: DEFAULT_HEADING_TRANSFORM,
      dataTransform: DEFAULT_DATA_TRANSFORM
    });
    module.exports = function(items) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var columnConfigs = options.config || {};
      delete options.config;
      var maxLineWidth = options.maxLineWidth || Infinity;
      if (maxLineWidth === "auto") maxLineWidth = process.stdout.columns || Infinity;
      delete options.maxLineWidth;
      options = mixin({}, DEFAULTS, options);
      options.config = options.config || /* @__PURE__ */ Object.create(null);
      options.spacing = options.spacing || "\n";
      options.preserveNewLines = !!options.preserveNewLines;
      options.showHeaders = !!options.showHeaders;
      options.columns = options.columns || options.include;
      var columnNames = options.columns || [];
      items = toArray(items, columnNames);
      if (!columnNames.length) {
        items.forEach(function(item) {
          for (var columnName in item) {
            if (columnNames.indexOf(columnName) === -1) columnNames.push(columnName);
          }
        });
      }
      var columns = columnNames.reduce(function(columns2, columnName) {
        var column = Object.create(options);
        columns2[columnName] = mixin(column, columnConfigs[columnName]);
        return columns2;
      }, /* @__PURE__ */ Object.create(null));
      columnNames.forEach(function(columnName) {
        var column = columns[columnName];
        column.name = columnName;
        column.maxWidth = Math.ceil(column.maxWidth);
        column.minWidth = Math.ceil(column.minWidth);
        column.truncate = !!column.truncate;
        column.align = column.align || "left";
      });
      items = items.map(function(item) {
        var result = /* @__PURE__ */ Object.create(null);
        columnNames.forEach(function(columnName) {
          result[columnName] = item[columnName] != null ? item[columnName] : "";
          result[columnName] = "" + result[columnName];
          if (columns[columnName].preserveNewLines) {
            result[columnName] = result[columnName].replace(/[^\S\n]/gmi, " ");
          } else {
            result[columnName] = result[columnName].replace(/\s/gmi, " ");
          }
        });
        return result;
      });
      columnNames.forEach(function(columnName) {
        var column = columns[columnName];
        items = items.map(function(item, index) {
          var col = Object.create(column);
          item[columnName] = column.dataTransform(item[columnName], col, index);
          var changedKeys = Object.keys(col);
          if (changedKeys.indexOf("name") !== -1) {
            if (column.headingTransform !== DEFAULT_HEADING_TRANSFORM) return;
            column.headingTransform = function(heading) {
              return heading;
            };
          }
          changedKeys.forEach(function(key) {
            return column[key] = col[key];
          });
          return item;
        });
      });
      var headers = {};
      if (options.showHeaders) {
        columnNames.forEach(function(columnName) {
          var column = columns[columnName];
          if (!column.showHeaders) {
            headers[columnName] = "";
            return;
          }
          headers[columnName] = column.headingTransform(column.name);
        });
        items.unshift(headers);
      }
      columnNames.forEach(function(columnName) {
        var column = columns[columnName];
        column.width = items.map(function(item) {
          return item[columnName];
        }).reduce(function(min, cur) {
          if (min >= column.maxWidth) return min;
          return Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, wcwidth(cur))));
        }, 0);
      });
      columnNames.forEach(function(columnName) {
        var column = columns[columnName];
        items = items.map(function(item) {
          item[columnName] = splitLongWords(item[columnName], column.width, column.truncateMarker);
          return item;
        });
      });
      columnNames.forEach(function(columnName) {
        var column = columns[columnName];
        items = items.map(function(item, index) {
          var cell = item[columnName];
          item[columnName] = splitIntoLines(cell, column.width);
          if (column.truncate && item[columnName].length > 1) {
            item[columnName] = splitIntoLines(cell, column.width - wcwidth(column.truncateMarker));
            var firstLine = item[columnName][0];
            if (!endsWith(firstLine, column.truncateMarker)) item[columnName][0] += column.truncateMarker;
            item[columnName] = item[columnName].slice(0, 1);
          }
          return item;
        });
      });
      columnNames.forEach(function(columnName) {
        var column = columns[columnName];
        column.width = items.map(function(item) {
          return item[columnName].reduce(function(min, cur) {
            if (min >= column.maxWidth) return min;
            return Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, wcwidth(cur))));
          }, 0);
        }).reduce(function(min, cur) {
          if (min >= column.maxWidth) return min;
          return Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, cur)));
        }, 0);
      });
      var rows = createRows(items, columns, columnNames, options.paddingChr);
      return rows.reduce(function(output, row) {
        return output.concat(row.reduce(function(rowOut, line) {
          return rowOut.concat(line.join(options.columnSplitter));
        }, []));
      }, []).map(function(line) {
        return truncateString(line, maxLineWidth);
      }).join(options.spacing);
    };
    function createRows(items, columns, columnNames, paddingChr) {
      return items.map(function(item) {
        var row = [];
        var numLines = 0;
        columnNames.forEach(function(columnName) {
          numLines = Math.max(numLines, item[columnName].length);
        });
        var _loop = function _loop2(i2) {
          row[i2] = row[i2] || [];
          columnNames.forEach(function(columnName) {
            var column = columns[columnName];
            var val = item[columnName][i2] || "";
            if (column.align === "right") row[i2].push(padLeft(val, column.width, paddingChr));
            else if (column.align === "center" || column.align === "centre") row[i2].push(padCenter(val, column.width, paddingChr));
            else row[i2].push(padRight(val, column.width, paddingChr));
          });
        };
        for (var i = 0; i < numLines; i++) {
          _loop(i);
        }
        return row;
      });
    }
    function mixin() {
      if (Object.assign) return Object.assign.apply(Object, arguments);
      return ObjectAssign.apply(void 0, arguments);
    }
    function ObjectAssign(target, firstSource) {
      "use strict";
      if (target === void 0 || target === null) throw new TypeError("Cannot convert first argument to object");
      var to = Object(target);
      var hasPendingException = false;
      var pendingException;
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === void 0 || nextSource === null) continue;
        var keysArray = Object.keys(Object(nextSource));
        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
          var nextKey = keysArray[nextIndex];
          try {
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== void 0 && desc.enumerable) to[nextKey] = nextSource[nextKey];
          } catch (e) {
            if (!hasPendingException) {
              hasPendingException = true;
              pendingException = e;
            }
          }
        }
        if (hasPendingException) throw pendingException;
      }
      return to;
    }
    function endsWith(target, searchString, position) {
      position = position || target.length;
      position = position - searchString.length;
      var lastIndex = target.lastIndexOf(searchString);
      return lastIndex !== -1 && lastIndex === position;
    }
    function toArray(items, columnNames) {
      if (Array.isArray(items)) return items;
      var rows = [];
      for (var key in items) {
        var item = {};
        item[columnNames[0] || "key"] = key;
        item[columnNames[1] || "value"] = items[key];
        rows.push(item);
      }
      return rows;
    }
  }
});

// src/index.tsx
init_esm_shims();
var import_react4 = __toESM(require_react(), 1);
import { cwd as cwd2 } from "node:process";

// ../cli-version-manager/src/index.ts
init_esm_shims();

// ../cli-version-manager/src/version-notifier.tsx
init_esm_shims();
var import_semver2 = __toESM(require_semver(), 1);

// ../cli-version-manager/src/package-details-reader.ts
init_esm_shims();
import { join } from "node:path";

// ../../node_modules/package-json/index.js
init_esm_shims();

// ../../node_modules/ky/distribution/index.js
init_esm_shims();

// ../../node_modules/ky/distribution/core/Ky.js
init_esm_shims();

// ../../node_modules/ky/distribution/errors/HTTPError.js
init_esm_shims();
var HTTPError = class extends Error {
  response;
  request;
  options;
  constructor(response, request, options) {
    const code = response.status || response.status === 0 ? response.status : "";
    const title = response.statusText || "";
    const status = `${code} ${title}`.trim();
    const reason = status ? `status code ${status}` : "an unknown error";
    super(`Request failed with ${reason}: ${request.method} ${request.url}`);
    this.name = "HTTPError";
    this.response = response;
    this.request = request;
    this.options = options;
  }
};

// ../../node_modules/ky/distribution/errors/TimeoutError.js
init_esm_shims();
var TimeoutError = class extends Error {
  request;
  constructor(request) {
    super(`Request timed out: ${request.method} ${request.url}`);
    this.name = "TimeoutError";
    this.request = request;
  }
};

// ../../node_modules/ky/distribution/utils/merge.js
init_esm_shims();

// ../../node_modules/ky/distribution/utils/is.js
init_esm_shims();
var isObject = (value) => value !== null && typeof value === "object";

// ../../node_modules/ky/distribution/utils/merge.js
var validateAndMerge = (...sources) => {
  for (const source of sources) {
    if ((!isObject(source) || Array.isArray(source)) && source !== void 0) {
      throw new TypeError("The `options` argument must be an object");
    }
  }
  return deepMerge({}, ...sources);
};
var mergeHeaders = (source1 = {}, source2 = {}) => {
  const result = new globalThis.Headers(source1);
  const isHeadersInstance = source2 instanceof globalThis.Headers;
  const source = new globalThis.Headers(source2);
  for (const [key, value] of source.entries()) {
    if (isHeadersInstance && value === "undefined" || value === void 0) {
      result.delete(key);
    } else {
      result.set(key, value);
    }
  }
  return result;
};
function newHookValue(original, incoming, property) {
  return Object.hasOwn(incoming, property) && incoming[property] === void 0 ? [] : deepMerge(original[property] ?? [], incoming[property] ?? []);
}
var mergeHooks = (original = {}, incoming = {}) => ({
  beforeRequest: newHookValue(original, incoming, "beforeRequest"),
  beforeRetry: newHookValue(original, incoming, "beforeRetry"),
  afterResponse: newHookValue(original, incoming, "afterResponse"),
  beforeError: newHookValue(original, incoming, "beforeError")
});
var deepMerge = (...sources) => {
  let returnValue = {};
  let headers = {};
  let hooks = {};
  for (const source of sources) {
    if (Array.isArray(source)) {
      if (!Array.isArray(returnValue)) {
        returnValue = [];
      }
      returnValue = [...returnValue, ...source];
    } else if (isObject(source)) {
      for (let [key, value] of Object.entries(source)) {
        if (isObject(value) && key in returnValue) {
          value = deepMerge(returnValue[key], value);
        }
        returnValue = { ...returnValue, [key]: value };
      }
      if (isObject(source.hooks)) {
        hooks = mergeHooks(hooks, source.hooks);
        returnValue.hooks = hooks;
      }
      if (isObject(source.headers)) {
        headers = mergeHeaders(headers, source.headers);
        returnValue.headers = headers;
      }
    }
  }
  return returnValue;
};

// ../../node_modules/ky/distribution/utils/normalize.js
init_esm_shims();

// ../../node_modules/ky/distribution/core/constants.js
init_esm_shims();
var supportsRequestStreams = (() => {
  let duplexAccessed = false;
  let hasContentType = false;
  const supportsReadableStream = typeof globalThis.ReadableStream === "function";
  const supportsRequest = typeof globalThis.Request === "function";
  if (supportsReadableStream && supportsRequest) {
    try {
      hasContentType = new globalThis.Request("https://empty.invalid", {
        body: new globalThis.ReadableStream(),
        method: "POST",
        // @ts-expect-error - Types are outdated.
        get duplex() {
          duplexAccessed = true;
          return "half";
        }
      }).headers.has("Content-Type");
    } catch (error) {
      if (error instanceof Error && error.message === "unsupported BodyInit type") {
        return false;
      }
      throw error;
    }
  }
  return duplexAccessed && !hasContentType;
})();
var supportsAbortController = typeof globalThis.AbortController === "function";
var supportsResponseStreams = typeof globalThis.ReadableStream === "function";
var supportsFormData = typeof globalThis.FormData === "function";
var requestMethods = ["get", "post", "put", "patch", "head", "delete"];
var validate = () => void 0;
validate();
var responseTypes = {
  json: "application/json",
  text: "text/*",
  formData: "multipart/form-data",
  arrayBuffer: "*/*",
  blob: "*/*"
};
var maxSafeTimeout = 2147483647;
var stop = Symbol("stop");
var kyOptionKeys = {
  json: true,
  parseJson: true,
  stringifyJson: true,
  searchParams: true,
  prefixUrl: true,
  retry: true,
  timeout: true,
  hooks: true,
  throwHttpErrors: true,
  onDownloadProgress: true,
  fetch: true
};
var requestOptionsRegistry = {
  method: true,
  headers: true,
  body: true,
  mode: true,
  credentials: true,
  cache: true,
  redirect: true,
  referrer: true,
  referrerPolicy: true,
  integrity: true,
  keepalive: true,
  signal: true,
  window: true,
  dispatcher: true,
  duplex: true,
  priority: true
};

// ../../node_modules/ky/distribution/utils/normalize.js
var normalizeRequestMethod = (input) => requestMethods.includes(input) ? input.toUpperCase() : input;
var retryMethods = ["get", "put", "head", "delete", "options", "trace"];
var retryStatusCodes = [408, 413, 429, 500, 502, 503, 504];
var retryAfterStatusCodes = [413, 429, 503];
var defaultRetryOptions = {
  limit: 2,
  methods: retryMethods,
  statusCodes: retryStatusCodes,
  afterStatusCodes: retryAfterStatusCodes,
  maxRetryAfter: Number.POSITIVE_INFINITY,
  backoffLimit: Number.POSITIVE_INFINITY,
  delay: (attemptCount) => 0.3 * 2 ** (attemptCount - 1) * 1e3
};
var normalizeRetryOptions = (retry = {}) => {
  if (typeof retry === "number") {
    return {
      ...defaultRetryOptions,
      limit: retry
    };
  }
  if (retry.methods && !Array.isArray(retry.methods)) {
    throw new Error("retry.methods must be an array");
  }
  if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {
    throw new Error("retry.statusCodes must be an array");
  }
  return {
    ...defaultRetryOptions,
    ...retry
  };
};

// ../../node_modules/ky/distribution/utils/timeout.js
init_esm_shims();
async function timeout(request, init, abortController, options) {
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      if (abortController) {
        abortController.abort();
      }
      reject(new TimeoutError(request));
    }, options.timeout);
    void options.fetch(request, init).then(resolve).catch(reject).then(() => {
      clearTimeout(timeoutId);
    });
  });
}

// ../../node_modules/ky/distribution/utils/delay.js
init_esm_shims();
async function delay(ms, { signal }) {
  return new Promise((resolve, reject) => {
    if (signal) {
      signal.throwIfAborted();
      signal.addEventListener("abort", abortHandler, { once: true });
    }
    function abortHandler() {
      clearTimeout(timeoutId);
      reject(signal.reason);
    }
    const timeoutId = setTimeout(() => {
      signal?.removeEventListener("abort", abortHandler);
      resolve();
    }, ms);
  });
}

// ../../node_modules/ky/distribution/utils/options.js
init_esm_shims();
var findUnknownOptions = (request, options) => {
  const unknownOptions = {};
  for (const key in options) {
    if (!(key in requestOptionsRegistry) && !(key in kyOptionKeys) && !(key in request)) {
      unknownOptions[key] = options[key];
    }
  }
  return unknownOptions;
};

// ../../node_modules/ky/distribution/core/Ky.js
var Ky = class _Ky {
  static create(input, options) {
    const ky2 = new _Ky(input, options);
    const function_ = async () => {
      if (typeof ky2._options.timeout === "number" && ky2._options.timeout > maxSafeTimeout) {
        throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);
      }
      await Promise.resolve();
      let response = await ky2._fetch();
      for (const hook of ky2._options.hooks.afterResponse) {
        const modifiedResponse = await hook(ky2.request, ky2._options, ky2._decorateResponse(response.clone()));
        if (modifiedResponse instanceof globalThis.Response) {
          response = modifiedResponse;
        }
      }
      ky2._decorateResponse(response);
      if (!response.ok && ky2._options.throwHttpErrors) {
        let error = new HTTPError(response, ky2.request, ky2._options);
        for (const hook of ky2._options.hooks.beforeError) {
          error = await hook(error);
        }
        throw error;
      }
      if (ky2._options.onDownloadProgress) {
        if (typeof ky2._options.onDownloadProgress !== "function") {
          throw new TypeError("The `onDownloadProgress` option must be a function");
        }
        if (!supportsResponseStreams) {
          throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");
        }
        return ky2._stream(response.clone(), ky2._options.onDownloadProgress);
      }
      return response;
    };
    const isRetriableMethod = ky2._options.retry.methods.includes(ky2.request.method.toLowerCase());
    const result = isRetriableMethod ? ky2._retry(function_) : function_();
    for (const [type, mimeType] of Object.entries(responseTypes)) {
      result[type] = async () => {
        ky2.request.headers.set("accept", ky2.request.headers.get("accept") || mimeType);
        const response = await result;
        if (type === "json") {
          if (response.status === 204) {
            return "";
          }
          const arrayBuffer = await response.clone().arrayBuffer();
          const responseSize = arrayBuffer.byteLength;
          if (responseSize === 0) {
            return "";
          }
          if (options.parseJson) {
            return options.parseJson(await response.text());
          }
        }
        return response[type]();
      };
    }
    return result;
  }
  request;
  abortController;
  _retryCount = 0;
  _input;
  _options;
  // eslint-disable-next-line complexity
  constructor(input, options = {}) {
    this._input = input;
    this._options = {
      ...options,
      headers: mergeHeaders(this._input.headers, options.headers),
      hooks: mergeHooks({
        beforeRequest: [],
        beforeRetry: [],
        beforeError: [],
        afterResponse: []
      }, options.hooks),
      method: normalizeRequestMethod(options.method ?? this._input.method),
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      prefixUrl: String(options.prefixUrl || ""),
      retry: normalizeRetryOptions(options.retry),
      throwHttpErrors: options.throwHttpErrors !== false,
      timeout: options.timeout ?? 1e4,
      fetch: options.fetch ?? globalThis.fetch.bind(globalThis)
    };
    if (typeof this._input !== "string" && !(this._input instanceof URL || this._input instanceof globalThis.Request)) {
      throw new TypeError("`input` must be a string, URL, or Request");
    }
    if (this._options.prefixUrl && typeof this._input === "string") {
      if (this._input.startsWith("/")) {
        throw new Error("`input` must not begin with a slash when using `prefixUrl`");
      }
      if (!this._options.prefixUrl.endsWith("/")) {
        this._options.prefixUrl += "/";
      }
      this._input = this._options.prefixUrl + this._input;
    }
    if (supportsAbortController) {
      this.abortController = new globalThis.AbortController();
      const originalSignal = this._options.signal ?? this._input.signal;
      if (originalSignal?.aborted) {
        this.abortController.abort(originalSignal?.reason);
      }
      originalSignal?.addEventListener("abort", () => {
        this.abortController.abort(originalSignal.reason);
      });
      this._options.signal = this.abortController.signal;
    }
    if (supportsRequestStreams) {
      this._options.duplex = "half";
    }
    if (this._options.json !== void 0) {
      this._options.body = this._options.stringifyJson?.(this._options.json) ?? JSON.stringify(this._options.json);
      this._options.headers.set("content-type", this._options.headers.get("content-type") ?? "application/json");
    }
    this.request = new globalThis.Request(this._input, this._options);
    if (this._options.searchParams) {
      const textSearchParams = typeof this._options.searchParams === "string" ? this._options.searchParams.replace(/^\?/, "") : new URLSearchParams(this._options.searchParams).toString();
      const searchParams = "?" + textSearchParams;
      const url = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, searchParams);
      if ((supportsFormData && this._options.body instanceof globalThis.FormData || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers["content-type"])) {
        this.request.headers.delete("content-type");
      }
      this.request = new globalThis.Request(new globalThis.Request(url, { ...this.request }), this._options);
    }
  }
  _calculateRetryDelay(error) {
    this._retryCount++;
    if (this._retryCount > this._options.retry.limit || error instanceof TimeoutError) {
      throw error;
    }
    if (error instanceof HTTPError) {
      if (!this._options.retry.statusCodes.includes(error.response.status)) {
        throw error;
      }
      const retryAfter = error.response.headers.get("Retry-After") ?? error.response.headers.get("RateLimit-Reset") ?? error.response.headers.get("X-RateLimit-Reset") ?? error.response.headers.get("X-Rate-Limit-Reset");
      if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {
        let after = Number(retryAfter) * 1e3;
        if (Number.isNaN(after)) {
          after = Date.parse(retryAfter) - Date.now();
        } else if (after >= Date.parse("2024-01-01")) {
          after -= Date.now();
        }
        const max = this._options.retry.maxRetryAfter ?? after;
        return after < max ? after : max;
      }
      if (error.response.status === 413) {
        throw error;
      }
    }
    const retryDelay = this._options.retry.delay(this._retryCount);
    return Math.min(this._options.retry.backoffLimit, retryDelay);
  }
  _decorateResponse(response) {
    if (this._options.parseJson) {
      response.json = async () => this._options.parseJson(await response.text());
    }
    return response;
  }
  async _retry(function_) {
    try {
      return await function_();
    } catch (error) {
      const ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);
      if (this._retryCount < 1) {
        throw error;
      }
      await delay(ms, { signal: this._options.signal });
      for (const hook of this._options.hooks.beforeRetry) {
        const hookResult = await hook({
          request: this.request,
          options: this._options,
          error,
          retryCount: this._retryCount
        });
        if (hookResult === stop) {
          return;
        }
      }
      return this._retry(function_);
    }
  }
  async _fetch() {
    for (const hook of this._options.hooks.beforeRequest) {
      const result = await hook(this.request, this._options);
      if (result instanceof Request) {
        this.request = result;
        break;
      }
      if (result instanceof Response) {
        return result;
      }
    }
    const nonRequestOptions = findUnknownOptions(this.request, this._options);
    const mainRequest = this.request;
    this.request = mainRequest.clone();
    if (this._options.timeout === false) {
      return this._options.fetch(mainRequest, nonRequestOptions);
    }
    return timeout(mainRequest, nonRequestOptions, this.abortController, this._options);
  }
  /* istanbul ignore next */
  _stream(response, onDownloadProgress) {
    const totalBytes = Number(response.headers.get("content-length")) || 0;
    let transferredBytes = 0;
    if (response.status === 204) {
      if (onDownloadProgress) {
        onDownloadProgress({ percent: 1, totalBytes, transferredBytes }, new Uint8Array());
      }
      return new globalThis.Response(null, {
        status: response.status,
        statusText: response.statusText,
        headers: response.headers
      });
    }
    return new globalThis.Response(new globalThis.ReadableStream({
      async start(controller) {
        const reader = response.body.getReader();
        if (onDownloadProgress) {
          onDownloadProgress({ percent: 0, transferredBytes: 0, totalBytes }, new Uint8Array());
        }
        async function read() {
          const { done, value } = await reader.read();
          if (done) {
            controller.close();
            return;
          }
          if (onDownloadProgress) {
            transferredBytes += value.byteLength;
            const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
            onDownloadProgress({ percent, transferredBytes, totalBytes }, value);
          }
          controller.enqueue(value);
          await read();
        }
        await read();
      }
    }), {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers
    });
  }
};

// ../../node_modules/ky/distribution/index.js
var createInstance = (defaults) => {
  const ky2 = (input, options) => Ky.create(input, validateAndMerge(defaults, options));
  for (const method of requestMethods) {
    ky2[method] = (input, options) => Ky.create(input, validateAndMerge(defaults, options, { method }));
  }
  ky2.create = (newDefaults) => createInstance(validateAndMerge(newDefaults));
  ky2.extend = (newDefaults) => {
    if (typeof newDefaults === "function") {
      newDefaults = newDefaults(defaults ?? {});
    }
    return createInstance(validateAndMerge(defaults, newDefaults));
  };
  ky2.stop = stop;
  return ky2;
};
var ky = createInstance();
var distribution_default = ky;

// ../../node_modules/registry-url/index.js
init_esm_shims();
var import_rc = __toESM(require_rc(), 1);
function registryUrl(scope) {
  const result = (0, import_rc.default)("npm", { registry: "https://registry.npmjs.org/" });
  const url = result[`${scope}:registry`] || result.config_registry || result.registry;
  return url.slice(-1) === "/" ? url : `${url}/`;
}

// ../../node_modules/package-json/index.js
var import_registry_auth_token = __toESM(require_registry_auth_token(), 1);
var import_semver = __toESM(require_semver(), 1);
var PackageNotFoundError = class extends Error {
  constructor(packageName) {
    super(`Package \`${packageName}\` could not be found`);
    this.name = "PackageNotFoundError";
  }
};
var VersionNotFoundError = class extends Error {
  constructor(packageName, version) {
    super(`Version \`${version}\` for package \`${packageName}\` could not be found`);
    this.name = "VersionNotFoundError";
  }
};
async function packageJson(packageName, options = {}) {
  let { version = "latest" } = options;
  const { omitDeprecated = true } = options;
  const scope = packageName.split("/")[0];
  const registryUrl_ = options.registryUrl ?? registryUrl(scope);
  const packageUrl = new URL(encodeURIComponent(packageName).replace(/^%40/, "@"), registryUrl_);
  const authInfo = (0, import_registry_auth_token.default)(registryUrl_.toString(), { recursive: true });
  const headers = {
    accept: "application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*"
  };
  if (options.fullMetadata) {
    delete headers.accept;
  }
  if (authInfo) {
    headers.authorization = `${authInfo.type} ${authInfo.token}`;
  }
  let data;
  try {
    data = await distribution_default(packageUrl, { headers, keepalive: true }).json();
  } catch (error) {
    if (error?.response?.status === 404) {
      throw new PackageNotFoundError(packageName);
    }
    throw error;
  }
  if (options.allVersions) {
    return data;
  }
  const versionError = new VersionNotFoundError(packageName, version);
  if (data["dist-tags"][version]) {
    const { time } = data;
    data = data.versions[data["dist-tags"][version]];
    data.time = time;
  } else if (version) {
    const versionExists = Boolean(data.versions[version]);
    if (omitDeprecated && !versionExists) {
      for (const [metadataVersion, metadata] of Object.entries(data.versions)) {
        if (metadata.deprecated) {
          delete data.versions[metadataVersion];
        }
      }
    }
    if (!versionExists) {
      const versions = Object.keys(data.versions);
      version = import_semver.default.maxSatisfying(versions, version);
      if (!version) {
        throw versionError;
      }
    }
    const { time } = data;
    data = data.versions[version];
    data.time = time;
    if (!data) {
      throw versionError;
    }
  }
  return data;
}

// ../cli-version-manager/src/package-details-reader.ts
var import_variant = __toESM(require_lib(), 1);
var versionCacheFileSchema = z.object({
  deprecated: z.string().optional(),
  latestVersion: z.string()
});
async function fetchPackageDetails(packageJson2) {
  let versionCache = null;
  try {
    const { name: packageName, version: packageVersion } = packageJson2;
    const cliCache = createFsCache({
      filePath: getFsCacheFilePath(
        join(__dirname, ".."),
        VERSION_CACHE_FILENAME
      ),
      ttlInHours: 24
    });
    const cacheState = await cliCache.get();
    versionCache = matchVersionState(cacheState);
    if (!versionCache) {
      const cliPackageDetails = await fetchPackageDataFromNpm({
        packageName,
        packageVersion
      });
      versionCache = {
        deprecated: cliPackageDetails.deprecated,
        latestVersion: cliPackageDetails.latestVersion
      };
      await cliCache.set(versionCache);
    }
    return versionCache;
  } catch (e) {
    throw new CliError({
      code: CliErrorCode.FailedToFetchPackageDetails(),
      cause: e
    });
  }
}
function matchVersionState(cacheState) {
  return (0, import_variant.match)(cacheState, {
    Exists: ({ data: versionCache }) => {
      const cache = versionCacheFileSchema.safeParse(versionCache);
      return cache.success ? cache.data : null;
    },
    NotExists: () => null
  });
}
async function fetchPackageDataFromNpm({
  packageName,
  packageVersion
}) {
  const testOverrides = getTestOverrides();
  const packageJsonPromise = packageJson(packageName, {
    registryUrl: testOverrides.registryUrl,
    version: packageVersion,
    allVersions: true
  });
  const result = await pTimeout(packageJsonPromise, {
    message: "Reached timeout while fetching Wix CLI package details",
    milliseconds: 5e3
  });
  if (result instanceof Error) {
    throw result;
  }
  return {
    deprecated: result.versions[packageVersion]?.deprecated,
    latestVersion: result["dist-tags"].latest
  };
}

// ../cli-version-manager/src/version-notifier.tsx
async function versionNotifier(packageJson2) {
  const packageDetails = await fetchPackageDetails(packageJson2);
  return {
    currentVersion: packageJson2.version,
    latestVersion: packageDetails.latestVersion,
    deprecated: packageDetails.deprecated,
    newestVersion: import_semver2.default.eq(packageDetails.latestVersion, packageJson2.version)
  };
}

// src/commander-hooks.ts
init_esm_shims();
var getFullCommandName = (command) => {
  if (command.parent) {
    return `${getFullCommandName(command.parent)} ${command.name()}`.trim();
  }
  return command.name();
};
function addCommandInfoToErrorReports(program, { errorReporter: errorReporter2 }) {
  program.hook("preAction", (_, actionCommand) => {
    const command = getFullCommandName(actionCommand);
    errorReporter2.setContext("command info", {
      args: actionCommand.args,
      command,
      opts: actionCommand.opts()
    });
  });
}

// src/program.ts
init_esm_shims();
var import_variant3 = __toESM(require_lib(), 1);

// src/commands/login.tsx
init_esm_shims();
var import_react = __toESM(require_react(), 1);
var login = (services) => {
  return createCommand("login").description("Log in to your Wix account").option(
    "--api-key <token>",
    "Authenticate using an API key for automations and CI environments"
  ).action(async (options, command) => {
    const { apiKey } = options;
    const { getUserInfo: getUserInfo2 } = await import("./src-3GQRTLXH.js");
    const { LoginCommand } = await import("./LoginCommand-F6JSBTSW.js");
    const { renderCommand } = await import("./render-command-CWA2OK7E.js");
    const userInfo = await getUserInfo2();
    await renderCommand(
      command,
      services,
      /* @__PURE__ */ import_react.default.createElement(LoginCommand, { apiKeyToken: apiKey, userInfo })
    );
  });
};

// src/commands/logout.tsx
init_esm_shims();
var import_react2 = __toESM(require_react(), 1);
var logout = (services) => {
  return createCommand("logout").description("Log out of your Wix account").action(async (_, command) => {
    const { getUserInfo: getUserInfo2 } = await import("./src-3GQRTLXH.js");
    const { LogoutCommand } = await import("./LogoutCommand-J7W5DMRG.js");
    const { renderCommand } = await import("./render-command-CWA2OK7E.js");
    const userInfo = await getUserInfo2();
    await renderCommand(
      command,
      services,
      /* @__PURE__ */ import_react2.default.createElement(LogoutCommand, { userInfo })
    );
  });
};

// src/commands/telemetry.ts
init_esm_shims();
var telemetry = () => {
  return createCommand("telemetry").description(
    "Opt in/out of sending anonymous usage information (telemetry) to Wix"
  ).addArgument(new Argument("<state>", "").choices(["on", "off"])).action(async (state) => {
    const { updateUserConfig } = await import("./src-JG3UNWMO.js");
    const { CliError: CliError2, CliErrorCode: CliErrorCode2 } = await import("./src-KHTSP4W3.js");
    const { createLogger } = await import("./src-BDYMKDQI.js");
    const logger = createLogger();
    try {
      const telemetryEnabled = state === "on";
      await updateUserConfig({ telemetry: telemetryEnabled });
      logger.log(`Telemetry has been turned ${state} successfully.`);
    } catch (e) {
      throw new CliError2({
        cause: e,
        code: CliErrorCode2.FailedToUpdateTelemetryConfig()
      });
    }
  });
};

// src/commands/whoami.tsx
init_esm_shims();
var import_react3 = __toESM(require_react(), 1);
var whoami = (services) => {
  return createCommand("whoami").description("Display the email of the logged in Wix user").action(async (_, command) => {
    const { getUserInfo: getUserInfo2 } = await import("./src-3GQRTLXH.js");
    const { WhoamiCommand } = await import("./WhoamiCommand-PYCDYHLZ.js");
    const { renderCommand } = await import("./render-command-CWA2OK7E.js");
    const userInfo = await getUserInfo2();
    await renderCommand(
      command,
      services,
      /* @__PURE__ */ import_react3.default.createElement(WhoamiCommand, { userInfo })
    );
  });
};

// src/help.ts
init_esm_shims();
import { EOL } from "node:os";
var import_columnify = __toESM(require_columnify(), 1);

// src/constants.ts
init_esm_shims();
var LEARN_MORE_LINK = "https://wix.to/YASTRGa";

// src/help.ts
var helpConfiguration = {
  commandUsage(cmd) {
    return `${source_default.bold(cmd.name())} ${cmd.usage()}`;
  },
  formatHelp(cmd, helper) {
    const usage = `${source_default.dim("Usage:")}
  ${helper.commandUsage(cmd)}`;
    const commands = helper.visibleCommands(cmd).map((cmd2) => {
      return {
        term: cmd2.name(),
        usage: cmd2.usage(),
        // `columnify` relies on the order of object keys
        // eslint-disable-next-line perfectionist/sort-objects
        description: helper.commandDescription(cmd2)
      };
    });
    const options = helper.visibleOptions(cmd).map((opt) => {
      return {
        term: helper.optionTerm(opt),
        // `columnify` relies on the order of object keys
        // eslint-disable-next-line perfectionist/sort-objects
        description: helper.optionDescription(opt)
      };
    });
    const columnified = (0, import_columnify.default)([...commands, ...options], {
      columnSplitter: "  ",
      showHeaders: false
    }).split(EOL).map((row) => `  ${row}`);
    const columnifiedOptions = columnified.splice(commands.length);
    const columnifiedCommands = columnified;
    const formattedCommands = `${source_default.dim(
      "Commands:"
    )}${EOL}${columnifiedCommands.join(EOL)}`;
    const formattedOptions = `${source_default.dim(
      "Options:"
    )}${EOL}${columnifiedOptions.join(EOL)}`;
    const learnMore = `${source_default.dim("Learn More:")}
  Learn more at ${LEARN_MORE_LINK}${EOL}`;
    return `${[usage, formattedCommands, formattedOptions, learnMore].join(
      EOL.repeat(2)
    )}${EOL}`;
  },
  sortOptions: true,
  sortSubcommands: true
};

// src/program-flow.ts
init_esm_shims();
var import_variant2 = __toESM(require_lib(), 1);

// src/cli-app.ts
init_esm_shims();
import { createRequire } from "node:module";
import { join as join2 } from "node:path";
import { cwd } from "node:process";
import { pathToFileURL } from "node:url";
var import_prerelease = __toESM(require_prerelease(), 1);
var requireCwd = createRequire(
  join2(
    cwd(),
    // `createRequire` must accept a path to a file, but doesn't really care about it
    // Even Sindre did it:
    // https://github.com/sindresorhus/import-from/blob/6063941cfac93086ae7f5a2e9ec2ac23f4bee401/index.js#L9
    "dummy.js"
  )
);
async function importCliApp(config) {
  if (Object.hasOwn(config, "appId")) {
    const cliAppPath = resolveCliAppPath();
    if (cliAppPath) {
      ensureCompatibleVersions();
      return importCliAppFromPath(cliAppPath);
    }
  }
  return null;
}
function resolveCliAppPath() {
  try {
    return requireCwd.resolve("@wix/cli-app");
  } catch (e) {
    if (e instanceof Error && "code" in e && e.code === "MODULE_NOT_FOUND") {
      return null;
    }
    throw new CliError({
      cause: e,
      code: CliErrorCode.FailedToImportCliApp()
    });
  }
}
function ensureCompatibleVersions() {
  const cliAppVersion = requireCwd("@wix/cli-app/package.json").version;
  if ((0, import_prerelease.default)(cliAppVersion) != null) {
    return;
  }
  if (package_default.version !== cliAppVersion) {
    throw new CliError({
      cause: null,
      code: CliErrorCode.CliAppVersionMismatch({
        cliAppVersion,
        cliVersion: package_default.version
      })
    });
  }
}
async function importCliAppFromPath(cliAppPath) {
  try {
    return await import(pathToFileURL(cliAppPath).href);
  } catch (e) {
    throw new CliError({
      cause: e,
      code: CliErrorCode.FailedToImportCliApp()
    });
  }
}

// src/cli-astro.ts
init_esm_shims();
async function importCliAstro(config, projectFolder2) {
  if (Object.hasOwn(config, "appId")) {
    const astroExists = await hasAstroConfigurationFile(projectFolder2);
    if (astroExists) {
      return import("./src-NPO6Z5GU.js");
    }
  }
  return null;
}
async function hasAstroConfigurationFile(projectFolder2) {
  const configFilesFound = await globby("astro.config.{js,cjs,mjs,ts}", {
    cwd: projectFolder2,
    onlyFiles: true
  });
  return configFilesFound.length === 1;
}

// src/cli-site.ts
init_esm_shims();
import { env } from "node:process";
async function importCliSite(config) {
  if (!Object.hasOwn(config, "siteId")) {
    return null;
  }
  if (env.WIX_CLI_SITE_LIVE === "true" && Object.hasOwn(config, "veloAppId")) {
    return import("./src-32UY4VQ4.js");
  }
  if (!Object.hasOwn(config, "uiVersion")) {
    return import("./src-NL5RQAZD.js");
  }
  return import("./src-HVSSKZSZ.js");
}

// src/files/wix.config.ts
init_esm_shims();
var wixConfigSchema = z.object({}).passthrough();
async function readWixConfig(projectFolder2) {
  const configFile = await readJson(getWixConfigFilePath(projectFolder2));
  const config = wixConfigSchema.safeParse(configFile);
  if (config.success) {
    return config.data;
  }
  throw new CliError({
    cause: config.error,
    code: CliErrorCode.InvalidConfigSchemaError({
      configPath: WIX_CONFIG_FILENAME,
      zodError: config.error
    })
  });
}
function isWixConfigExists(projectFolder2) {
  return pathExists(getWixConfigFilePath(projectFolder2));
}

// src/program-flow.ts
var ProgramFlow = (0, import_variant2.variant)({
  APP: (0, import_variant2.fields)(),
  ASTRO: (0, import_variant2.fields)(),
  SITE: (0, import_variant2.fields)(),
  UNKNOWN: (0, import_variant2.fields)()
});
async function identifyProgramFlow(projectFolder2) {
  const isConfigExist = await isWixConfigExists(projectFolder2);
  if (!isConfigExist) {
    return ProgramFlow.UNKNOWN({
      reason: `Project type could not be determined due to a missing configuration file "${WIX_CONFIG_FILENAME}".`
    });
  }
  const config = await readWixConfig(projectFolder2);
  const astro = await importCliAstro(config, projectFolder2);
  if (astro) {
    return ProgramFlow.ASTRO({ getRootCommand: astro.getRootCommand });
  }
  const app = await importCliApp(config);
  if (app) {
    return ProgramFlow.APP({ getRootCommand: app.getRootCommand });
  }
  const site = await importCliSite(config);
  if (site) {
    return ProgramFlow.SITE({ getRootCommand: site.getRootCommand });
  }
  return ProgramFlow.UNKNOWN({
    reason: "A configuration file was found, but it is either malformed or missing required fields, preventing project type identification."
  });
}

// src/program.ts
async function createProgram({
  biLogger,
  errorReporter: errorReporter2,
  projectFolder: projectFolder2
}) {
  const program = new Command();
  program.name("wix");
  program.version(
    package_default.version,
    "-v, --version",
    "Output the version number"
  );
  program.enablePositionalOptions(true);
  program.helpOption("-h, --help", "Display help for command");
  program.helpCommand(false);
  program.configureHelp(helpConfiguration);
  const flow = await identifyProgramFlow(projectFolder2);
  errorReporter2.setTag("flow", flow.type);
  await (0, import_variant3.match)(flow, {
    APP: async ({ getRootCommand }) => {
      const app = await getRootCommand(
        { biLogger, errorReporter: errorReporter2 },
        package_default.version
      );
      program.addCommand(app);
    },
    ASTRO: async ({ getRootCommand }) => {
      const astro = await getRootCommand(
        { biLogger, errorReporter: errorReporter2 },
        package_default.version
      );
      for (const command of astro.commands) {
        program.addCommand(command);
      }
    },
    SITE: async ({ getRootCommand }) => {
      const site = await getRootCommand(
        { biLogger, errorReporter: errorReporter2 },
        package_default.version
      );
      for (const command of site.commands) {
        program.addCommand(command);
      }
    },
    UNKNOWN: ({ reason }) => {
      program.on("command:*", () => {
        throw new CliError({
          cause: void 0,
          code: CliErrorCode.FailedToIdentifyProgramFlow({ reason })
        });
      });
    }
  });
  program.addCommand(login({ biLogger, errorReporter: errorReporter2 })).addCommand(whoami({ biLogger, errorReporter: errorReporter2 })).addCommand(logout({ biLogger, errorReporter: errorReporter2 })).addCommand(telemetry());
  const hasCliAppInstalled = (0, import_variant3.isType)(flow, "APP");
  return { hasCliAppInstalled, program };
}

// src/index.tsx
setupTestEnv();
var projectFolder = cwd2();
function setupErrorHandling() {
  const {
    errorReporter: errorReporter2,
    handler: errorHandler2,
    registerToProcessErrors
  } = createErrorHandler({
    debugOutputPath: getDebugLogFilePath(projectFolder),
    dsn: SENTRY_DSN,
    release: package_default.version,
    userFeedbackCachePath: getUserFeedbackCacheFilePath(projectFolder)
  });
  registerToProcessErrors();
  return { errorHandler: errorHandler2, errorReporter: errorReporter2 };
}
var { errorHandler, errorReporter } = setupErrorHandling();
try {
  const userInfo = await getUserInfo();
  if (userInfo) {
    errorReporter.setUser({ id: userInfo.userId });
  }
  const { biLogger } = await createBiLogger(errorReporter, userInfo?.userId);
  const packageDetails = await versionNotifier(package_default).catch(
    (error) => {
      errorReporter.reportError(error);
      writeCrashReport(getDebugLogFilePath(cwd2()), error);
    }
  );
  const { program, hasCliAppInstalled } = await createProgram({
    biLogger,
    errorReporter,
    projectFolder
  });
  if (packageDetails?.deprecated) {
    throw new CliError({
      code: CliErrorCode.DeprecatedVersion({
        ...packageDetails,
        hasCliAppInstalled
      }),
      cause: void 0
    });
  }
  addCommandInfoToErrorReports(program, { errorReporter });
  const actionCommand = await program.parseAsync();
  if (packageDetails?.newestVersion === false && !actionCommand.args.includes(NO_TTY_JSON_OUTPUT_OPTION)) {
    await render(
      /* @__PURE__ */ import_react4.default.createElement(
        OutdatedVersionMessage,
        {
          currentVersion: packageDetails.currentVersion,
          latestVersion: packageDetails.latestVersion,
          hasCliAppInstalled
        }
      )
    );
  }
} catch (error) {
  errorHandler({ error });
}
/*! Bundled license information:

deep-extend/lib/deep-extend.js:
  (*!
   * @description Recursive object extending
   * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
   * @license MIT
   *
   * The MIT License (MIT)
   *
   * Copyright (c) 2013-2018 Viacheslav Lotsmanov
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy of
   * this software and associated documentation files (the "Software"), to deal in
   * the Software without restriction, including without limitation the rights to
   * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   * the Software, and to permit persons to whom the Software is furnished to do so,
   * subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
   * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
   * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *)

ky/distribution/index.js:
  (*! MIT License © Sindre Sorhus *)
*/
//# sourceMappingURL=index.js.map