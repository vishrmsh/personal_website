import { createRequire as _createRequire } from 'node:module';
const require = _createRequire(import.meta.url);
import {
  require_ci_info,
  require_index_node,
  require_src
} from "./chunk-SJKVYZPL.js";
import {
  I18nProvider,
  Trans,
  useTranslation
} from "./chunk-UQLHXG4X.js";
import {
  Alert,
  Box_default,
  ConfirmInput,
  ErrorDetails,
  Link,
  Newline,
  Notification,
  Text,
  TextInput,
  render,
  renderErrorSync,
  renderSync
} from "./chunk-RXATQXHV.js";
import {
  require_react
} from "./chunk-NRAQAV6T.js";
import {
  DiagLogLevel,
  SEMATTRS_HTTP_ROUTE,
  SEMRESATTRS_PROCESS_RUNTIME_NAME,
  SEMRESATTRS_TELEMETRY_SDK_LANGUAGE,
  SEMRESATTRS_TELEMETRY_SDK_NAME,
  SEMRESATTRS_TELEMETRY_SDK_VERSION,
  SamplingDecision,
  TELEMETRYSDKLANGUAGEVALUES_NODEJS,
  TraceFlags,
  baggageEntryMetadataFromString,
  context,
  createContextKey,
  diag,
  esm_exports,
  esm_exports2,
  init_esm,
  init_esm2,
  isSpanContextValid,
  isValidTraceId,
  metrics,
  propagation,
  trace
} from "./chunk-Z4MHKCET.js";
import {
  LRUMap,
  SDK_VERSION,
  SEMANTIC_ATTRIBUTE_CACHE_HIT,
  SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE,
  SEMANTIC_ATTRIBUTE_CACHE_KEY,
  SEMANTIC_ATTRIBUTE_SENTRY_OP,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  Scope,
  ServerRuntimeClient,
  _nullishCoalesce,
  _optionalChain,
  addBreadcrumb,
  addConsoleInstrumentationHandler,
  applySdkMetadata,
  baggageHeaderToDynamicSamplingContext,
  captureException,
  consoleSandbox,
  createStackParser,
  createTransport,
  defineIntegration,
  dirname,
  dynamicSamplingContextToSentryBaggageHeader,
  flatten,
  functionToStringIntegration,
  getCapturedScopesOnSpan,
  getClient,
  getCurrentScope,
  getDefaultIsolationScope,
  getDynamicSamplingContextFromSpan,
  getIsolationScope,
  getRootSpan,
  getSanitizedUrlString,
  hasTracingEnabled,
  inboundFiltersIntegration,
  isSentryRequestUrl,
  linkedErrorsIntegration,
  logger,
  nodeStackLineParser,
  parseSemver,
  parseUrl,
  requestDataIntegration,
  setCapturedScopesOnSpan,
  severityLevelFromString,
  snipLine,
  spanToJSON,
  stripUrlQueryAndFragment,
  suppressTracing,
  truncate
} from "./chunk-C4SUTB4O.js";
import {
  getTestOverrides
} from "./chunk-WYHHEOWO.js";
import {
  pathExists,
  readJson,
  writeJson
} from "./chunk-Z3Y5NFYG.js";
import {
  z
} from "./chunk-ZXYGJZOO.js";
import {
  CliError,
  CliErrorCode,
  CliSystemErrorCode,
  isCliError,
  isCliSystemError,
  normalizeError,
  require_lib,
  require_verror
} from "./chunk-IVMK6TVY.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM,
  init_esm_shims
} from "./chunk-4EFJZ3GQ.js";

// ../../node_modules/@opentelemetry/core/build/esm/trace/suppress-tracing.js
function suppressTracing2(context2) {
  return context2.setValue(SUPPRESS_TRACING_KEY, true);
}
function unsuppressTracing(context2) {
  return context2.deleteValue(SUPPRESS_TRACING_KEY);
}
function isTracingSuppressed(context2) {
  return context2.getValue(SUPPRESS_TRACING_KEY) === true;
}
var SUPPRESS_TRACING_KEY;
var init_suppress_tracing = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/trace/suppress-tracing.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    SUPPRESS_TRACING_KEY = createContextKey("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/baggage/constants.js
var BAGGAGE_KEY_PAIR_SEPARATOR, BAGGAGE_PROPERTIES_SEPARATOR, BAGGAGE_ITEMS_SEPARATOR, BAGGAGE_HEADER, BAGGAGE_MAX_NAME_VALUE_PAIRS, BAGGAGE_MAX_PER_NAME_VALUE_PAIRS, BAGGAGE_MAX_TOTAL_LENGTH;
var init_constants = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/baggage/constants.js"() {
    "use strict";
    init_esm_shims();
    BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    BAGGAGE_PROPERTIES_SEPARATOR = ";";
    BAGGAGE_ITEMS_SEPARATOR = ",";
    BAGGAGE_HEADER = "baggage";
    BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/baggage/utils.js
var utils_exports = {};
__export(utils_exports, {
  getKeyPairs: () => getKeyPairs,
  parseKeyPairsIntoRecord: () => parseKeyPairsIntoRecord,
  parsePairKeyValue: () => parsePairKeyValue,
  serializeKeyPairs: () => serializeKeyPairs
});
function serializeKeyPairs(keyPairs) {
  return keyPairs.reduce(function(hValue, current) {
    var value = "" + hValue + (hValue !== "" ? BAGGAGE_ITEMS_SEPARATOR : "") + current;
    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
  }, "");
}
function getKeyPairs(baggage) {
  return baggage.getAllEntries().map(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], value = _b[1];
    var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
    if (value.metadata !== void 0) {
      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
    }
    return entry;
  });
}
function parsePairKeyValue(entry) {
  var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);
  if (valueProps.length <= 0)
    return;
  var keyPairPart = valueProps.shift();
  if (!keyPairPart)
    return;
  var separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);
  if (separatorIndex <= 0)
    return;
  var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
  var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
  var metadata;
  if (valueProps.length > 0) {
    metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));
  }
  return { key, value, metadata };
}
function parseKeyPairsIntoRecord(value) {
  if (typeof value !== "string" || value.length === 0)
    return {};
  return value.split(BAGGAGE_ITEMS_SEPARATOR).map(function(entry) {
    return parsePairKeyValue(entry);
  }).filter(function(keyPair) {
    return keyPair !== void 0 && keyPair.value.length > 0;
  }).reduce(function(headers, keyPair) {
    headers[keyPair.key] = keyPair.value;
    return headers;
  }, {});
}
var __read;
var init_utils = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/baggage/utils.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    init_constants();
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js
var W3CBaggagePropagator;
var init_W3CBaggagePropagator = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    init_suppress_tracing();
    init_constants();
    init_utils();
    W3CBaggagePropagator = /** @class */
    function() {
      function W3CBaggagePropagator2() {
      }
      W3CBaggagePropagator2.prototype.inject = function(context2, carrier, setter) {
        var baggage = propagation.getBaggage(context2);
        if (!baggage || isTracingSuppressed(context2))
          return;
        var keyPairs = getKeyPairs(baggage).filter(function(pair) {
          return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);
        var headerValue = serializeKeyPairs(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, BAGGAGE_HEADER, headerValue);
        }
      };
      W3CBaggagePropagator2.prototype.extract = function(context2, carrier, getter) {
        var headerValue = getter.get(carrier, BAGGAGE_HEADER);
        var baggageString = Array.isArray(headerValue) ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context2;
        var baggage = {};
        if (baggageString.length === 0) {
          return context2;
        }
        var pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach(function(entry) {
          var keyPair = parsePairKeyValue(entry);
          if (keyPair) {
            var baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context2;
        }
        return propagation.setBaggage(context2, propagation.createBaggage(baggage));
      };
      W3CBaggagePropagator2.prototype.fields = function() {
        return [BAGGAGE_HEADER];
      };
      return W3CBaggagePropagator2;
    }();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/common/anchored-clock.js
var AnchoredClock;
var init_anchored_clock = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/common/anchored-clock.js"() {
    "use strict";
    init_esm_shims();
    AnchoredClock = /** @class */
    function() {
      function AnchoredClock2(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
      }
      AnchoredClock2.prototype.now = function() {
        var delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      };
      return AnchoredClock2;
    }();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/common/attributes.js
function sanitizeAttributes(attributes) {
  var e_1, _a2;
  var out = {};
  if (typeof attributes !== "object" || attributes == null) {
    return out;
  }
  try {
    for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var _d = __read2(_c.value, 2), key = _d[0], val = _d[1];
      if (!isAttributeKey(key)) {
        diag.warn("Invalid attribute key: " + key);
        continue;
      }
      if (!isAttributeValue(val)) {
        diag.warn("Invalid attribute value set for key: " + key);
        continue;
      }
      if (Array.isArray(val)) {
        out[key] = val.slice();
      } else {
        out[key] = val;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return out;
}
function isAttributeKey(key) {
  return typeof key === "string" && key.length > 0;
}
function isAttributeValue(val) {
  if (val == null) {
    return true;
  }
  if (Array.isArray(val)) {
    return isHomogeneousAttributeValueArray(val);
  }
  return isValidPrimitiveAttributeValue(val);
}
function isHomogeneousAttributeValueArray(arr) {
  var e_2, _a2;
  var type;
  try {
    for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
      var element = arr_1_1.value;
      if (element == null)
        continue;
      if (!type) {
        if (isValidPrimitiveAttributeValue(element)) {
          type = typeof element;
          continue;
        }
        return false;
      }
      if (typeof element === type) {
        continue;
      }
      return false;
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (arr_1_1 && !arr_1_1.done && (_a2 = arr_1.return)) _a2.call(arr_1);
    } finally {
      if (e_2) throw e_2.error;
    }
  }
  return true;
}
function isValidPrimitiveAttributeValue(val) {
  switch (typeof val) {
    case "number":
    case "boolean":
    case "string":
      return true;
  }
  return false;
}
var __values, __read2;
var init_attributes = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/common/attributes.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/common/logging-error-handler.js
function loggingErrorHandler() {
  return function(ex) {
    diag.error(stringifyException(ex));
  };
}
function stringifyException(ex) {
  if (typeof ex === "string") {
    return ex;
  } else {
    return JSON.stringify(flattenException(ex));
  }
}
function flattenException(ex) {
  var result = {};
  var current = ex;
  while (current !== null) {
    Object.getOwnPropertyNames(current).forEach(function(propertyName) {
      if (result[propertyName])
        return;
      var value = current[propertyName];
      if (value) {
        result[propertyName] = String(value);
      }
    });
    current = Object.getPrototypeOf(current);
  }
  return result;
}
var init_logging_error_handler = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/common/logging-error-handler.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/common/global-error-handler.js
function setGlobalErrorHandler(handler) {
  delegateHandler = handler;
}
function globalErrorHandler(ex) {
  try {
    delegateHandler(ex);
  } catch (_a2) {
  }
}
var delegateHandler;
var init_global_error_handler = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/common/global-error-handler.js"() {
    "use strict";
    init_esm_shims();
    init_logging_error_handler();
    delegateHandler = loggingErrorHandler();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/utils/sampling.js
var TracesSamplerValues;
var init_sampling = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/utils/sampling.js"() {
    "use strict";
    init_esm_shims();
    (function(TracesSamplerValues2) {
      TracesSamplerValues2["AlwaysOff"] = "always_off";
      TracesSamplerValues2["AlwaysOn"] = "always_on";
      TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues || (TracesSamplerValues = {}));
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/utils/environment.js
function isEnvVarABoolean(key) {
  return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
}
function isEnvVarANumber(key) {
  return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
}
function isEnvVarAList(key) {
  return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
}
function parseBoolean(key, environment, values) {
  if (typeof values[key] === "undefined") {
    return;
  }
  var value = String(values[key]);
  environment[key] = value.toLowerCase() === "true";
}
function parseNumber(name, environment, values, min, max) {
  if (min === void 0) {
    min = -Infinity;
  }
  if (max === void 0) {
    max = Infinity;
  }
  if (typeof values[name] !== "undefined") {
    var value = Number(values[name]);
    if (!isNaN(value)) {
      if (value < min) {
        environment[name] = min;
      } else if (value > max) {
        environment[name] = max;
      } else {
        environment[name] = value;
      }
    }
  }
}
function parseStringList(name, output, input, separator) {
  if (separator === void 0) {
    separator = DEFAULT_LIST_SEPARATOR;
  }
  var givenValue = input[name];
  if (typeof givenValue === "string") {
    output[name] = givenValue.split(separator).map(function(v) {
      return v.trim();
    });
  }
}
function setLogLevelFromEnv(key, environment, values) {
  var value = values[key];
  if (typeof value === "string") {
    var theLevel = logLevelMap[value.toUpperCase()];
    if (theLevel != null) {
      environment[key] = theLevel;
    }
  }
}
function parseEnvironment(values) {
  var environment = {};
  for (var env in DEFAULT_ENVIRONMENT) {
    var key = env;
    switch (key) {
      case "OTEL_LOG_LEVEL":
        setLogLevelFromEnv(key, environment, values);
        break;
      default:
        if (isEnvVarABoolean(key)) {
          parseBoolean(key, environment, values);
        } else if (isEnvVarANumber(key)) {
          parseNumber(key, environment, values);
        } else if (isEnvVarAList(key)) {
          parseStringList(key, environment, values);
        } else {
          var value = values[key];
          if (typeof value !== "undefined" && value !== null) {
            environment[key] = String(value);
          }
        }
    }
  }
  return environment;
}
var DEFAULT_LIST_SEPARATOR, ENVIRONMENT_BOOLEAN_KEYS, ENVIRONMENT_NUMBERS_KEYS, ENVIRONMENT_LISTS_KEYS, DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT, DEFAULT_ATTRIBUTE_COUNT_LIMIT, DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT, DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT, DEFAULT_ENVIRONMENT, logLevelMap;
var init_environment = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/utils/environment.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    init_sampling();
    DEFAULT_LIST_SEPARATOR = ",";
    ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS"
    ];
    DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: false,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
    };
    logLevelMap = {
      ALL: DiagLogLevel.ALL,
      VERBOSE: DiagLogLevel.VERBOSE,
      DEBUG: DiagLogLevel.DEBUG,
      INFO: DiagLogLevel.INFO,
      WARN: DiagLogLevel.WARN,
      ERROR: DiagLogLevel.ERROR,
      NONE: DiagLogLevel.NONE
    };
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/platform/node/environment.js
function getEnv() {
  var processEnv = parseEnvironment(process.env);
  return Object.assign({}, DEFAULT_ENVIRONMENT, processEnv);
}
function getEnvWithoutDefaults() {
  return parseEnvironment(process.env);
}
var init_environment2 = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/platform/node/environment.js"() {
    "use strict";
    init_esm_shims();
    init_environment();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/platform/node/globalThis.js
var _globalThis;
var init_globalThis = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/platform/node/globalThis.js"() {
    "use strict";
    init_esm_shims();
    _globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/common/hex-to-binary.js
function intValue(charCode) {
  if (charCode >= 48 && charCode <= 57) {
    return charCode - 48;
  }
  if (charCode >= 97 && charCode <= 102) {
    return charCode - 87;
  }
  return charCode - 55;
}
function hexToBinary(hexStr) {
  var buf = new Uint8Array(hexStr.length / 2);
  var offset = 0;
  for (var i = 0; i < hexStr.length; i += 2) {
    var hi = intValue(hexStr.charCodeAt(i));
    var lo = intValue(hexStr.charCodeAt(i + 1));
    buf[offset++] = hi << 4 | lo;
  }
  return buf;
}
var init_hex_to_binary = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/common/hex-to-binary.js"() {
    "use strict";
    init_esm_shims();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/platform/node/hex-to-base64.js
function hexToBase64(hexStr) {
  return Buffer.from(hexToBinary(hexStr)).toString("base64");
}
var init_hex_to_base64 = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/platform/node/hex-to-base64.js"() {
    "use strict";
    init_esm_shims();
    init_hex_to_binary();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/platform/node/RandomIdGenerator.js
function getIdGenerator(bytes) {
  return function generateId() {
    for (var i = 0; i < bytes / 4; i++) {
      SHARED_BUFFER.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, i * 4);
    }
    for (var i = 0; i < bytes; i++) {
      if (SHARED_BUFFER[i] > 0) {
        break;
      } else if (i === bytes - 1) {
        SHARED_BUFFER[bytes - 1] = 1;
      }
    }
    return SHARED_BUFFER.toString("hex", 0, bytes);
  };
}
var SPAN_ID_BYTES, TRACE_ID_BYTES, RandomIdGenerator, SHARED_BUFFER;
var init_RandomIdGenerator = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/platform/node/RandomIdGenerator.js"() {
    "use strict";
    init_esm_shims();
    SPAN_ID_BYTES = 8;
    TRACE_ID_BYTES = 16;
    RandomIdGenerator = /** @class */
    /* @__PURE__ */ function() {
      function RandomIdGenerator2() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
      return RandomIdGenerator2;
    }();
    SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/platform/node/performance.js
import { performance } from "perf_hooks";
var otperformance;
var init_performance = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/platform/node/performance.js"() {
    "use strict";
    init_esm_shims();
    otperformance = performance;
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/version.js
var VERSION;
var init_version = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/version.js"() {
    "use strict";
    init_esm_shims();
    VERSION = "1.25.1";
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/platform/node/sdk-info.js
var _a, SDK_INFO;
var init_sdk_info = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/platform/node/sdk-info.js"() {
    "use strict";
    init_esm_shims();
    init_version();
    init_esm2();
    SDK_INFO = (_a = {}, _a[SEMRESATTRS_TELEMETRY_SDK_NAME] = "opentelemetry", _a[SEMRESATTRS_PROCESS_RUNTIME_NAME] = "node", _a[SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = TELEMETRYSDKLANGUAGEVALUES_NODEJS, _a[SEMRESATTRS_TELEMETRY_SDK_VERSION] = VERSION, _a);
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/platform/node/timer-util.js
function unrefTimer(timer) {
  timer.unref();
}
var init_timer_util = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/platform/node/timer-util.js"() {
    "use strict";
    init_esm_shims();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/platform/node/index.js
var init_node = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/platform/node/index.js"() {
    "use strict";
    init_esm_shims();
    init_environment2();
    init_globalThis();
    init_hex_to_base64();
    init_RandomIdGenerator();
    init_performance();
    init_sdk_info();
    init_timer_util();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/platform/index.js
var init_platform = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/platform/index.js"() {
    "use strict";
    init_esm_shims();
    init_node();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/common/time.js
function millisToHrTime(epochMillis) {
  var epochSeconds = epochMillis / 1e3;
  var seconds = Math.trunc(epochSeconds);
  var nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
  return [seconds, nanos];
}
function getTimeOrigin() {
  var timeOrigin = otperformance.timeOrigin;
  if (typeof timeOrigin !== "number") {
    var perf = otperformance;
    timeOrigin = perf.timing && perf.timing.fetchStart;
  }
  return timeOrigin;
}
function hrTime(performanceNow) {
  var timeOrigin = millisToHrTime(getTimeOrigin());
  var now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : otperformance.now());
  return addHrTimes(timeOrigin, now);
}
function timeInputToHrTime(time) {
  if (isTimeInputHrTime(time)) {
    return time;
  } else if (typeof time === "number") {
    if (time < getTimeOrigin()) {
      return hrTime(time);
    } else {
      return millisToHrTime(time);
    }
  } else if (time instanceof Date) {
    return millisToHrTime(time.getTime());
  } else {
    throw TypeError("Invalid input type");
  }
}
function hrTimeDuration(startTime, endTime) {
  var seconds = endTime[0] - startTime[0];
  var nanos = endTime[1] - startTime[1];
  if (nanos < 0) {
    seconds -= 1;
    nanos += SECOND_TO_NANOSECONDS;
  }
  return [seconds, nanos];
}
function hrTimeToTimeStamp(time) {
  var precision = NANOSECOND_DIGITS;
  var tmp = "" + "0".repeat(precision) + time[1] + "Z";
  var nanoString = tmp.substr(tmp.length - precision - 1);
  var date = new Date(time[0] * 1e3).toISOString();
  return date.replace("000Z", nanoString);
}
function hrTimeToNanoseconds(time) {
  return time[0] * SECOND_TO_NANOSECONDS + time[1];
}
function hrTimeToMilliseconds(time) {
  return time[0] * 1e3 + time[1] / 1e6;
}
function hrTimeToMicroseconds(time) {
  return time[0] * 1e6 + time[1] / 1e3;
}
function isTimeInputHrTime(value) {
  return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
}
function isTimeInput(value) {
  return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
}
function addHrTimes(time1, time2) {
  var out = [time1[0] + time2[0], time1[1] + time2[1]];
  if (out[1] >= SECOND_TO_NANOSECONDS) {
    out[1] -= SECOND_TO_NANOSECONDS;
    out[0] += 1;
  }
  return out;
}
var NANOSECOND_DIGITS, NANOSECOND_DIGITS_IN_MILLIS, MILLISECONDS_TO_NANOSECONDS, SECOND_TO_NANOSECONDS;
var init_time = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/common/time.js"() {
    "use strict";
    init_esm_shims();
    init_platform();
    NANOSECOND_DIGITS = 9;
    NANOSECOND_DIGITS_IN_MILLIS = 6;
    MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/common/types.js
var init_types = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/common/types.js"() {
    "use strict";
    init_esm_shims();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/ExportResult.js
var ExportResultCode;
var init_ExportResult = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/ExportResult.js"() {
    "use strict";
    init_esm_shims();
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode || (ExportResultCode = {}));
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/propagation/composite.js
var __values2, CompositePropagator;
var init_composite = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/propagation/composite.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    __values2 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    CompositePropagator = /** @class */
    function() {
      function CompositePropagator2(config) {
        if (config === void 0) {
          config = {};
        }
        var _a2;
        this._propagators = (_a2 = config.propagators) !== null && _a2 !== void 0 ? _a2 : [];
        this._fields = Array.from(new Set(this._propagators.map(function(p) {
          return typeof p.fields === "function" ? p.fields() : [];
        }).reduce(function(x, y) {
          return x.concat(y);
        }, [])));
      }
      CompositePropagator2.prototype.inject = function(context2, carrier, setter) {
        var e_1, _a2;
        try {
          for (var _b = __values2(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {
            var propagator = _c.value;
            try {
              propagator.inject(context2, carrier, setter);
            } catch (err) {
              diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      };
      CompositePropagator2.prototype.extract = function(context2, carrier, getter) {
        return this._propagators.reduce(function(ctx, propagator) {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
          }
          return ctx;
        }, context2);
      };
      CompositePropagator2.prototype.fields = function() {
        return this._fields.slice();
      };
      return CompositePropagator2;
    }();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/internal/validators.js
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}
var VALID_KEY_CHAR_RANGE, VALID_KEY, VALID_VENDOR_KEY, VALID_KEY_REGEX, VALID_VALUE_BASE_REGEX, INVALID_VALUE_COMMA_EQUAL_REGEX;
var init_validators = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/internal/validators.js"() {
    "use strict";
    init_esm_shims();
    VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/trace/TraceState.js
var MAX_TRACE_STATE_ITEMS, MAX_TRACE_STATE_LEN, LIST_MEMBERS_SEPARATOR, LIST_MEMBER_KEY_VALUE_SPLITTER, TraceState;
var init_TraceState = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/trace/TraceState.js"() {
    "use strict";
    init_esm_shims();
    init_validators();
    MAX_TRACE_STATE_ITEMS = 32;
    MAX_TRACE_STATE_LEN = 512;
    LIST_MEMBERS_SEPARATOR = ",";
    LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    TraceState = /** @class */
    function() {
      function TraceState2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      TraceState2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceState2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceState2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceState2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceState2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceState2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceState2.prototype._clone = function() {
        var traceState = new TraceState2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceState2;
    }();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js
function parseTraceParent(traceParent) {
  var match2 = TRACE_PARENT_REGEX.exec(traceParent);
  if (!match2)
    return null;
  if (match2[1] === "00" && match2[5])
    return null;
  return {
    traceId: match2[2],
    spanId: match2[3],
    traceFlags: parseInt(match2[4], 16)
  };
}
var TRACE_PARENT_HEADER, TRACE_STATE_HEADER, VERSION2, VERSION_PART, TRACE_ID_PART, PARENT_ID_PART, FLAGS_PART, TRACE_PARENT_REGEX, W3CTraceContextPropagator;
var init_W3CTraceContextPropagator = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    init_suppress_tracing();
    init_TraceState();
    TRACE_PARENT_HEADER = "traceparent";
    TRACE_STATE_HEADER = "tracestate";
    VERSION2 = "00";
    VERSION_PART = "(?!ff)[\\da-f]{2}";
    TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    FLAGS_PART = "[\\da-f]{2}";
    TRACE_PARENT_REGEX = new RegExp("^\\s?(" + VERSION_PART + ")-(" + TRACE_ID_PART + ")-(" + PARENT_ID_PART + ")-(" + FLAGS_PART + ")(-.*)?\\s?$");
    W3CTraceContextPropagator = /** @class */
    function() {
      function W3CTraceContextPropagator2() {
      }
      W3CTraceContextPropagator2.prototype.inject = function(context2, carrier, setter) {
        var spanContext = trace.getSpanContext(context2);
        if (!spanContext || isTracingSuppressed(context2) || !isSpanContextValid(spanContext))
          return;
        var traceParent = VERSION2 + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);
        setter.set(carrier, TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      };
      W3CTraceContextPropagator2.prototype.extract = function(context2, carrier, getter) {
        var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context2;
        var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context2;
        var spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context2;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
        if (traceStateHeader) {
          var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState(typeof state === "string" ? state : void 0);
        }
        return trace.setSpanContext(context2, spanContext);
      };
      W3CTraceContextPropagator2.prototype.fields = function() {
        return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];
      };
      return W3CTraceContextPropagator2;
    }();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/trace/IdGenerator.js
var init_IdGenerator = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/trace/IdGenerator.js"() {
    "use strict";
    init_esm_shims();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/trace/rpc-metadata.js
function setRPCMetadata(context2, meta) {
  return context2.setValue(RPC_METADATA_KEY, meta);
}
function deleteRPCMetadata(context2) {
  return context2.deleteValue(RPC_METADATA_KEY);
}
function getRPCMetadata(context2) {
  return context2.getValue(RPC_METADATA_KEY);
}
var RPC_METADATA_KEY, RPCType;
var init_rpc_metadata = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/trace/rpc-metadata.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    RPC_METADATA_KEY = createContextKey("OpenTelemetry SDK Context Key RPC_METADATA");
    (function(RPCType2) {
      RPCType2["HTTP"] = "http";
    })(RPCType || (RPCType = {}));
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOffSampler.js
var AlwaysOffSampler;
var init_AlwaysOffSampler = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOffSampler.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    AlwaysOffSampler = /** @class */
    function() {
      function AlwaysOffSampler2() {
      }
      AlwaysOffSampler2.prototype.shouldSample = function() {
        return {
          decision: SamplingDecision.NOT_RECORD
        };
      };
      AlwaysOffSampler2.prototype.toString = function() {
        return "AlwaysOffSampler";
      };
      return AlwaysOffSampler2;
    }();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOnSampler.js
var AlwaysOnSampler;
var init_AlwaysOnSampler = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOnSampler.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    AlwaysOnSampler = /** @class */
    function() {
      function AlwaysOnSampler2() {
      }
      AlwaysOnSampler2.prototype.shouldSample = function() {
        return {
          decision: SamplingDecision.RECORD_AND_SAMPLED
        };
      };
      AlwaysOnSampler2.prototype.toString = function() {
        return "AlwaysOnSampler";
      };
      return AlwaysOnSampler2;
    }();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/trace/sampler/ParentBasedSampler.js
var ParentBasedSampler;
var init_ParentBasedSampler = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/trace/sampler/ParentBasedSampler.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    init_global_error_handler();
    init_AlwaysOffSampler();
    init_AlwaysOnSampler();
    ParentBasedSampler = /** @class */
    function() {
      function ParentBasedSampler2(config) {
        var _a2, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
          globalErrorHandler(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a2 = config.remoteParentSampled) !== null && _a2 !== void 0 ? _a2 : new AlwaysOnSampler();
        this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler();
        this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler();
        this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler();
      }
      ParentBasedSampler2.prototype.shouldSample = function(context2, traceId, spanName, spanKind, attributes, links) {
        var parentContext = trace.getSpanContext(context2);
        if (!parentContext || !isSpanContextValid(parentContext)) {
          return this._root.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
      };
      ParentBasedSampler2.prototype.toString = function() {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
      };
      return ParentBasedSampler2;
    }();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/trace/sampler/TraceIdRatioBasedSampler.js
var TraceIdRatioBasedSampler;
var init_TraceIdRatioBasedSampler = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/trace/sampler/TraceIdRatioBasedSampler.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    TraceIdRatioBasedSampler = /** @class */
    function() {
      function TraceIdRatioBasedSampler2(_ratio) {
        if (_ratio === void 0) {
          _ratio = 0;
        }
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      TraceIdRatioBasedSampler2.prototype.shouldSample = function(context2, traceId) {
        return {
          decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD
        };
      };
      TraceIdRatioBasedSampler2.prototype.toString = function() {
        return "TraceIdRatioBased{" + this._ratio + "}";
      };
      TraceIdRatioBasedSampler2.prototype._normalize = function(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      };
      TraceIdRatioBasedSampler2.prototype._accumulate = function(traceId) {
        var accumulation = 0;
        for (var i = 0; i < traceId.length / 8; i++) {
          var pos = i * 8;
          var part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      };
      return TraceIdRatioBasedSampler2;
    }();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/utils/lodash.merge.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  var unmasked = false;
  try {
    value[symToStringTag] = void 0;
    unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var objectTag, nullTag, undefinedTag, funcProto, funcToString, objectCtorString, getPrototype, objectProto, hasOwnProperty, symToStringTag, nativeObjectToString;
var init_lodash_merge = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/utils/lodash.merge.js"() {
    "use strict";
    init_esm_shims();
    objectTag = "[object Object]";
    nullTag = "[object Null]";
    undefinedTag = "[object Undefined]";
    funcProto = Function.prototype;
    funcToString = funcProto.toString;
    objectCtorString = funcToString.call(Object);
    getPrototype = overArg(Object.getPrototypeOf, Object);
    objectProto = Object.prototype;
    hasOwnProperty = objectProto.hasOwnProperty;
    symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    nativeObjectToString = objectProto.toString;
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/utils/merge.js
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var result = args.shift();
  var objects = /* @__PURE__ */ new WeakMap();
  while (args.length > 0) {
    result = mergeTwoObjects(result, args.shift(), 0, objects);
  }
  return result;
}
function takeValue(value) {
  if (isArray(value)) {
    return value.slice();
  }
  return value;
}
function mergeTwoObjects(one, two, level, objects) {
  if (level === void 0) {
    level = 0;
  }
  var result;
  if (level > MAX_LEVEL) {
    return void 0;
  }
  level++;
  if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
    result = takeValue(two);
  } else if (isArray(one)) {
    result = one.slice();
    if (isArray(two)) {
      for (var i = 0, j = two.length; i < j; i++) {
        result.push(takeValue(two[i]));
      }
    } else if (isObject(two)) {
      var keys = Object.keys(two);
      for (var i = 0, j = keys.length; i < j; i++) {
        var key = keys[i];
        result[key] = takeValue(two[key]);
      }
    }
  } else if (isObject(one)) {
    if (isObject(two)) {
      if (!shouldMerge(one, two)) {
        return two;
      }
      result = Object.assign({}, one);
      var keys = Object.keys(two);
      for (var i = 0, j = keys.length; i < j; i++) {
        var key = keys[i];
        var twoValue = two[key];
        if (isPrimitive(twoValue)) {
          if (typeof twoValue === "undefined") {
            delete result[key];
          } else {
            result[key] = twoValue;
          }
        } else {
          var obj1 = result[key];
          var obj2 = twoValue;
          if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
            delete result[key];
          } else {
            if (isObject(obj1) && isObject(obj2)) {
              var arr1 = objects.get(obj1) || [];
              var arr2 = objects.get(obj2) || [];
              arr1.push({ obj: one, key });
              arr2.push({ obj: two, key });
              objects.set(obj1, arr1);
              objects.set(obj2, arr2);
            }
            result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
          }
        }
      }
    } else {
      result = two;
    }
  }
  return result;
}
function wasObjectReferenced(obj, key, objects) {
  var arr = objects.get(obj[key]) || [];
  for (var i = 0, j = arr.length; i < j; i++) {
    var info = arr[i];
    if (info.key === key && info.obj === obj) {
      return true;
    }
  }
  return false;
}
function isArray(value) {
  return Array.isArray(value);
}
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
}
function isPrimitive(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
}
function shouldMerge(one, two) {
  if (!isPlainObject(one) || !isPlainObject(two)) {
    return false;
  }
  return true;
}
var MAX_LEVEL;
var init_merge = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/utils/merge.js"() {
    "use strict";
    init_esm_shims();
    init_lodash_merge();
    MAX_LEVEL = 20;
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/utils/timeout.js
function callWithTimeout(promise, timeout) {
  var timeoutHandle;
  var timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
    timeoutHandle = setTimeout(function timeoutHandler() {
      reject(new TimeoutError("Operation timed out."));
    }, timeout);
  });
  return Promise.race([promise, timeoutPromise]).then(function(result) {
    clearTimeout(timeoutHandle);
    return result;
  }, function(reason) {
    clearTimeout(timeoutHandle);
    throw reason;
  });
}
var __extends, TimeoutError;
var init_timeout = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/utils/timeout.js"() {
    "use strict";
    init_esm_shims();
    __extends = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    TimeoutError = /** @class */
    function(_super) {
      __extends(TimeoutError2, _super);
      function TimeoutError2(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, TimeoutError2.prototype);
        return _this;
      }
      return TimeoutError2;
    }(Error);
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/utils/url.js
function urlMatches(url, urlToMatch) {
  if (typeof urlToMatch === "string") {
    return url === urlToMatch;
  } else {
    return !!url.match(urlToMatch);
  }
}
function isUrlIgnored(url, ignoredUrls) {
  var e_1, _a2;
  if (!ignoredUrls) {
    return false;
  }
  try {
    for (var ignoredUrls_1 = __values3(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()) {
      var ignoreUrl = ignoredUrls_1_1.value;
      if (urlMatches(url, ignoreUrl)) {
        return true;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a2 = ignoredUrls_1.return)) _a2.call(ignoredUrls_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return false;
}
var __values3;
var init_url = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/utils/url.js"() {
    "use strict";
    init_esm_shims();
    __values3 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/utils/wrap.js
function isWrapped(func) {
  return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
}
var init_wrap = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/utils/wrap.js"() {
    "use strict";
    init_esm_shims();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/utils/promise.js
var Deferred;
var init_promise = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/utils/promise.js"() {
    "use strict";
    init_esm_shims();
    Deferred = /** @class */
    function() {
      function Deferred2() {
        var _this = this;
        this._promise = new Promise(function(resolve, reject) {
          _this._resolve = resolve;
          _this._reject = reject;
        });
      }
      Object.defineProperty(Deferred2.prototype, "promise", {
        get: function() {
          return this._promise;
        },
        enumerable: false,
        configurable: true
      });
      Deferred2.prototype.resolve = function(val) {
        this._resolve(val);
      };
      Deferred2.prototype.reject = function(err) {
        this._reject(err);
      };
      return Deferred2;
    }();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/utils/callback.js
var __read3, __spreadArray, BindOnceFuture;
var init_callback = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/utils/callback.js"() {
    "use strict";
    init_esm_shims();
    init_promise();
    __read3 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    BindOnceFuture = /** @class */
    function() {
      function BindOnceFuture2(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new Deferred();
      }
      Object.defineProperty(BindOnceFuture2.prototype, "isCalled", {
        get: function() {
          return this._isCalled;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BindOnceFuture2.prototype, "promise", {
        get: function() {
          return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
      });
      BindOnceFuture2.prototype.call = function() {
        var _a2;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve((_a2 = this._callback).call.apply(_a2, __spreadArray([this._that], __read3(args), false))).then(function(val) {
              return _this._deferred.resolve(val);
            }, function(err) {
              return _this._deferred.reject(err);
            });
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      };
      return BindOnceFuture2;
    }();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/internal/exporter.js
function _export(exporter, arg) {
  return new Promise(function(resolve) {
    context.with(suppressTracing2(context.active()), function() {
      exporter.export(arg, function(result) {
        resolve(result);
      });
    });
  });
}
var init_exporter = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/internal/exporter.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    init_suppress_tracing();
  }
});

// ../../node_modules/@opentelemetry/core/build/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  AlwaysOffSampler: () => AlwaysOffSampler,
  AlwaysOnSampler: () => AlwaysOnSampler,
  AnchoredClock: () => AnchoredClock,
  BindOnceFuture: () => BindOnceFuture,
  CompositePropagator: () => CompositePropagator,
  DEFAULT_ATTRIBUTE_COUNT_LIMIT: () => DEFAULT_ATTRIBUTE_COUNT_LIMIT,
  DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT: () => DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
  DEFAULT_ENVIRONMENT: () => DEFAULT_ENVIRONMENT,
  DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: () => DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
  DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: () => DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
  ExportResultCode: () => ExportResultCode,
  ParentBasedSampler: () => ParentBasedSampler,
  RPCType: () => RPCType,
  RandomIdGenerator: () => RandomIdGenerator,
  SDK_INFO: () => SDK_INFO,
  TRACE_PARENT_HEADER: () => TRACE_PARENT_HEADER,
  TRACE_STATE_HEADER: () => TRACE_STATE_HEADER,
  TimeoutError: () => TimeoutError,
  TraceIdRatioBasedSampler: () => TraceIdRatioBasedSampler,
  TraceState: () => TraceState,
  TracesSamplerValues: () => TracesSamplerValues,
  VERSION: () => VERSION,
  W3CBaggagePropagator: () => W3CBaggagePropagator,
  W3CTraceContextPropagator: () => W3CTraceContextPropagator,
  _globalThis: () => _globalThis,
  addHrTimes: () => addHrTimes,
  baggageUtils: () => utils_exports,
  callWithTimeout: () => callWithTimeout,
  deleteRPCMetadata: () => deleteRPCMetadata,
  getEnv: () => getEnv,
  getEnvWithoutDefaults: () => getEnvWithoutDefaults,
  getRPCMetadata: () => getRPCMetadata,
  getTimeOrigin: () => getTimeOrigin,
  globalErrorHandler: () => globalErrorHandler,
  hexToBase64: () => hexToBase64,
  hexToBinary: () => hexToBinary,
  hrTime: () => hrTime,
  hrTimeDuration: () => hrTimeDuration,
  hrTimeToMicroseconds: () => hrTimeToMicroseconds,
  hrTimeToMilliseconds: () => hrTimeToMilliseconds,
  hrTimeToNanoseconds: () => hrTimeToNanoseconds,
  hrTimeToTimeStamp: () => hrTimeToTimeStamp,
  internal: () => internal,
  isAttributeKey: () => isAttributeKey,
  isAttributeValue: () => isAttributeValue,
  isTimeInput: () => isTimeInput,
  isTimeInputHrTime: () => isTimeInputHrTime,
  isTracingSuppressed: () => isTracingSuppressed,
  isUrlIgnored: () => isUrlIgnored,
  isWrapped: () => isWrapped,
  loggingErrorHandler: () => loggingErrorHandler,
  merge: () => merge,
  millisToHrTime: () => millisToHrTime,
  otperformance: () => otperformance,
  parseEnvironment: () => parseEnvironment,
  parseTraceParent: () => parseTraceParent,
  sanitizeAttributes: () => sanitizeAttributes,
  setGlobalErrorHandler: () => setGlobalErrorHandler,
  setRPCMetadata: () => setRPCMetadata,
  suppressTracing: () => suppressTracing2,
  timeInputToHrTime: () => timeInputToHrTime,
  unrefTimer: () => unrefTimer,
  unsuppressTracing: () => unsuppressTracing,
  urlMatches: () => urlMatches
});
var internal;
var init_esm3 = __esm({
  "../../node_modules/@opentelemetry/core/build/esm/index.js"() {
    "use strict";
    init_esm_shims();
    init_W3CBaggagePropagator();
    init_anchored_clock();
    init_attributes();
    init_global_error_handler();
    init_logging_error_handler();
    init_time();
    init_types();
    init_hex_to_binary();
    init_ExportResult();
    init_utils();
    init_platform();
    init_composite();
    init_W3CTraceContextPropagator();
    init_IdGenerator();
    init_rpc_metadata();
    init_AlwaysOffSampler();
    init_AlwaysOnSampler();
    init_ParentBasedSampler();
    init_TraceIdRatioBasedSampler();
    init_suppress_tracing();
    init_TraceState();
    init_environment();
    init_merge();
    init_sampling();
    init_timeout();
    init_url();
    init_wrap();
    init_callback();
    init_version();
    init_exporter();
    internal = {
      _export
    };
  }
});

// ../../node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "../../node_modules/semver/internal/constants.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// ../../node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "../../node_modules/semver/internal/debug.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var debug3 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug3;
  }
});

// ../../node_modules/semver/internal/re.js
var require_re = __commonJS({
  "../../node_modules/semver/internal/re.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug3 = require_debug();
    exports = module2.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug3(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// ../../node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "../../node_modules/semver/internal/parse-options.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// ../../node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "../../node_modules/semver/internal/identifiers.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// ../../node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "../../node_modules/semver/classes/semver.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var debug3 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, safeSrc: src, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug3("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug3("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug3("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug3("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release2, identifier, identifierBase) {
        if (release2.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`);
            const match2 = `-${identifier}`.match(r);
            if (!match2 || match2[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release2) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release2}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// ../../node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "../../node_modules/semver/functions/parse.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// ../../node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "../../node_modules/semver/functions/valid.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// ../../node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "../../node_modules/semver/functions/clean.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// ../../node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "../../node_modules/semver/functions/inc.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SemVer = require_semver();
    var inc = (version, release2, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release2, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// ../../node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "../../node_modules/semver/functions/diff.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// ../../node_modules/semver/functions/major.js
var require_major = __commonJS({
  "../../node_modules/semver/functions/major.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// ../../node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "../../node_modules/semver/functions/minor.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// ../../node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "../../node_modules/semver/functions/patch.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// ../../node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "../../node_modules/semver/functions/prerelease.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// ../../node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "../../node_modules/semver/functions/compare.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// ../../node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "../../node_modules/semver/functions/rcompare.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// ../../node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "../../node_modules/semver/functions/compare-loose.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// ../../node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "../../node_modules/semver/functions/compare-build.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// ../../node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "../../node_modules/semver/functions/sort.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// ../../node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "../../node_modules/semver/functions/rsort.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// ../../node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "../../node_modules/semver/functions/gt.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// ../../node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "../../node_modules/semver/functions/lt.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// ../../node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "../../node_modules/semver/functions/eq.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// ../../node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "../../node_modules/semver/functions/neq.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// ../../node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "../../node_modules/semver/functions/gte.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// ../../node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "../../node_modules/semver/functions/lte.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// ../../node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "../../node_modules/semver/functions/cmp.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// ../../node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "../../node_modules/semver/functions/coerce.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match2 = null;
      if (!options.rtl) {
        match2 = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match2 || match2.index + match2[0].length !== version.length)) {
          if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
            match2 = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match2 === null) {
        return null;
      }
      const major = match2[2];
      const minor = match2[3] || "0";
      const patch = match2[4] || "0";
      const prerelease = options.includePrerelease && match2[5] ? `-${match2[5]}` : "";
      const build = options.includePrerelease && match2[6] ? `+${match2[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// ../../node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "../../node_modules/semver/internal/lrucache.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// ../../node_modules/semver/classes/range.js
var require_range = __commonJS({
  "../../node_modules/semver/classes/range.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug3("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug3("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug3("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug3("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug3("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug3("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug3 = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug3("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug3("caret", comp);
      comp = replaceTildes(comp, options);
      debug3("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug3("xrange", comp);
      comp = replaceStars(comp, options);
      debug3("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug3("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug3("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug3("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug3("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug3("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z2} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z2} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug3("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug3("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug3("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug3("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug3("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug3("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug3("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug3("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug3(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "../../node_modules/semver/classes/comparator.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug3("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug3("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug3("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug3 = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// ../../node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "../../node_modules/semver/functions/satisfies.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var Range = require_range();
    var satisfies2 = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies2;
  }
});

// ../../node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "../../node_modules/semver/ranges/to-comparators.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// ../../node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "../../node_modules/semver/ranges/max-satisfying.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// ../../node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "../../node_modules/semver/ranges/min-satisfying.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// ../../node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "../../node_modules/semver/ranges/min-version.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// ../../node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "../../node_modules/semver/ranges/valid.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// ../../node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "../../node_modules/semver/ranges/outside.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies2 = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies2(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// ../../node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "../../node_modules/semver/ranges/gtr.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// ../../node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "../../node_modules/semver/ranges/ltr.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// ../../node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "../../node_modules/semver/ranges/intersects.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// ../../node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "../../node_modules/semver/ranges/simplify.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var satisfies2 = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies2(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// ../../node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "../../node_modules/semver/ranges/subset.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies2 = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies2(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies2(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies2(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies2(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies2(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// ../../node_modules/semver/index.js
var require_semver2 = __commonJS({
  "../../node_modules/semver/index.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies2 = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies: satisfies2,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// ../../node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js
var require_AttributeNames = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeNames = void 0;
    var AttributeNames;
    (function(AttributeNames2) {
      AttributeNames2["HTTP_ERROR_NAME"] = "http.error_name";
      AttributeNames2["HTTP_ERROR_MESSAGE"] = "http.error_message";
      AttributeNames2["HTTP_STATUS_TEXT"] = "http.status_text";
    })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-http/build/src/utils.js
var require_utils = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-http/build/src/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.headerCapture = exports.getIncomingRequestMetricAttributesOnResponse = exports.getIncomingRequestAttributesOnResponse = exports.getIncomingRequestMetricAttributes = exports.getIncomingRequestAttributes = exports.getOutgoingRequestMetricAttributesOnResponse = exports.getOutgoingRequestAttributesOnResponse = exports.setAttributesFromHttpKind = exports.getOutgoingRequestMetricAttributes = exports.getOutgoingRequestAttributes = exports.extractHostnameAndPort = exports.isValidOptionsType = exports.getRequestInfo = exports.isCompressed = exports.setResponseContentLengthAttribute = exports.setRequestContentLengthAttribute = exports.setSpanWithError = exports.isIgnored = exports.satisfiesPattern = exports.parseResponseStatus = exports.getAbsoluteUrl = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var core_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var url = __require("url");
    var AttributeNames_1 = require_AttributeNames();
    var getAbsoluteUrl2 = (requestUrl, headers, fallbackProtocol = "http:") => {
      const reqUrlObject = requestUrl || {};
      const protocol = reqUrlObject.protocol || fallbackProtocol;
      const port = (reqUrlObject.port || "").toString();
      const path3 = reqUrlObject.path || "/";
      let host = reqUrlObject.host || reqUrlObject.hostname || headers.host || "localhost";
      if (host.indexOf(":") === -1 && port && port !== "80" && port !== "443") {
        host += `:${port}`;
      }
      return `${protocol}//${host}${path3}`;
    };
    exports.getAbsoluteUrl = getAbsoluteUrl2;
    var parseResponseStatus = (kind, statusCode) => {
      const upperBound = kind === api_1.SpanKind.CLIENT ? 400 : 500;
      if (statusCode && statusCode >= 100 && statusCode < upperBound) {
        return api_1.SpanStatusCode.UNSET;
      }
      return api_1.SpanStatusCode.ERROR;
    };
    exports.parseResponseStatus = parseResponseStatus;
    var satisfiesPattern = (constant, pattern) => {
      if (typeof pattern === "string") {
        return pattern === constant;
      } else if (pattern instanceof RegExp) {
        return pattern.test(constant);
      } else if (typeof pattern === "function") {
        return pattern(constant);
      } else {
        throw new TypeError("Pattern is in unsupported datatype");
      }
    };
    exports.satisfiesPattern = satisfiesPattern;
    var isIgnored = (constant, list, onException) => {
      if (!list) {
        return false;
      }
      try {
        for (const pattern of list) {
          if ((0, exports.satisfiesPattern)(constant, pattern)) {
            return true;
          }
        }
      } catch (e) {
        if (onException) {
          onException(e);
        }
      }
      return false;
    };
    exports.isIgnored = isIgnored;
    var setSpanWithError = (span, error) => {
      const message = error.message;
      span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_NAME, error.name);
      span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_MESSAGE, message);
      span.setStatus({ code: api_1.SpanStatusCode.ERROR, message });
      span.recordException(error);
    };
    exports.setSpanWithError = setSpanWithError;
    var setRequestContentLengthAttribute = (request, attributes) => {
      const length = getContentLength(request.headers);
      if (length === null)
        return;
      if ((0, exports.isCompressed)(request.headers)) {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH] = length;
      } else {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED] = length;
      }
    };
    exports.setRequestContentLengthAttribute = setRequestContentLengthAttribute;
    var setResponseContentLengthAttribute = (response, attributes) => {
      const length = getContentLength(response.headers);
      if (length === null)
        return;
      if ((0, exports.isCompressed)(response.headers)) {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH] = length;
      } else {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED] = length;
      }
    };
    exports.setResponseContentLengthAttribute = setResponseContentLengthAttribute;
    function getContentLength(headers) {
      const contentLengthHeader = headers["content-length"];
      if (contentLengthHeader === void 0)
        return null;
      const contentLength = parseInt(contentLengthHeader, 10);
      if (isNaN(contentLength))
        return null;
      return contentLength;
    }
    var isCompressed = (headers) => {
      const encoding = headers["content-encoding"];
      return !!encoding && encoding !== "identity";
    };
    exports.isCompressed = isCompressed;
    var getRequestInfo = (options, extraOptions) => {
      let pathname = "/";
      let origin = "";
      let optionsParsed;
      if (typeof options === "string") {
        optionsParsed = url.parse(options);
        pathname = optionsParsed.pathname || "/";
        origin = `${optionsParsed.protocol || "http:"}//${optionsParsed.host}`;
        if (extraOptions !== void 0) {
          Object.assign(optionsParsed, extraOptions);
        }
      } else if (options instanceof url.URL) {
        optionsParsed = {
          protocol: options.protocol,
          hostname: typeof options.hostname === "string" && options.hostname.startsWith("[") ? options.hostname.slice(1, -1) : options.hostname,
          path: `${options.pathname || ""}${options.search || ""}`
        };
        if (options.port !== "") {
          optionsParsed.port = Number(options.port);
        }
        if (options.username || options.password) {
          optionsParsed.auth = `${options.username}:${options.password}`;
        }
        pathname = options.pathname;
        origin = options.origin;
        if (extraOptions !== void 0) {
          Object.assign(optionsParsed, extraOptions);
        }
      } else {
        optionsParsed = Object.assign({ protocol: options.host ? "http:" : void 0 }, options);
        pathname = options.pathname;
        if (!pathname && optionsParsed.path) {
          pathname = url.parse(optionsParsed.path).pathname || "/";
        }
        const hostname2 = optionsParsed.host || (optionsParsed.port != null ? `${optionsParsed.hostname}${optionsParsed.port}` : optionsParsed.hostname);
        origin = `${optionsParsed.protocol || "http:"}//${hostname2}`;
      }
      const method = optionsParsed.method ? optionsParsed.method.toUpperCase() : "GET";
      return { origin, pathname, method, optionsParsed };
    };
    exports.getRequestInfo = getRequestInfo;
    var isValidOptionsType = (options) => {
      if (!options) {
        return false;
      }
      const type = typeof options;
      return type === "string" || type === "object" && !Array.isArray(options);
    };
    exports.isValidOptionsType = isValidOptionsType;
    var extractHostnameAndPort = (requestOptions) => {
      var _a2;
      if (requestOptions.hostname && requestOptions.port) {
        return { hostname: requestOptions.hostname, port: requestOptions.port };
      }
      const matches = ((_a2 = requestOptions.host) === null || _a2 === void 0 ? void 0 : _a2.match(/^([^:/ ]+)(:\d{1,5})?/)) || null;
      const hostname2 = requestOptions.hostname || (matches === null ? "localhost" : matches[1]);
      let port = requestOptions.port;
      if (!port) {
        if (matches && matches[2]) {
          port = matches[2].substring(1);
        } else {
          port = requestOptions.protocol === "https:" ? "443" : "80";
        }
      }
      return { hostname: hostname2, port };
    };
    exports.extractHostnameAndPort = extractHostnameAndPort;
    var getOutgoingRequestAttributes = (requestOptions, options) => {
      var _a2;
      const hostname2 = options.hostname;
      const port = options.port;
      const requestMethod = requestOptions.method;
      const method = requestMethod ? requestMethod.toUpperCase() : "GET";
      const headers = requestOptions.headers || {};
      const userAgent = headers["user-agent"];
      const attributes = {
        [semantic_conventions_1.SEMATTRS_HTTP_URL]: (0, exports.getAbsoluteUrl)(requestOptions, headers, `${options.component}:`),
        [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,
        [semantic_conventions_1.SEMATTRS_HTTP_TARGET]: requestOptions.path || "/",
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: hostname2,
        [semantic_conventions_1.SEMATTRS_HTTP_HOST]: (_a2 = headers.host) !== null && _a2 !== void 0 ? _a2 : `${hostname2}:${port}`
      };
      if (userAgent !== void 0) {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;
      }
      return Object.assign(attributes, options.hookAttributes);
    };
    exports.getOutgoingRequestAttributes = getOutgoingRequestAttributes;
    var getOutgoingRequestMetricAttributes = (spanAttributes) => {
      const metricAttributes = {};
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];
      metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME] = spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME];
      return metricAttributes;
    };
    exports.getOutgoingRequestMetricAttributes = getOutgoingRequestMetricAttributes;
    var setAttributesFromHttpKind = (kind, attributes) => {
      if (kind) {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = kind;
        if (kind.toUpperCase() !== "QUIC") {
          attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_TCP;
        } else {
          attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_UDP;
        }
      }
    };
    exports.setAttributesFromHttpKind = setAttributesFromHttpKind;
    var getOutgoingRequestAttributesOnResponse = (response) => {
      const { statusCode, statusMessage, httpVersion, socket } = response;
      const attributes = {};
      if (socket) {
        const { remoteAddress, remotePort } = socket;
        attributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;
        attributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;
      }
      (0, exports.setResponseContentLengthAttribute)(response, attributes);
      if (statusCode) {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;
        attributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || "").toUpperCase();
      }
      (0, exports.setAttributesFromHttpKind)(httpVersion, attributes);
      return attributes;
    };
    exports.getOutgoingRequestAttributesOnResponse = getOutgoingRequestAttributesOnResponse;
    var getOutgoingRequestMetricAttributesOnResponse = (spanAttributes) => {
      const metricAttributes = {};
      metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT];
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];
      return metricAttributes;
    };
    exports.getOutgoingRequestMetricAttributesOnResponse = getOutgoingRequestMetricAttributesOnResponse;
    var getIncomingRequestAttributes = (request, options) => {
      const headers = request.headers;
      const userAgent = headers["user-agent"];
      const ips = headers["x-forwarded-for"];
      const method = request.method || "GET";
      const httpVersion = request.httpVersion;
      const requestUrl = request.url ? url.parse(request.url) : null;
      const host = (requestUrl === null || requestUrl === void 0 ? void 0 : requestUrl.host) || headers.host;
      const hostname2 = (requestUrl === null || requestUrl === void 0 ? void 0 : requestUrl.hostname) || (host === null || host === void 0 ? void 0 : host.replace(/^(.*)(:[0-9]{1,5})/, "$1")) || "localhost";
      const serverName = options.serverName;
      const attributes = {
        [semantic_conventions_1.SEMATTRS_HTTP_URL]: (0, exports.getAbsoluteUrl)(requestUrl, headers, `${options.component}:`),
        [semantic_conventions_1.SEMATTRS_HTTP_HOST]: host,
        [semantic_conventions_1.SEMATTRS_NET_HOST_NAME]: hostname2,
        [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,
        [semantic_conventions_1.SEMATTRS_HTTP_SCHEME]: options.component
      };
      if (typeof ips === "string") {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_CLIENT_IP] = ips.split(",")[0];
      }
      if (typeof serverName === "string") {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_SERVER_NAME] = serverName;
      }
      if (requestUrl) {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_TARGET] = requestUrl.path || "/";
      }
      if (userAgent !== void 0) {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;
      }
      (0, exports.setRequestContentLengthAttribute)(request, attributes);
      (0, exports.setAttributesFromHttpKind)(httpVersion, attributes);
      return Object.assign(attributes, options.hookAttributes);
    };
    exports.getIncomingRequestAttributes = getIncomingRequestAttributes;
    var getIncomingRequestMetricAttributes = (spanAttributes) => {
      const metricAttributes = {};
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME];
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];
      metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME] = spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME];
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];
      return metricAttributes;
    };
    exports.getIncomingRequestMetricAttributes = getIncomingRequestMetricAttributes;
    var getIncomingRequestAttributesOnResponse = (request, response) => {
      const { socket } = request;
      const { statusCode, statusMessage } = response;
      const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
      const attributes = {};
      if (socket) {
        const { localAddress, localPort, remoteAddress, remotePort } = socket;
        attributes[semantic_conventions_1.SEMATTRS_NET_HOST_IP] = localAddress;
        attributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] = localPort;
        attributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;
        attributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;
      }
      attributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;
      attributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || "").toUpperCase();
      if ((rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP && rpcMetadata.route !== void 0) {
        attributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = rpcMetadata.route;
      }
      return attributes;
    };
    exports.getIncomingRequestAttributesOnResponse = getIncomingRequestAttributesOnResponse;
    var getIncomingRequestMetricAttributesOnResponse = (spanAttributes) => {
      const metricAttributes = {};
      metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];
      metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] = spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT];
      if (spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] !== void 0) {
        metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];
      }
      return metricAttributes;
    };
    exports.getIncomingRequestMetricAttributesOnResponse = getIncomingRequestMetricAttributesOnResponse;
    function headerCapture(type, headers) {
      const normalizedHeaders = /* @__PURE__ */ new Map();
      for (let i = 0, len = headers.length; i < len; i++) {
        const capturedHeader = headers[i].toLowerCase();
        normalizedHeaders.set(capturedHeader, capturedHeader.replace(/-/g, "_"));
      }
      return (span, getHeader) => {
        for (const capturedHeader of normalizedHeaders.keys()) {
          const value = getHeader(capturedHeader);
          if (value === void 0) {
            continue;
          }
          const normalizedHeader = normalizedHeaders.get(capturedHeader);
          const key = `http.${type}.header.${normalizedHeader}`;
          if (typeof value === "string") {
            span.setAttribute(key, [value]);
          } else if (Array.isArray(value)) {
            span.setAttribute(key, value);
          } else {
            span.setAttribute(key, [value]);
          }
        }
      };
    }
    exports.headerCapture = headerCapture;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-http/build/src/version.js
var require_version = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-http/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "0.52.1";
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/esm/types/Logger.js
var init_Logger = __esm({
  "../../node_modules/@opentelemetry/api-logs/build/esm/types/Logger.js"() {
    "use strict";
    init_esm_shims();
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/esm/types/LoggerProvider.js
var init_LoggerProvider = __esm({
  "../../node_modules/@opentelemetry/api-logs/build/esm/types/LoggerProvider.js"() {
    "use strict";
    init_esm_shims();
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/esm/types/LogRecord.js
var SeverityNumber;
var init_LogRecord = __esm({
  "../../node_modules/@opentelemetry/api-logs/build/esm/types/LogRecord.js"() {
    "use strict";
    init_esm_shims();
    (function(SeverityNumber2) {
      SeverityNumber2[SeverityNumber2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
      SeverityNumber2[SeverityNumber2["TRACE"] = 1] = "TRACE";
      SeverityNumber2[SeverityNumber2["TRACE2"] = 2] = "TRACE2";
      SeverityNumber2[SeverityNumber2["TRACE3"] = 3] = "TRACE3";
      SeverityNumber2[SeverityNumber2["TRACE4"] = 4] = "TRACE4";
      SeverityNumber2[SeverityNumber2["DEBUG"] = 5] = "DEBUG";
      SeverityNumber2[SeverityNumber2["DEBUG2"] = 6] = "DEBUG2";
      SeverityNumber2[SeverityNumber2["DEBUG3"] = 7] = "DEBUG3";
      SeverityNumber2[SeverityNumber2["DEBUG4"] = 8] = "DEBUG4";
      SeverityNumber2[SeverityNumber2["INFO"] = 9] = "INFO";
      SeverityNumber2[SeverityNumber2["INFO2"] = 10] = "INFO2";
      SeverityNumber2[SeverityNumber2["INFO3"] = 11] = "INFO3";
      SeverityNumber2[SeverityNumber2["INFO4"] = 12] = "INFO4";
      SeverityNumber2[SeverityNumber2["WARN"] = 13] = "WARN";
      SeverityNumber2[SeverityNumber2["WARN2"] = 14] = "WARN2";
      SeverityNumber2[SeverityNumber2["WARN3"] = 15] = "WARN3";
      SeverityNumber2[SeverityNumber2["WARN4"] = 16] = "WARN4";
      SeverityNumber2[SeverityNumber2["ERROR"] = 17] = "ERROR";
      SeverityNumber2[SeverityNumber2["ERROR2"] = 18] = "ERROR2";
      SeverityNumber2[SeverityNumber2["ERROR3"] = 19] = "ERROR3";
      SeverityNumber2[SeverityNumber2["ERROR4"] = 20] = "ERROR4";
      SeverityNumber2[SeverityNumber2["FATAL"] = 21] = "FATAL";
      SeverityNumber2[SeverityNumber2["FATAL2"] = 22] = "FATAL2";
      SeverityNumber2[SeverityNumber2["FATAL3"] = 23] = "FATAL3";
      SeverityNumber2[SeverityNumber2["FATAL4"] = 24] = "FATAL4";
    })(SeverityNumber || (SeverityNumber = {}));
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/esm/types/LoggerOptions.js
var init_LoggerOptions = __esm({
  "../../node_modules/@opentelemetry/api-logs/build/esm/types/LoggerOptions.js"() {
    "use strict";
    init_esm_shims();
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/esm/types/AnyValue.js
var init_AnyValue = __esm({
  "../../node_modules/@opentelemetry/api-logs/build/esm/types/AnyValue.js"() {
    "use strict";
    init_esm_shims();
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/esm/NoopLogger.js
var NoopLogger, NOOP_LOGGER;
var init_NoopLogger = __esm({
  "../../node_modules/@opentelemetry/api-logs/build/esm/NoopLogger.js"() {
    "use strict";
    init_esm_shims();
    NoopLogger = /** @class */
    function() {
      function NoopLogger2() {
      }
      NoopLogger2.prototype.emit = function(_logRecord) {
      };
      return NoopLogger2;
    }();
    NOOP_LOGGER = new NoopLogger();
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/esm/NoopLoggerProvider.js
var NoopLoggerProvider, NOOP_LOGGER_PROVIDER;
var init_NoopLoggerProvider = __esm({
  "../../node_modules/@opentelemetry/api-logs/build/esm/NoopLoggerProvider.js"() {
    "use strict";
    init_esm_shims();
    init_NoopLogger();
    NoopLoggerProvider = /** @class */
    function() {
      function NoopLoggerProvider2() {
      }
      NoopLoggerProvider2.prototype.getLogger = function(_name, _version, _options) {
        return new NoopLogger();
      };
      return NoopLoggerProvider2;
    }();
    NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/esm/platform/node/globalThis.js
var _globalThis2;
var init_globalThis2 = __esm({
  "../../node_modules/@opentelemetry/api-logs/build/esm/platform/node/globalThis.js"() {
    "use strict";
    init_esm_shims();
    _globalThis2 = typeof globalThis === "object" ? globalThis : global;
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/esm/platform/node/index.js
var init_node2 = __esm({
  "../../node_modules/@opentelemetry/api-logs/build/esm/platform/node/index.js"() {
    "use strict";
    init_esm_shims();
    init_globalThis2();
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/esm/platform/index.js
var init_platform2 = __esm({
  "../../node_modules/@opentelemetry/api-logs/build/esm/platform/index.js"() {
    "use strict";
    init_esm_shims();
    init_node2();
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/esm/internal/global-utils.js
function makeGetter(requiredVersion, instance, fallback) {
  return function(version) {
    return version === requiredVersion ? instance : fallback;
  };
}
var GLOBAL_LOGS_API_KEY, _global, API_BACKWARDS_COMPATIBILITY_VERSION;
var init_global_utils = __esm({
  "../../node_modules/@opentelemetry/api-logs/build/esm/internal/global-utils.js"() {
    "use strict";
    init_esm_shims();
    init_platform2();
    GLOBAL_LOGS_API_KEY = Symbol.for("io.opentelemetry.js.api.logs");
    _global = _globalThis2;
    API_BACKWARDS_COMPATIBILITY_VERSION = 1;
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/esm/api/logs.js
var LogsAPI;
var init_logs = __esm({
  "../../node_modules/@opentelemetry/api-logs/build/esm/api/logs.js"() {
    "use strict";
    init_esm_shims();
    init_global_utils();
    init_NoopLoggerProvider();
    LogsAPI = /** @class */
    function() {
      function LogsAPI2() {
      }
      LogsAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new LogsAPI2();
        }
        return this._instance;
      };
      LogsAPI2.prototype.setGlobalLoggerProvider = function(provider) {
        if (_global[GLOBAL_LOGS_API_KEY]) {
          return this.getLoggerProvider();
        }
        _global[GLOBAL_LOGS_API_KEY] = makeGetter(API_BACKWARDS_COMPATIBILITY_VERSION, provider, NOOP_LOGGER_PROVIDER);
        return provider;
      };
      LogsAPI2.prototype.getLoggerProvider = function() {
        var _a2, _b;
        return (_b = (_a2 = _global[GLOBAL_LOGS_API_KEY]) === null || _a2 === void 0 ? void 0 : _a2.call(_global, API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NOOP_LOGGER_PROVIDER;
      };
      LogsAPI2.prototype.getLogger = function(name, version, options) {
        return this.getLoggerProvider().getLogger(name, version, options);
      };
      LogsAPI2.prototype.disable = function() {
        delete _global[GLOBAL_LOGS_API_KEY];
      };
      return LogsAPI2;
    }();
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/esm/index.js
var logs;
var init_esm4 = __esm({
  "../../node_modules/@opentelemetry/api-logs/build/esm/index.js"() {
    "use strict";
    init_esm_shims();
    init_Logger();
    init_LoggerProvider();
    init_LogRecord();
    init_LoggerOptions();
    init_AnyValue();
    init_NoopLogger();
    init_NoopLoggerProvider();
    init_logs();
    logs = LogsAPI.getInstance();
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/autoLoaderUtils.js
function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
  for (var i = 0, j = instrumentations.length; i < j; i++) {
    var instrumentation = instrumentations[i];
    if (tracerProvider) {
      instrumentation.setTracerProvider(tracerProvider);
    }
    if (meterProvider) {
      instrumentation.setMeterProvider(meterProvider);
    }
    if (loggerProvider && instrumentation.setLoggerProvider) {
      instrumentation.setLoggerProvider(loggerProvider);
    }
    if (!instrumentation.getConfig().enabled) {
      instrumentation.enable();
    }
  }
}
function disableInstrumentations(instrumentations) {
  instrumentations.forEach(function(instrumentation) {
    return instrumentation.disable();
  });
}
var init_autoLoaderUtils = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/autoLoaderUtils.js"() {
    "use strict";
    init_esm_shims();
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/autoLoader.js
function registerInstrumentations(options) {
  var _a2, _b;
  var tracerProvider = options.tracerProvider || trace.getTracerProvider();
  var meterProvider = options.meterProvider || metrics.getMeterProvider();
  var loggerProvider = options.loggerProvider || logs.getLoggerProvider();
  var instrumentations = (_b = (_a2 = options.instrumentations) === null || _a2 === void 0 ? void 0 : _a2.flat()) !== null && _b !== void 0 ? _b : [];
  enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider);
  return function() {
    disableInstrumentations(instrumentations);
  };
}
var init_autoLoader = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/autoLoader.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    init_esm4();
    init_autoLoaderUtils();
  }
});

// ../../node_modules/shimmer/index.js
var require_shimmer = __commonJS({
  "../../node_modules/shimmer/index.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    function isFunction2(funktion) {
      return typeof funktion === "function";
    }
    var logger2 = console.error.bind(console);
    function defineProperty(obj, name, value) {
      var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
      Object.defineProperty(obj, name, {
        configurable: true,
        enumerable,
        writable: true,
        value
      });
    }
    function shimmer2(options) {
      if (options && options.logger) {
        if (!isFunction2(options.logger)) logger2("new logger isn't a function, not replacing");
        else logger2 = options.logger;
      }
    }
    function wrap3(nodule, name, wrapper) {
      if (!nodule || !nodule[name]) {
        logger2("no original function " + name + " to wrap");
        return;
      }
      if (!wrapper) {
        logger2("no wrapper function");
        logger2(new Error().stack);
        return;
      }
      if (!isFunction2(nodule[name]) || !isFunction2(wrapper)) {
        logger2("original object and wrapper must be functions");
        return;
      }
      var original = nodule[name];
      var wrapped = wrapper(original, name);
      defineProperty(wrapped, "__original", original);
      defineProperty(wrapped, "__unwrap", function() {
        if (nodule[name] === wrapped) defineProperty(nodule, name, original);
      });
      defineProperty(wrapped, "__wrapped", true);
      defineProperty(nodule, name, wrapped);
      return wrapped;
    }
    function massWrap2(nodules, names, wrapper) {
      if (!nodules) {
        logger2("must provide one or more modules to patch");
        logger2(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger2("must provide one or more functions to wrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name) {
          wrap3(nodule, name, wrapper);
        });
      });
    }
    function unwrap3(nodule, name) {
      if (!nodule || !nodule[name]) {
        logger2("no function to unwrap.");
        logger2(new Error().stack);
        return;
      }
      if (!nodule[name].__unwrap) {
        logger2("no original to unwrap to -- has " + name + " already been unwrapped?");
      } else {
        return nodule[name].__unwrap();
      }
    }
    function massUnwrap2(nodules, names) {
      if (!nodules) {
        logger2("must provide one or more modules to patch");
        logger2(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger2("must provide one or more functions to unwrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name) {
          unwrap3(nodule, name);
        });
      });
    }
    shimmer2.wrap = wrap3;
    shimmer2.massWrap = massWrap2;
    shimmer2.unwrap = unwrap3;
    shimmer2.massUnwrap = massUnwrap2;
    module2.exports = shimmer2;
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/instrumentation.js
var shimmer, __assign, InstrumentationAbstract;
var init_instrumentation = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/instrumentation.js"() {
    "use strict";
    init_esm_shims();
    init_esm();
    init_esm4();
    shimmer = __toESM(require_shimmer());
    __assign = function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    InstrumentationAbstract = /** @class */
    function() {
      function InstrumentationAbstract2(instrumentationName, instrumentationVersion, config) {
        this.instrumentationName = instrumentationName;
        this.instrumentationVersion = instrumentationVersion;
        this._wrap = shimmer.wrap;
        this._unwrap = shimmer.unwrap;
        this._massWrap = shimmer.massWrap;
        this._massUnwrap = shimmer.massUnwrap;
        this._config = __assign({ enabled: true }, config);
        this._diag = diag.createComponentLogger({
          namespace: instrumentationName
        });
        this._tracer = trace.getTracer(instrumentationName, instrumentationVersion);
        this._meter = metrics.getMeter(instrumentationName, instrumentationVersion);
        this._logger = logs.getLogger(instrumentationName, instrumentationVersion);
        this._updateMetricInstruments();
      }
      Object.defineProperty(InstrumentationAbstract2.prototype, "meter", {
        /* Returns meter */
        get: function() {
          return this._meter;
        },
        enumerable: false,
        configurable: true
      });
      InstrumentationAbstract2.prototype.setMeterProvider = function(meterProvider) {
        this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
        this._updateMetricInstruments();
      };
      Object.defineProperty(InstrumentationAbstract2.prototype, "logger", {
        /* Returns logger */
        get: function() {
          return this._logger;
        },
        enumerable: false,
        configurable: true
      });
      InstrumentationAbstract2.prototype.setLoggerProvider = function(loggerProvider) {
        this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
      };
      InstrumentationAbstract2.prototype.getModuleDefinitions = function() {
        var _a2;
        var initResult = (_a2 = this.init()) !== null && _a2 !== void 0 ? _a2 : [];
        if (!Array.isArray(initResult)) {
          return [initResult];
        }
        return initResult;
      };
      InstrumentationAbstract2.prototype._updateMetricInstruments = function() {
        return;
      };
      InstrumentationAbstract2.prototype.getConfig = function() {
        return this._config;
      };
      InstrumentationAbstract2.prototype.setConfig = function(config) {
        this._config = __assign({}, config);
      };
      InstrumentationAbstract2.prototype.setTracerProvider = function(tracerProvider) {
        this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
      };
      Object.defineProperty(InstrumentationAbstract2.prototype, "tracer", {
        /* Returns tracer */
        get: function() {
          return this._tracer;
        },
        enumerable: false,
        configurable: true
      });
      InstrumentationAbstract2.prototype._runSpanCustomizationHook = function(hookHandler, triggerName, span, info) {
        if (!hookHandler) {
          return;
        }
        try {
          hookHandler(span, info);
        } catch (e) {
          this._diag.error("Error running span customization hook due to exception in handler", { triggerName }, e);
        }
      };
      return InstrumentationAbstract2;
    }();
  }
});

// ../../node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "../../node_modules/resolve/lib/homedir.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var os3 = __require("os");
    module2.exports = os3.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// ../../node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "../../node_modules/resolve/lib/caller.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// ../../node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "../../node_modules/path-parse/index.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix2 = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix2.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module2.exports = win32.parse;
    else
      module2.exports = posix2.parse;
    module2.exports.posix = posix2.parse;
    module2.exports.win32 = win32.parse;
  }
});

// ../../node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "../../node_modules/resolve/lib/node-modules-paths.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var path3 = __require("path");
    var parse = path3.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path3.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// ../../node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "../../node_modules/resolve/lib/normalize-options.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var path3 = __require("path");
    module2.exports = function(_, opts) {
      opts = opts || {};
      if (opts.forceNodeResolution || !process.versions.pnp)
        return opts;
      const { findPnpApi } = __require("module");
      const runPnpResolution = (request, basedir) => {
        const parts = request.match(/^((?:@[^/]+\/)?[^/]+)(\/.*)?/);
        if (!parts)
          throw new Error(`Assertion failed: Expected the "resolve" package to call the "paths" callback with package names only (got "${request}")`);
        if (basedir.charAt(basedir.length - 1) !== `/`)
          basedir = path3.join(basedir, `/`);
        const api = findPnpApi(basedir);
        if (api === null)
          return void 0;
        let manifestPath;
        try {
          manifestPath = api.resolveToUnqualified(`${parts[1]}/package.json`, basedir, { considerBuiltins: false });
        } catch (err) {
          return null;
        }
        if (manifestPath === null)
          throw new Error(`Assertion failed: The resolution thinks that "${parts[1]}" is a Node builtin`);
        const packagePath = path3.dirname(manifestPath);
        const unqualifiedPath = typeof parts[2] !== `undefined` ? path3.join(packagePath, parts[2]) : packagePath;
        return { packagePath, unqualifiedPath };
      };
      const runPnpResolutionOnArray = (request, paths2) => {
        for (let i = 0; i < paths2.length; i++) {
          const resolution = runPnpResolution(request, paths2[i]);
          if (resolution || i === paths2.length - 1) {
            return resolution;
          }
        }
        return null;
      };
      const originalPaths = Array.isArray(opts.paths) ? opts.paths : [];
      const packageIterator = (request, basedir, getCandidates, opts2) => {
        const pathsToTest = [basedir].concat(originalPaths);
        const resolution = runPnpResolutionOnArray(request, pathsToTest);
        if (resolution == null)
          return getCandidates();
        return [resolution.unqualifiedPath];
      };
      const paths = (request, basedir, getNodeModulePaths, opts2) => {
        const pathsToTest = [basedir].concat(originalPaths);
        const resolution = runPnpResolutionOnArray(request, pathsToTest);
        if (resolution == null)
          return getNodeModulePaths().concat(originalPaths);
        let nodeModules = path3.dirname(resolution.packagePath);
        if (request.match(/^@[^/]+\//))
          nodeModules = path3.dirname(nodeModules);
        return [nodeModules];
      };
      let isInsideIterator = false;
      if (!opts.__skipPackageIterator) {
        opts.packageIterator = function(request, basedir, getCandidates, opts2) {
          isInsideIterator = true;
          try {
            return packageIterator(request, basedir, getCandidates, opts2);
          } finally {
            isInsideIterator = false;
          }
        };
      }
      opts.paths = function(request, basedir, getNodeModulePaths, opts2) {
        if (isInsideIterator)
          return getNodeModulePaths().concat(originalPaths);
        return paths(request, basedir, getNodeModulePaths, opts2);
      };
      return opts;
    };
  }
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/function-bind/implementation.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/function-bind/index.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/hasown/index.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// ../../node_modules/is-core-module/core.json
var require_core = __commonJS({
  "../../node_modules/is-core-module/core.json"(exports, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      "node:sea": [">= 20.12 && < 21", ">= 21.7"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "test/mock_loader": ">= 22.3 && < 22.7",
      "node:test/mock_loader": ">= 22.3 && < 22.7",
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// ../../node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "../../node_modules/is-core-module/index.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var hasOwn = require_hasown();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core();
    module2.exports = function isCore(x, nodeVersion) {
      return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
    };
  }
});

// ../../node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "../../node_modules/resolve/lib/async.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var fs = __require("fs");
    var getHomedir = require_homedir();
    var path3 = __require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path3.join(homedir, ".node_modules"),
        path3.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT") cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile2, pkgfile, cb) {
      readFile2(pkgfile, function(readFileErr, body) {
        if (readFileErr) cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path3.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolve(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile2 = opts.readFile || fs.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path3.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path3.resolve(basedir);
      maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2) cb(err2);
          else init2(realStart);
        }
      );
      var res;
      function init2(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path3.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/") res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else loadNodeModules(x, basedir2, function(err2, n, pkg) {
          if (err2) cb(err2);
          else if (n) {
            return maybeRealpath(realpath, n, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
      }
      function onfile(err2, m, pkg) {
        if (err2) cb(err2);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function(err3, d, pkg2) {
          if (err3) cb(err3);
          else if (d) {
            maybeRealpath(realpath, d, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0) return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg) onpkg(null, pkg);
          else loadpkg(path3.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2) return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path3.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r) return load(
                [""].concat(extensions.slice()),
                path3.resolve(dir, r),
                pkg
              );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2) return cb2(err2);
            if (ex) return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/") return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir)) return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr) return loadpkg(path3.dirname(dir), cb2);
          var pkgfile = path3.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex) return loadpkg(path3.dirname(dir), cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3) cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr) return cb2(unwrapErr);
          var pkgfile = path3.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2) return cb2(err2);
            if (!ex) return loadAsFile(path3.join(x2, "index"), fpkg, cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3) return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path3.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4) return cb2(err4);
                  if (m) return cb2(null, m, pkg2);
                  if (!pkg2) return loadAsFile(path3.join(x2, "index"), pkg2, cb2);
                  var dir = path3.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                    if (err5) return cb2(err5);
                    if (n) return cb2(null, n, pkg3);
                    loadAsFile(path3.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path3.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0) return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path3.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2) return cb2(err2);
          if (!isdir2) return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2) return cb2(err2);
          if (m) return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n, pkg) {
          if (err2) return cb2(err2);
          if (n) return cb2(null, n, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// ../../node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "../../node_modules/resolve/lib/core.json"(exports, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// ../../node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "../../node_modules/resolve/lib/core.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var isCoreModule = require_is_core_module();
    var data = require_core2();
    var core = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = isCoreModule(mod);
      }
    }
    var mod;
    module2.exports = core;
  }
});

// ../../node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "../../node_modules/resolve/lib/is-core.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var isCoreModule = require_is_core_module();
    module2.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});

// ../../node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "../../node_modules/resolve/lib/sync.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var isCore = require_is_core_module();
    var fs = __require("fs");
    var path3 = __require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path3.join(homedir, ".node_modules"),
        path3.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync3, pkgfile) {
      var body = readFileSync3(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path3.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync3 = opts.readFileSync || fs.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path3.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path3.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path3.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/") res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path3.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path3.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path3.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/") return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir)) return;
        var pkgfile = path3.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path3.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync3, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(
            pkg,
            /*pkgfile,*/
            dir
          );
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path3.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync3, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(
              pkg,
              /*pkgfile,*/
              x2
            );
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path3.resolve(x2, pkg.main));
              if (m2) return m2;
              var n2 = loadAsDirectorySync(path3.resolve(x2, pkg.main));
              if (n2) return n2;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path3.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path3.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2) return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2) return n2;
          }
        }
      }
    };
  }
});

// ../../node_modules/resolve/index.js
var require_resolve = __commonJS({
  "../../node_modules/resolve/index.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var async = require_async();
    async.core = require_core3();
    async.isCore = require_is_core();
    async.sync = require_sync();
    module2.exports = async;
  }
});

// ../../node_modules/module-details-from-path/index.js
var require_module_details_from_path = __commonJS({
  "../../node_modules/module-details-from-path/index.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var path3 = __require("path");
    module2.exports = function(file) {
      var segments = file.split(path3.sep);
      var index = segments.lastIndexOf("node_modules");
      if (index === -1) return;
      if (!segments[index + 1]) return;
      var scoped = segments[index + 1][0] === "@";
      var name = scoped ? segments[index + 1] + "/" + segments[index + 2] : segments[index + 1];
      var offset = scoped ? 3 : 2;
      return {
        name,
        basedir: segments.slice(0, index + offset).join(path3.sep),
        path: segments.slice(index + offset).join(path3.sep)
      };
    };
  }
});

// ../../node_modules/require-in-the-middle/package.json
var require_package = __commonJS({
  "../../node_modules/require-in-the-middle/package.json"(exports, module2) {
    module2.exports = {
      name: "require-in-the-middle",
      version: "7.4.0",
      description: "Module to hook into the Node.js require function",
      main: "index.js",
      types: "types/index.d.ts",
      dependencies: {
        debug: "^4.3.5",
        "module-details-from-path": "^1.0.3",
        resolve: "^1.22.8"
      },
      devDependencies: {
        "@babel/core": "^7.9.0",
        "@babel/preset-env": "^7.9.5",
        "@babel/preset-typescript": "^7.9.0",
        "@babel/register": "^7.9.0",
        "ipp-printer": "^1.0.0",
        patterns: "^1.0.3",
        roundround: "^0.2.0",
        semver: "^6.3.0",
        standard: "^14.3.1",
        tape: "^4.11.0"
      },
      scripts: {
        test: "npm run test:lint && npm run test:tape && npm run test:babel",
        "test:lint": "standard",
        "test:tape": "tape test/*.js",
        "test:babel": "node test/babel/babel-register.js"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/elastic/require-in-the-middle.git"
      },
      keywords: [
        "require",
        "hook",
        "shim",
        "shimmer",
        "shimming",
        "patch",
        "monkey",
        "monkeypatch",
        "module",
        "load"
      ],
      files: [
        "types"
      ],
      author: "Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)",
      license: "MIT",
      bugs: {
        url: "https://github.com/elastic/require-in-the-middle/issues"
      },
      homepage: "https://github.com/elastic/require-in-the-middle#readme",
      engines: {
        node: ">=8.6.0"
      }
    };
  }
});

// ../../node_modules/require-in-the-middle/index.js
var require_require_in_the_middle = __commonJS({
  "../../node_modules/require-in-the-middle/index.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var path3 = __require("path");
    var Module = __require("module");
    var resolve = require_resolve();
    var debug3 = require_src()("require-in-the-middle");
    var moduleDetailsFromPath = require_module_details_from_path();
    module2.exports = Hook2;
    module2.exports.Hook = Hook2;
    var isCore;
    if (Module.isBuiltin) {
      isCore = Module.isBuiltin;
    } else {
      const [major, minor] = process.versions.node.split(".").map(Number);
      if (major === 8 && minor < 8) {
        isCore = (moduleName) => {
          if (moduleName === "http2") {
            return true;
          }
          return !!resolve.core[moduleName];
        };
      } else {
        isCore = (moduleName) => {
          return !!resolve.core[moduleName];
        };
      }
    }
    var normalize3 = /([/\\]index)?(\.js)?$/;
    var ExportsCache = class {
      constructor() {
        this._localCache = /* @__PURE__ */ new Map();
        this._kRitmExports = Symbol("RitmExports");
      }
      has(filename, isBuiltin) {
        if (this._localCache.has(filename)) {
          return true;
        } else if (!isBuiltin) {
          const mod = __require.cache[filename];
          return !!(mod && this._kRitmExports in mod);
        } else {
          return false;
        }
      }
      get(filename, isBuiltin) {
        const cachedExports = this._localCache.get(filename);
        if (cachedExports !== void 0) {
          return cachedExports;
        } else if (!isBuiltin) {
          const mod = __require.cache[filename];
          return mod && mod[this._kRitmExports];
        }
      }
      set(filename, exports2, isBuiltin) {
        if (isBuiltin) {
          this._localCache.set(filename, exports2);
        } else if (filename in __require.cache) {
          __require.cache[filename][this._kRitmExports] = exports2;
        } else {
          debug3('non-core module is unexpectedly not in require.cache: "%s"', filename);
          this._localCache.set(filename, exports2);
        }
      }
    };
    function Hook2(modules, options, onrequire) {
      if (this instanceof Hook2 === false) return new Hook2(modules, options, onrequire);
      if (typeof modules === "function") {
        onrequire = modules;
        modules = null;
        options = null;
      } else if (typeof options === "function") {
        onrequire = options;
        options = null;
      }
      if (typeof Module._resolveFilename !== "function") {
        console.error("Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!", typeof Module._resolveFilename);
        console.error("Please report this error as an issue related to Node.js %s at %s", process.version, require_package().bugs.url);
        return;
      }
      this._cache = new ExportsCache();
      this._unhooked = false;
      this._origRequire = Module.prototype.require;
      const self = this;
      const patching = /* @__PURE__ */ new Set();
      const internals = options ? options.internals === true : false;
      const hasWhitelist = Array.isArray(modules);
      debug3("registering require hook");
      this._require = Module.prototype.require = function(id) {
        if (self._unhooked === true) {
          debug3("ignoring require call - module is soft-unhooked");
          return self._origRequire.apply(this, arguments);
        }
        return patchedRequire.call(this, arguments, false);
      };
      if (typeof process.getBuiltinModule === "function") {
        this._origGetBuiltinModule = process.getBuiltinModule;
        this._getBuiltinModule = process.getBuiltinModule = function(id) {
          if (self._unhooked === true) {
            debug3("ignoring process.getBuiltinModule call - module is soft-unhooked");
            return self._origGetBuiltinModule.apply(this, arguments);
          }
          return patchedRequire.call(this, arguments, true);
        };
      }
      function patchedRequire(args, coreOnly) {
        const id = args[0];
        const core = isCore(id);
        let filename;
        if (core) {
          filename = id;
          if (id.startsWith("node:")) {
            const idWithoutPrefix = id.slice(5);
            if (isCore(idWithoutPrefix)) {
              filename = idWithoutPrefix;
            }
          }
        } else if (coreOnly) {
          debug3("call to process.getBuiltinModule with unknown built-in id");
          return self._origGetBuiltinModule.apply(this, args);
        } else {
          try {
            filename = Module._resolveFilename(id, this);
          } catch (resolveErr) {
            debug3('Module._resolveFilename("%s") threw %j, calling original Module.require', id, resolveErr.message);
            return self._origRequire.apply(this, args);
          }
        }
        let moduleName, basedir;
        debug3("processing %s module require('%s'): %s", core === true ? "core" : "non-core", id, filename);
        if (self._cache.has(filename, core) === true) {
          debug3("returning already patched cached module: %s", filename);
          return self._cache.get(filename, core);
        }
        const isPatching = patching.has(filename);
        if (isPatching === false) {
          patching.add(filename);
        }
        const exports2 = coreOnly ? self._origGetBuiltinModule.apply(this, args) : self._origRequire.apply(this, args);
        if (isPatching === true) {
          debug3("module is in the process of being patched already - ignoring: %s", filename);
          return exports2;
        }
        patching.delete(filename);
        if (core === true) {
          if (hasWhitelist === true && modules.includes(filename) === false) {
            debug3("ignoring core module not on whitelist: %s", filename);
            return exports2;
          }
          moduleName = filename;
        } else if (hasWhitelist === true && modules.includes(filename)) {
          const parsedPath = path3.parse(filename);
          moduleName = parsedPath.name;
          basedir = parsedPath.dir;
        } else {
          const stat = moduleDetailsFromPath(filename);
          if (stat === void 0) {
            debug3("could not parse filename: %s", filename);
            return exports2;
          }
          moduleName = stat.name;
          basedir = stat.basedir;
          const fullModuleName = resolveModuleName(stat);
          debug3("resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)", moduleName, id, fullModuleName, basedir);
          let matchFound = false;
          if (hasWhitelist) {
            if (!id.startsWith(".") && modules.includes(id)) {
              moduleName = id;
              matchFound = true;
            }
            if (!modules.includes(moduleName) && !modules.includes(fullModuleName)) {
              return exports2;
            }
            if (modules.includes(fullModuleName) && fullModuleName !== moduleName) {
              moduleName = fullModuleName;
              matchFound = true;
            }
          }
          if (!matchFound) {
            let res;
            try {
              res = resolve.sync(moduleName, { basedir });
            } catch (e) {
              debug3("could not resolve module: %s", moduleName);
              self._cache.set(filename, exports2, core);
              return exports2;
            }
            if (res !== filename) {
              if (internals === true) {
                moduleName = moduleName + path3.sep + path3.relative(basedir, filename);
                debug3("preparing to process require of internal file: %s", moduleName);
              } else {
                debug3("ignoring require of non-main module file: %s", res);
                self._cache.set(filename, exports2, core);
                return exports2;
              }
            }
          }
        }
        self._cache.set(filename, exports2, core);
        debug3("calling require hook: %s", moduleName);
        const patchedExports = onrequire(exports2, moduleName, basedir);
        self._cache.set(filename, patchedExports, core);
        debug3("returning module: %s", moduleName);
        return patchedExports;
      }
    }
    Hook2.prototype.unhook = function() {
      this._unhooked = true;
      if (this._require === Module.prototype.require) {
        Module.prototype.require = this._origRequire;
        debug3("require unhook successful");
      } else {
        debug3("require unhook unsuccessful");
      }
      if (process.getBuiltinModule !== void 0) {
        if (this._getBuiltinModule === process.getBuiltinModule) {
          process.getBuiltinModule = this._origGetBuiltinModule;
          debug3("process.getBuiltinModule unhook successful");
        } else {
          debug3("process.getBuiltinModule unhook unsuccessful");
        }
      }
    };
    function resolveModuleName(stat) {
      const normalizedPath = path3.sep !== "/" ? stat.path.split(path3.sep).join("/") : stat.path;
      return path3.posix.join(stat.name, normalizedPath).replace(normalize3, "");
    }
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ModuleNameTrie.js
var __values4, __read4, __spreadArray2, ModuleNameSeparator, ModuleNameTrieNode, ModuleNameTrie;
var init_ModuleNameTrie = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ModuleNameTrie.js"() {
    "use strict";
    init_esm_shims();
    __values4 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read4 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    ModuleNameSeparator = "/";
    ModuleNameTrieNode = /** @class */
    /* @__PURE__ */ function() {
      function ModuleNameTrieNode2() {
        this.hooks = [];
        this.children = /* @__PURE__ */ new Map();
      }
      return ModuleNameTrieNode2;
    }();
    ModuleNameTrie = /** @class */
    function() {
      function ModuleNameTrie2() {
        this._trie = new ModuleNameTrieNode();
        this._counter = 0;
      }
      ModuleNameTrie2.prototype.insert = function(hook) {
        var e_1, _a2;
        var trieNode = this._trie;
        try {
          for (var _b = __values4(hook.moduleName.split(ModuleNameSeparator)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var moduleNamePart = _c.value;
            var nextNode = trieNode.children.get(moduleNamePart);
            if (!nextNode) {
              nextNode = new ModuleNameTrieNode();
              trieNode.children.set(moduleNamePart, nextNode);
            }
            trieNode = nextNode;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        trieNode.hooks.push({ hook, insertedId: this._counter++ });
      };
      ModuleNameTrie2.prototype.search = function(moduleName, _a2) {
        var e_2, _b;
        var _c = _a2 === void 0 ? {} : _a2, maintainInsertionOrder = _c.maintainInsertionOrder, fullOnly = _c.fullOnly;
        var trieNode = this._trie;
        var results = [];
        var foundFull = true;
        try {
          for (var _d = __values4(moduleName.split(ModuleNameSeparator)), _e = _d.next(); !_e.done; _e = _d.next()) {
            var moduleNamePart = _e.value;
            var nextNode = trieNode.children.get(moduleNamePart);
            if (!nextNode) {
              foundFull = false;
              break;
            }
            if (!fullOnly) {
              results.push.apply(results, __spreadArray2([], __read4(nextNode.hooks), false));
            }
            trieNode = nextNode;
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        if (fullOnly && foundFull) {
          results.push.apply(results, __spreadArray2([], __read4(trieNode.hooks), false));
        }
        if (results.length === 0) {
          return [];
        }
        if (results.length === 1) {
          return [results[0].hook];
        }
        if (maintainInsertionOrder) {
          results.sort(function(a, b) {
            return a.insertedId - b.insertedId;
          });
        }
        return results.map(function(_a3) {
          var hook = _a3.hook;
          return hook;
        });
      };
      return ModuleNameTrie2;
    }();
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/RequireInTheMiddleSingleton.js
import * as path from "path";
function normalizePathSeparators(moduleNameOrPath) {
  return path.sep !== ModuleNameSeparator ? moduleNameOrPath.split(path.sep).join(ModuleNameSeparator) : moduleNameOrPath;
}
var import_require_in_the_middle, __values5, isMocha, RequireInTheMiddleSingleton;
var init_RequireInTheMiddleSingleton = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/RequireInTheMiddleSingleton.js"() {
    "use strict";
    init_esm_shims();
    import_require_in_the_middle = __toESM(require_require_in_the_middle());
    init_ModuleNameTrie();
    __values5 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    isMocha = [
      "afterEach",
      "after",
      "beforeEach",
      "before",
      "describe",
      "it"
    ].every(function(fn) {
      return typeof global[fn] === "function";
    });
    RequireInTheMiddleSingleton = /** @class */
    function() {
      function RequireInTheMiddleSingleton2() {
        this._moduleNameTrie = new ModuleNameTrie();
        this._initialize();
      }
      RequireInTheMiddleSingleton2.prototype._initialize = function() {
        var _this = this;
        new import_require_in_the_middle.Hook(
          // Intercept all `require` calls; we will filter the matching ones below
          null,
          { internals: true },
          function(exports, name, basedir) {
            var e_1, _a2;
            var normalizedModuleName = normalizePathSeparators(name);
            var matches = _this._moduleNameTrie.search(normalizedModuleName, {
              maintainInsertionOrder: true,
              // For core modules (e.g. `fs`), do not match on sub-paths (e.g. `fs/promises').
              // This matches the behavior of `require-in-the-middle`.
              // `basedir` is always `undefined` for core modules.
              fullOnly: basedir === void 0
            });
            try {
              for (var matches_1 = __values5(matches), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {
                var onRequire = matches_1_1.value.onRequire;
                exports = onRequire(exports, name, basedir);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (matches_1_1 && !matches_1_1.done && (_a2 = matches_1.return)) _a2.call(matches_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            return exports;
          }
        );
      };
      RequireInTheMiddleSingleton2.prototype.register = function(moduleName, onRequire) {
        var hooked = { moduleName, onRequire };
        this._moduleNameTrie.insert(hooked);
        return hooked;
      };
      RequireInTheMiddleSingleton2.getInstance = function() {
        var _a2;
        if (isMocha)
          return new RequireInTheMiddleSingleton2();
        return this._instance = (_a2 = this._instance) !== null && _a2 !== void 0 ? _a2 : new RequireInTheMiddleSingleton2();
      };
      return RequireInTheMiddleSingleton2;
    }();
  }
});

// ../../node_modules/import-in-the-middle/lib/register.js
var require_register = __commonJS({
  "../../node_modules/import-in-the-middle/lib/register.js"(exports) {
    "use strict";
    init_esm_shims();
    var importHooks = [];
    var setters = /* @__PURE__ */ new WeakMap();
    var specifiers = /* @__PURE__ */ new Map();
    var toHook = [];
    var proxyHandler = {
      set(target, name, value) {
        return setters.get(target)[name](value);
      },
      defineProperty(target, property, descriptor) {
        if (!("value" in descriptor)) {
          throw new Error("Getters/setters are not supported for exports property descriptors.");
        }
        return setters.get(target)[property](descriptor.value);
      }
    };
    function register(name, namespace, set, specifier) {
      specifiers.set(name, specifier);
      setters.set(namespace, set);
      const proxy = new Proxy(namespace, proxyHandler);
      importHooks.forEach((hook) => hook(name, proxy));
      toHook.push([name, proxy]);
    }
    exports.register = register;
    exports.importHooks = importHooks;
    exports.specifiers = specifiers;
    exports.toHook = toHook;
  }
});

// ../../node_modules/import-in-the-middle/index.js
var require_import_in_the_middle = __commonJS({
  "../../node_modules/import-in-the-middle/index.js"(exports, module2) {
    "use strict";
    init_esm_shims();
    var path3 = __require("path");
    var parse = require_module_details_from_path();
    var { fileURLToPath } = __require("url");
    var {
      importHooks,
      specifiers,
      toHook
    } = require_register();
    function addHook(hook) {
      importHooks.push(hook);
      toHook.forEach(([name, namespace]) => hook(name, namespace));
    }
    function removeHook(hook) {
      const index = importHooks.indexOf(hook);
      if (index > -1) {
        importHooks.splice(index, 1);
      }
    }
    function callHookFn(hookFn, namespace, name, baseDir) {
      const newDefault = hookFn(namespace, name, baseDir);
      if (newDefault && newDefault !== namespace) {
        namespace.default = newDefault;
      }
    }
    function Hook2(modules, options, hookFn) {
      if (this instanceof Hook2 === false) return new Hook2(modules, options, hookFn);
      if (typeof modules === "function") {
        hookFn = modules;
        modules = null;
        options = null;
      } else if (typeof options === "function") {
        hookFn = options;
        options = null;
      }
      const internals = options ? options.internals === true : false;
      this._iitmHook = (name, namespace) => {
        const filename = name;
        const isBuiltin = name.startsWith("node:");
        let baseDir;
        if (isBuiltin) {
          name = name.replace(/^node:/, "");
        } else {
          if (name.startsWith("file://")) {
            try {
              name = fileURLToPath(name);
            } catch (e) {
            }
          }
          const details = parse(name);
          if (details) {
            name = details.name;
            baseDir = details.basedir;
          }
        }
        if (modules) {
          for (const moduleName of modules) {
            if (moduleName === name) {
              if (baseDir) {
                if (internals) {
                  name = name + path3.sep + path3.relative(baseDir, fileURLToPath(filename));
                } else {
                  if (!baseDir.endsWith(specifiers.get(filename))) continue;
                }
              }
              callHookFn(hookFn, namespace, name, baseDir);
            }
          }
        } else {
          callHookFn(hookFn, namespace, name, baseDir);
        }
      };
      addHook(this._iitmHook);
    }
    Hook2.prototype.unhook = function() {
      removeHook(this._iitmHook);
    };
    module2.exports = Hook2;
    module2.exports.Hook = Hook2;
    module2.exports.addHook = addHook;
    module2.exports.removeHook = removeHook;
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/utils.js
function safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {
  var error;
  var result;
  try {
    result = execute();
  } catch (e) {
    error = e;
  } finally {
    onFinish(error, result);
    if (error && !preventThrowingError) {
      throw error;
    }
    return result;
  }
}
function safeExecuteInTheMiddleAsync(execute, onFinish, preventThrowingError) {
  return __awaiter(this, void 0, void 0, function() {
    var error, result, e_1;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          _a2.trys.push([0, 2, 3, 4]);
          return [4, execute()];
        case 1:
          result = _a2.sent();
          return [3, 4];
        case 2:
          e_1 = _a2.sent();
          error = e_1;
          return [3, 4];
        case 3:
          onFinish(error, result);
          if (error && !preventThrowingError) {
            throw error;
          }
          return [2, result];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function isWrapped2(func) {
  return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
}
var __awaiter, __generator;
var init_utils2 = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/utils.js"() {
    "use strict";
    init_esm_shims();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/instrumentation.js
import * as path2 from "path";
import { types as utilTypes } from "util";
import { readFileSync } from "fs";
function isSupported(supportedVersions, version, includePrerelease) {
  if (typeof version === "undefined") {
    return supportedVersions.includes("*");
  }
  return supportedVersions.some(function(supportedVersion) {
    return (0, import_semver.satisfies)(version, supportedVersion, { includePrerelease });
  });
}
var import_semver, import_shimmer, import_import_in_the_middle, import_require_in_the_middle2, __extends2, __values6, InstrumentationBase;
var init_instrumentation2 = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/instrumentation.js"() {
    "use strict";
    init_esm_shims();
    import_semver = __toESM(require_semver2());
    import_shimmer = __toESM(require_shimmer());
    init_instrumentation();
    init_RequireInTheMiddleSingleton();
    import_import_in_the_middle = __toESM(require_import_in_the_middle());
    init_esm();
    import_require_in_the_middle2 = __toESM(require_require_in_the_middle());
    init_utils2();
    __extends2 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __values6 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    InstrumentationBase = /** @class */
    function(_super) {
      __extends2(InstrumentationBase2, _super);
      function InstrumentationBase2(instrumentationName, instrumentationVersion, config) {
        var _this = _super.call(this, instrumentationName, instrumentationVersion, config) || this;
        _this._hooks = [];
        _this._requireInTheMiddleSingleton = RequireInTheMiddleSingleton.getInstance();
        _this._enabled = false;
        _this._wrap = function(moduleExports, name, wrapper) {
          if (isWrapped2(moduleExports[name])) {
            _this._unwrap(moduleExports, name);
          }
          if (!utilTypes.isProxy(moduleExports)) {
            return (0, import_shimmer.wrap)(moduleExports, name, wrapper);
          } else {
            var wrapped = (0, import_shimmer.wrap)(Object.assign({}, moduleExports), name, wrapper);
            return Object.defineProperty(moduleExports, name, {
              value: wrapped
            });
          }
        };
        _this._unwrap = function(moduleExports, name) {
          if (!utilTypes.isProxy(moduleExports)) {
            return (0, import_shimmer.unwrap)(moduleExports, name);
          } else {
            return Object.defineProperty(moduleExports, name, {
              value: moduleExports[name]
            });
          }
        };
        _this._massWrap = function(moduleExportsArray, names, wrapper) {
          if (!moduleExportsArray) {
            diag.error("must provide one or more modules to patch");
            return;
          } else if (!Array.isArray(moduleExportsArray)) {
            moduleExportsArray = [moduleExportsArray];
          }
          if (!(names && Array.isArray(names))) {
            diag.error("must provide one or more functions to wrap on modules");
            return;
          }
          moduleExportsArray.forEach(function(moduleExports) {
            names.forEach(function(name) {
              _this._wrap(moduleExports, name, wrapper);
            });
          });
        };
        _this._massUnwrap = function(moduleExportsArray, names) {
          if (!moduleExportsArray) {
            diag.error("must provide one or more modules to patch");
            return;
          } else if (!Array.isArray(moduleExportsArray)) {
            moduleExportsArray = [moduleExportsArray];
          }
          if (!(names && Array.isArray(names))) {
            diag.error("must provide one or more functions to wrap on modules");
            return;
          }
          moduleExportsArray.forEach(function(moduleExports) {
            names.forEach(function(name) {
              _this._unwrap(moduleExports, name);
            });
          });
        };
        var modules = _this.init();
        if (modules && !Array.isArray(modules)) {
          modules = [modules];
        }
        _this._modules = modules || [];
        if (_this._modules.length === 0) {
          diag.debug("No modules instrumentation has been defined for " + ("'" + _this.instrumentationName + "@" + _this.instrumentationVersion + "'") + ", nothing will be patched");
        }
        if (_this._config.enabled) {
          _this.enable();
        }
        return _this;
      }
      InstrumentationBase2.prototype._warnOnPreloadedModules = function() {
        var _this = this;
        this._modules.forEach(function(module2) {
          var name = module2.name;
          try {
            var resolvedModule = __require.resolve(name);
            if (__require.cache[resolvedModule]) {
              _this._diag.warn("Module " + name + " has been loaded before " + _this.instrumentationName + " so it might not work, please initialize it before requiring " + name);
            }
          } catch (_a2) {
          }
        });
      };
      InstrumentationBase2.prototype._extractPackageVersion = function(baseDir) {
        try {
          var json = readFileSync(path2.join(baseDir, "package.json"), {
            encoding: "utf8"
          });
          var version = JSON.parse(json).version;
          return typeof version === "string" ? version : void 0;
        } catch (error) {
          diag.warn("Failed extracting version", baseDir);
        }
        return void 0;
      };
      InstrumentationBase2.prototype._onRequire = function(module2, exports, name, baseDir) {
        var _this = this;
        var _a2;
        if (!baseDir) {
          if (typeof module2.patch === "function") {
            module2.moduleExports = exports;
            if (this._enabled) {
              this._diag.debug("Applying instrumentation patch for nodejs core module on require hook", {
                module: module2.name
              });
              return module2.patch(exports);
            }
          }
          return exports;
        }
        var version = this._extractPackageVersion(baseDir);
        module2.moduleVersion = version;
        if (module2.name === name) {
          if (isSupported(module2.supportedVersions, version, module2.includePrerelease)) {
            if (typeof module2.patch === "function") {
              module2.moduleExports = exports;
              if (this._enabled) {
                this._diag.debug("Applying instrumentation patch for module on require hook", {
                  module: module2.name,
                  version: module2.moduleVersion,
                  baseDir
                });
                return module2.patch(exports, module2.moduleVersion);
              }
            }
          }
          return exports;
        }
        var files = (_a2 = module2.files) !== null && _a2 !== void 0 ? _a2 : [];
        var normalizedName = path2.normalize(name);
        var supportedFileInstrumentations = files.filter(function(f) {
          return f.name === normalizedName;
        }).filter(function(f) {
          return isSupported(f.supportedVersions, version, module2.includePrerelease);
        });
        return supportedFileInstrumentations.reduce(function(patchedExports, file) {
          file.moduleExports = patchedExports;
          if (_this._enabled) {
            _this._diag.debug("Applying instrumentation patch for nodejs module file on require hook", {
              module: module2.name,
              version: module2.moduleVersion,
              fileName: file.name,
              baseDir
            });
            return file.patch(patchedExports, module2.moduleVersion);
          }
          return patchedExports;
        }, exports);
      };
      InstrumentationBase2.prototype.enable = function() {
        var e_1, _a2, e_2, _b, e_3, _c;
        var _this = this;
        if (this._enabled) {
          return;
        }
        this._enabled = true;
        if (this._hooks.length > 0) {
          try {
            for (var _d = __values6(this._modules), _e = _d.next(); !_e.done; _e = _d.next()) {
              var module_1 = _e.value;
              if (typeof module_1.patch === "function" && module_1.moduleExports) {
                this._diag.debug("Applying instrumentation patch for nodejs module on instrumentation enabled", {
                  module: module_1.name,
                  version: module_1.moduleVersion
                });
                module_1.patch(module_1.moduleExports, module_1.moduleVersion);
              }
              try {
                for (var _f = (e_2 = void 0, __values6(module_1.files)), _g = _f.next(); !_g.done; _g = _f.next()) {
                  var file = _g.value;
                  if (file.moduleExports) {
                    this._diag.debug("Applying instrumentation patch for nodejs module file on instrumentation enabled", {
                      module: module_1.name,
                      version: module_1.moduleVersion,
                      fileName: file.name
                    });
                    file.patch(file.moduleExports, module_1.moduleVersion);
                  }
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                } finally {
                  if (e_2) throw e_2.error;
                }
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_e && !_e.done && (_a2 = _d.return)) _a2.call(_d);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return;
        }
        this._warnOnPreloadedModules();
        var _loop_1 = function(module_22) {
          var hookFn = function(exports, name, baseDir) {
            return _this._onRequire(module_22, exports, name, baseDir);
          };
          var onRequire = function(exports, name, baseDir) {
            return _this._onRequire(module_22, exports, name, baseDir);
          };
          var hook = path2.isAbsolute(module_22.name) ? new import_require_in_the_middle2.Hook([module_22.name], { internals: true }, onRequire) : this_1._requireInTheMiddleSingleton.register(module_22.name, onRequire);
          this_1._hooks.push(hook);
          var esmHook = new import_import_in_the_middle.Hook([module_22.name], { internals: false }, hookFn);
          this_1._hooks.push(esmHook);
        };
        var this_1 = this;
        try {
          for (var _h = __values6(this._modules), _j = _h.next(); !_j.done; _j = _h.next()) {
            var module_2 = _j.value;
            _loop_1(module_2);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
      };
      InstrumentationBase2.prototype.disable = function() {
        var e_4, _a2, e_5, _b;
        if (!this._enabled) {
          return;
        }
        this._enabled = false;
        try {
          for (var _c = __values6(this._modules), _d = _c.next(); !_d.done; _d = _c.next()) {
            var module_3 = _d.value;
            if (typeof module_3.unpatch === "function" && module_3.moduleExports) {
              this._diag.debug("Removing instrumentation patch for nodejs module on instrumentation disabled", {
                module: module_3.name,
                version: module_3.moduleVersion
              });
              module_3.unpatch(module_3.moduleExports, module_3.moduleVersion);
            }
            try {
              for (var _e = (e_5 = void 0, __values6(module_3.files)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var file = _f.value;
                if (file.moduleExports) {
                  this._diag.debug("Removing instrumentation patch for nodejs module file on instrumentation disabled", {
                    module: module_3.name,
                    version: module_3.moduleVersion,
                    fileName: file.name
                  });
                  file.unpatch(file.moduleExports, module_3.moduleVersion);
                }
              }
            } catch (e_5_1) {
              e_5 = { error: e_5_1 };
            } finally {
              try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
              } finally {
                if (e_5) throw e_5.error;
              }
            }
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (_d && !_d.done && (_a2 = _c.return)) _a2.call(_c);
          } finally {
            if (e_4) throw e_4.error;
          }
        }
      };
      InstrumentationBase2.prototype.isEnabled = function() {
        return this._enabled;
      };
      return InstrumentationBase2;
    }(InstrumentationAbstract);
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/normalize.js
import { normalize as normalize2 } from "path";
var init_normalize = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/normalize.js"() {
    "use strict";
    init_esm_shims();
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/index.js
var init_node3 = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/platform/node/index.js"() {
    "use strict";
    init_esm_shims();
    init_instrumentation2();
    init_normalize();
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/platform/index.js
var init_platform3 = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/platform/index.js"() {
    "use strict";
    init_esm_shims();
    init_node3();
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/instrumentationNodeModuleDefinition.js
var InstrumentationNodeModuleDefinition;
var init_instrumentationNodeModuleDefinition = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/instrumentationNodeModuleDefinition.js"() {
    "use strict";
    init_esm_shims();
    InstrumentationNodeModuleDefinition = /** @class */
    /* @__PURE__ */ function() {
      function InstrumentationNodeModuleDefinition2(name, supportedVersions, patch, unpatch, files) {
        this.name = name;
        this.supportedVersions = supportedVersions;
        this.patch = patch;
        this.unpatch = unpatch;
        this.files = files || [];
      }
      return InstrumentationNodeModuleDefinition2;
    }();
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/instrumentationNodeModuleFile.js
var InstrumentationNodeModuleFile;
var init_instrumentationNodeModuleFile = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/instrumentationNodeModuleFile.js"() {
    "use strict";
    init_esm_shims();
    init_platform3();
    InstrumentationNodeModuleFile = /** @class */
    /* @__PURE__ */ function() {
      function InstrumentationNodeModuleFile2(name, supportedVersions, patch, unpatch) {
        this.supportedVersions = supportedVersions;
        this.patch = patch;
        this.unpatch = unpatch;
        this.name = normalize2(name);
      }
      return InstrumentationNodeModuleFile2;
    }();
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/types.js
var init_types2 = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/types.js"() {
    "use strict";
    init_esm_shims();
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/types_internal.js
var init_types_internal = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/types_internal.js"() {
    "use strict";
    init_esm_shims();
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  InstrumentationBase: () => InstrumentationBase,
  InstrumentationNodeModuleDefinition: () => InstrumentationNodeModuleDefinition,
  InstrumentationNodeModuleFile: () => InstrumentationNodeModuleFile,
  isWrapped: () => isWrapped2,
  registerInstrumentations: () => registerInstrumentations,
  safeExecuteInTheMiddle: () => safeExecuteInTheMiddle,
  safeExecuteInTheMiddleAsync: () => safeExecuteInTheMiddleAsync
});
var init_esm5 = __esm({
  "../../node_modules/@opentelemetry/instrumentation/build/esm/index.js"() {
    "use strict";
    init_esm_shims();
    init_autoLoader();
    init_platform3();
    init_instrumentationNodeModuleDefinition();
    init_instrumentationNodeModuleFile();
    init_types2();
    init_types_internal();
    init_utils2();
  }
});

// ../../node_modules/@opentelemetry/instrumentation-http/build/src/http.js
var require_http = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-http/build/src/http.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var semver = require_semver2();
    var url = __require("url");
    var utils = require_utils();
    var version_1 = require_version();
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var core_2 = (init_esm3(), __toCommonJS(esm_exports3));
    var events_1 = __require("events");
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var HttpInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super("@opentelemetry/instrumentation-http", version_1.VERSION, config);
        this._spanNotEnded = /* @__PURE__ */ new WeakSet();
        this._headerCapture = this._createHeaderCapture();
      }
      _updateMetricInstruments() {
        this._httpServerDurationHistogram = this.meter.createHistogram("http.server.duration", {
          description: "Measures the duration of inbound HTTP requests.",
          unit: "ms",
          valueType: api_1.ValueType.DOUBLE
        });
        this._httpClientDurationHistogram = this.meter.createHistogram("http.client.duration", {
          description: "Measures the duration of outbound HTTP requests.",
          unit: "ms",
          valueType: api_1.ValueType.DOUBLE
        });
      }
      setConfig(config = {}) {
        super.setConfig(config);
        this._headerCapture = this._createHeaderCapture();
      }
      init() {
        return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];
      }
      _getHttpInstrumentation() {
        return new instrumentation_1.InstrumentationNodeModuleDefinition("http", ["*"], (moduleExports) => {
          this._wrap(moduleExports, "request", this._getPatchOutgoingRequestFunction("http"));
          this._wrap(moduleExports, "get", this._getPatchOutgoingGetFunction(moduleExports.request));
          this._wrap(moduleExports.Server.prototype, "emit", this._getPatchIncomingRequestFunction("http"));
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports === void 0)
            return;
          this._unwrap(moduleExports, "request");
          this._unwrap(moduleExports, "get");
          this._unwrap(moduleExports.Server.prototype, "emit");
        });
      }
      _getHttpsInstrumentation() {
        return new instrumentation_1.InstrumentationNodeModuleDefinition("https", ["*"], (moduleExports) => {
          this._wrap(moduleExports, "request", this._getPatchHttpsOutgoingRequestFunction("https"));
          this._wrap(moduleExports, "get", this._getPatchHttpsOutgoingGetFunction(moduleExports.request));
          this._wrap(moduleExports.Server.prototype, "emit", this._getPatchIncomingRequestFunction("https"));
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports === void 0)
            return;
          this._unwrap(moduleExports, "request");
          this._unwrap(moduleExports, "get");
          this._unwrap(moduleExports.Server.prototype, "emit");
        });
      }
      /**
       * Creates spans for incoming requests, restoring spans' context if applied.
       */
      _getPatchIncomingRequestFunction(component) {
        return (original) => {
          return this._incomingRequestFunction(component, original);
        };
      }
      /**
       * Creates spans for outgoing requests, sending spans' context for distributed
       * tracing.
       */
      _getPatchOutgoingRequestFunction(component) {
        return (original) => {
          return this._outgoingRequestFunction(component, original);
        };
      }
      _getPatchOutgoingGetFunction(clientRequest) {
        return (_original) => {
          return function outgoingGetRequest(options, ...args) {
            const req = clientRequest(options, ...args);
            req.end();
            return req;
          };
        };
      }
      /** Patches HTTPS outgoing requests */
      _getPatchHttpsOutgoingRequestFunction(component) {
        return (original) => {
          const instrumentation = this;
          return function httpsOutgoingRequest(options, ...args) {
            var _a2;
            if (component === "https" && typeof options === "object" && ((_a2 = options === null || options === void 0 ? void 0 : options.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) !== "URL") {
              options = Object.assign({}, options);
              instrumentation._setDefaultOptions(options);
            }
            return instrumentation._getPatchOutgoingRequestFunction(component)(original)(options, ...args);
          };
        };
      }
      _setDefaultOptions(options) {
        options.protocol = options.protocol || "https:";
        options.port = options.port || 443;
      }
      /** Patches HTTPS outgoing get requests */
      _getPatchHttpsOutgoingGetFunction(clientRequest) {
        return (original) => {
          const instrumentation = this;
          return function httpsOutgoingRequest(options, ...args) {
            return instrumentation._getPatchOutgoingGetFunction(clientRequest)(original)(options, ...args);
          };
        };
      }
      /**
       * Attach event listeners to a client request to end span and add span attributes.
       *
       * @param request The original request object.
       * @param span representing the current operation
       * @param startTime representing the start time of the request to calculate duration in Metric
       * @param metricAttributes metric attributes
       */
      _traceClientRequest(request, span, startTime, metricAttributes) {
        if (this.getConfig().requestHook) {
          this._callRequestHook(span, request);
        }
        let responseFinished = false;
        request.prependListener("response", (response) => {
          this._diag.debug("outgoingRequest on response()");
          if (request.listenerCount("response") <= 1) {
            response.resume();
          }
          const responseAttributes = utils.getOutgoingRequestAttributesOnResponse(response);
          span.setAttributes(responseAttributes);
          metricAttributes = Object.assign(metricAttributes, utils.getOutgoingRequestMetricAttributesOnResponse(responseAttributes));
          if (this.getConfig().responseHook) {
            this._callResponseHook(span, response);
          }
          this._headerCapture.client.captureRequestHeaders(span, (header) => request.getHeader(header));
          this._headerCapture.client.captureResponseHeaders(span, (header) => response.headers[header]);
          api_1.context.bind(api_1.context.active(), response);
          const endHandler = () => {
            this._diag.debug("outgoingRequest on end()");
            if (responseFinished) {
              return;
            }
            responseFinished = true;
            let status;
            if (response.aborted && !response.complete) {
              status = { code: api_1.SpanStatusCode.ERROR };
            } else {
              status = {
                code: utils.parseResponseStatus(api_1.SpanKind.CLIENT, response.statusCode)
              };
            }
            span.setStatus(status);
            if (this.getConfig().applyCustomAttributesOnSpan) {
              (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().applyCustomAttributesOnSpan(span, request, response), () => {
              }, true);
            }
            this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, metricAttributes);
          };
          response.on("end", endHandler);
          if (semver.lt(process.version, "16.0.0")) {
            response.on("close", endHandler);
          }
          response.on(events_1.errorMonitor, (error) => {
            this._diag.debug("outgoingRequest on error()", error);
            if (responseFinished) {
              return;
            }
            responseFinished = true;
            utils.setSpanWithError(span, error);
            span.setStatus({
              code: api_1.SpanStatusCode.ERROR,
              message: error.message
            });
            this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, metricAttributes);
          });
        });
        request.on("close", () => {
          this._diag.debug("outgoingRequest on request close()");
          if (request.aborted || responseFinished) {
            return;
          }
          responseFinished = true;
          this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, metricAttributes);
        });
        request.on(events_1.errorMonitor, (error) => {
          this._diag.debug("outgoingRequest on request error()", error);
          if (responseFinished) {
            return;
          }
          responseFinished = true;
          utils.setSpanWithError(span, error);
          this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, metricAttributes);
        });
        this._diag.debug("http.ClientRequest return request");
        return request;
      }
      _incomingRequestFunction(component, original) {
        const instrumentation = this;
        return function incomingRequest(event, ...args) {
          if (event !== "request") {
            return original.apply(this, [event, ...args]);
          }
          const request = args[0];
          const response = args[1];
          const pathname = request.url ? url.parse(request.url).pathname || "/" : "/";
          const method = request.method || "GET";
          instrumentation._diag.debug(`${component} instrumentation incomingRequest`);
          if (utils.isIgnored(pathname, instrumentation.getConfig().ignoreIncomingPaths, (e) => instrumentation._diag.error("caught ignoreIncomingPaths error: ", e)) || (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
            var _a2, _b;
            return (_b = (_a2 = instrumentation.getConfig()).ignoreIncomingRequestHook) === null || _b === void 0 ? void 0 : _b.call(_a2, request);
          }, (e) => {
            if (e != null) {
              instrumentation._diag.error("caught ignoreIncomingRequestHook error: ", e);
            }
          }, true)) {
            return api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => {
              api_1.context.bind(api_1.context.active(), request);
              api_1.context.bind(api_1.context.active(), response);
              return original.apply(this, [event, ...args]);
            });
          }
          const headers = request.headers;
          const spanAttributes = utils.getIncomingRequestAttributes(request, {
            component,
            serverName: instrumentation.getConfig().serverName,
            hookAttributes: instrumentation._callStartSpanHook(request, instrumentation.getConfig().startIncomingSpanHook)
          });
          const spanOptions = {
            kind: api_1.SpanKind.SERVER,
            attributes: spanAttributes
          };
          const startTime = (0, core_1.hrTime)();
          const metricAttributes = utils.getIncomingRequestMetricAttributes(spanAttributes);
          const ctx = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);
          const span = instrumentation._startHttpSpan(method, spanOptions, ctx);
          const rpcMetadata = {
            type: core_2.RPCType.HTTP,
            span
          };
          return api_1.context.with((0, core_2.setRPCMetadata)(api_1.trace.setSpan(ctx, span), rpcMetadata), () => {
            api_1.context.bind(api_1.context.active(), request);
            api_1.context.bind(api_1.context.active(), response);
            if (instrumentation.getConfig().requestHook) {
              instrumentation._callRequestHook(span, request);
            }
            if (instrumentation.getConfig().responseHook) {
              instrumentation._callResponseHook(span, response);
            }
            instrumentation._headerCapture.server.captureRequestHeaders(span, (header) => request.headers[header]);
            let hasError = false;
            response.on("close", () => {
              if (hasError) {
                return;
              }
              instrumentation._onServerResponseFinish(request, response, span, metricAttributes, startTime);
            });
            response.on(events_1.errorMonitor, (err) => {
              hasError = true;
              instrumentation._onServerResponseError(span, metricAttributes, startTime, err);
            });
            return (0, instrumentation_1.safeExecuteInTheMiddle)(() => original.apply(this, [event, ...args]), (error) => {
              if (error) {
                utils.setSpanWithError(span, error);
                instrumentation._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, metricAttributes);
                throw error;
              }
            });
          });
        };
      }
      _outgoingRequestFunction(component, original) {
        const instrumentation = this;
        return function outgoingRequest(options, ...args) {
          if (!utils.isValidOptionsType(options)) {
            return original.apply(this, [options, ...args]);
          }
          const extraOptions = typeof args[0] === "object" && (typeof options === "string" || options instanceof url.URL) ? args.shift() : void 0;
          const { origin, pathname, method, optionsParsed } = utils.getRequestInfo(options, extraOptions);
          if (component === "http" && semver.lt(process.version, "9.0.0") && optionsParsed.protocol === "https:") {
            return original.apply(this, [optionsParsed, ...args]);
          }
          if (utils.isIgnored(origin + pathname, instrumentation.getConfig().ignoreOutgoingUrls, (e) => instrumentation._diag.error("caught ignoreOutgoingUrls error: ", e)) || (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
            var _a2, _b;
            return (_b = (_a2 = instrumentation.getConfig()).ignoreOutgoingRequestHook) === null || _b === void 0 ? void 0 : _b.call(_a2, optionsParsed);
          }, (e) => {
            if (e != null) {
              instrumentation._diag.error("caught ignoreOutgoingRequestHook error: ", e);
            }
          }, true)) {
            return original.apply(this, [optionsParsed, ...args]);
          }
          const { hostname: hostname2, port } = utils.extractHostnameAndPort(optionsParsed);
          const attributes = utils.getOutgoingRequestAttributes(optionsParsed, {
            component,
            port,
            hostname: hostname2,
            hookAttributes: instrumentation._callStartSpanHook(optionsParsed, instrumentation.getConfig().startOutgoingSpanHook)
          });
          const startTime = (0, core_1.hrTime)();
          const metricAttributes = utils.getOutgoingRequestMetricAttributes(attributes);
          const spanOptions = {
            kind: api_1.SpanKind.CLIENT,
            attributes
          };
          const span = instrumentation._startHttpSpan(method, spanOptions);
          const parentContext = api_1.context.active();
          const requestContext = api_1.trace.setSpan(parentContext, span);
          if (!optionsParsed.headers) {
            optionsParsed.headers = {};
          } else {
            optionsParsed.headers = Object.assign({}, optionsParsed.headers);
          }
          api_1.propagation.inject(requestContext, optionsParsed.headers);
          return api_1.context.with(requestContext, () => {
            const cb = args[args.length - 1];
            if (typeof cb === "function") {
              args[args.length - 1] = api_1.context.bind(parentContext, cb);
            }
            const request = (0, instrumentation_1.safeExecuteInTheMiddle)(() => original.apply(this, [optionsParsed, ...args]), (error) => {
              if (error) {
                utils.setSpanWithError(span, error);
                instrumentation._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, metricAttributes);
                throw error;
              }
            });
            instrumentation._diag.debug(`${component} instrumentation outgoingRequest`);
            api_1.context.bind(parentContext, request);
            return instrumentation._traceClientRequest(request, span, startTime, metricAttributes);
          });
        };
      }
      _onServerResponseFinish(request, response, span, metricAttributes, startTime) {
        const attributes = utils.getIncomingRequestAttributesOnResponse(request, response);
        metricAttributes = Object.assign(metricAttributes, utils.getIncomingRequestMetricAttributesOnResponse(attributes));
        this._headerCapture.server.captureResponseHeaders(span, (header) => response.getHeader(header));
        span.setAttributes(attributes).setStatus({
          code: utils.parseResponseStatus(api_1.SpanKind.SERVER, response.statusCode)
        });
        const route = attributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];
        if (route) {
          span.updateName(`${request.method || "GET"} ${route}`);
        }
        if (this.getConfig().applyCustomAttributesOnSpan) {
          (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().applyCustomAttributesOnSpan(span, request, response), () => {
          }, true);
        }
        this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, metricAttributes);
      }
      _onServerResponseError(span, metricAttributes, startTime, error) {
        utils.setSpanWithError(span, error);
        this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, metricAttributes);
      }
      _startHttpSpan(name, options, ctx = api_1.context.active()) {
        const requireParent = options.kind === api_1.SpanKind.CLIENT ? this.getConfig().requireParentforOutgoingSpans : this.getConfig().requireParentforIncomingSpans;
        let span;
        const currentSpan = api_1.trace.getSpan(ctx);
        if (requireParent === true && currentSpan === void 0) {
          span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);
        } else if (requireParent === true && (currentSpan === null || currentSpan === void 0 ? void 0 : currentSpan.spanContext().isRemote)) {
          span = currentSpan;
        } else {
          span = this.tracer.startSpan(name, options, ctx);
        }
        this._spanNotEnded.add(span);
        return span;
      }
      _closeHttpSpan(span, spanKind, startTime, metricAttributes) {
        if (!this._spanNotEnded.has(span)) {
          return;
        }
        span.end();
        this._spanNotEnded.delete(span);
        const duration = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)()));
        if (spanKind === api_1.SpanKind.SERVER) {
          this._httpServerDurationHistogram.record(duration, metricAttributes);
        } else if (spanKind === api_1.SpanKind.CLIENT) {
          this._httpClientDurationHistogram.record(duration, metricAttributes);
        }
      }
      _callResponseHook(span, response) {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().responseHook(span, response), () => {
        }, true);
      }
      _callRequestHook(span, request) {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().requestHook(span, request), () => {
        }, true);
      }
      _callStartSpanHook(request, hookFunc) {
        if (typeof hookFunc === "function") {
          return (0, instrumentation_1.safeExecuteInTheMiddle)(() => hookFunc(request), () => {
          }, true);
        }
      }
      _createHeaderCapture() {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const config = this.getConfig();
        return {
          client: {
            captureRequestHeaders: utils.headerCapture("request", (_c = (_b = (_a2 = config.headersToSpanAttributes) === null || _a2 === void 0 ? void 0 : _a2.client) === null || _b === void 0 ? void 0 : _b.requestHeaders) !== null && _c !== void 0 ? _c : []),
            captureResponseHeaders: utils.headerCapture("response", (_f = (_e = (_d = config.headersToSpanAttributes) === null || _d === void 0 ? void 0 : _d.client) === null || _e === void 0 ? void 0 : _e.responseHeaders) !== null && _f !== void 0 ? _f : [])
          },
          server: {
            captureRequestHeaders: utils.headerCapture("request", (_j = (_h = (_g = config.headersToSpanAttributes) === null || _g === void 0 ? void 0 : _g.server) === null || _h === void 0 ? void 0 : _h.requestHeaders) !== null && _j !== void 0 ? _j : []),
            captureResponseHeaders: utils.headerCapture("response", (_m = (_l = (_k = config.headersToSpanAttributes) === null || _k === void 0 ? void 0 : _k.server) === null || _l === void 0 ? void 0 : _l.responseHeaders) !== null && _m !== void 0 ? _m : [])
          }
        };
      }
    };
    exports.HttpInstrumentation = HttpInstrumentation2;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-http/build/src/types.js
var require_types = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-http/build/src/types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@opentelemetry/instrumentation-http/build/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-http/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_http(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_utils(), exports);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/enums/ExpressLayerType.js
var require_ExpressLayerType = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-express/build/src/enums/ExpressLayerType.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExpressLayerType = void 0;
    var ExpressLayerType;
    (function(ExpressLayerType2) {
      ExpressLayerType2["ROUTER"] = "router";
      ExpressLayerType2["MIDDLEWARE"] = "middleware";
      ExpressLayerType2["REQUEST_HANDLER"] = "request_handler";
    })(ExpressLayerType = exports.ExpressLayerType || (exports.ExpressLayerType = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/enums/AttributeNames.js
var require_AttributeNames2 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-express/build/src/enums/AttributeNames.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeNames = void 0;
    var AttributeNames;
    (function(AttributeNames2) {
      AttributeNames2["EXPRESS_TYPE"] = "express.type";
      AttributeNames2["EXPRESS_NAME"] = "express.name";
    })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/internal-types.js
var require_internal_types = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-express/build/src/internal-types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._LAYERS_STORE_PROPERTY = exports.kLayerPatched = void 0;
    exports.kLayerPatched = Symbol("express-layer-patched");
    exports._LAYERS_STORE_PROPERTY = "__ot_middlewares";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-express/build/src/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLayerPath = exports.asErrorAndMessage = exports.isLayerIgnored = exports.getLayerMetadata = exports.storeLayerPath = void 0;
    var ExpressLayerType_1 = require_ExpressLayerType();
    var AttributeNames_1 = require_AttributeNames2();
    var internal_types_1 = require_internal_types();
    var storeLayerPath = (request, value) => {
      if (Array.isArray(request[internal_types_1._LAYERS_STORE_PROPERTY]) === false) {
        Object.defineProperty(request, internal_types_1._LAYERS_STORE_PROPERTY, {
          enumerable: false,
          value: []
        });
      }
      if (value === void 0)
        return;
      request[internal_types_1._LAYERS_STORE_PROPERTY].push(value);
    };
    exports.storeLayerPath = storeLayerPath;
    var getLayerMetadata = (layer, layerPath) => {
      if (layer.name === "router") {
        return {
          attributes: {
            [AttributeNames_1.AttributeNames.EXPRESS_NAME]: layerPath,
            [AttributeNames_1.AttributeNames.EXPRESS_TYPE]: ExpressLayerType_1.ExpressLayerType.ROUTER
          },
          name: `router - ${layerPath}`
        };
      } else if (layer.name === "bound dispatch") {
        return {
          attributes: {
            [AttributeNames_1.AttributeNames.EXPRESS_NAME]: layerPath !== null && layerPath !== void 0 ? layerPath : "request handler",
            [AttributeNames_1.AttributeNames.EXPRESS_TYPE]: ExpressLayerType_1.ExpressLayerType.REQUEST_HANDLER
          },
          name: `request handler${layer.path ? ` - ${layerPath}` : ""}`
        };
      } else {
        return {
          attributes: {
            [AttributeNames_1.AttributeNames.EXPRESS_NAME]: layer.name,
            [AttributeNames_1.AttributeNames.EXPRESS_TYPE]: ExpressLayerType_1.ExpressLayerType.MIDDLEWARE
          },
          name: `middleware - ${layer.name}`
        };
      }
    };
    exports.getLayerMetadata = getLayerMetadata;
    var satisfiesPattern = (constant, pattern) => {
      if (typeof pattern === "string") {
        return pattern === constant;
      } else if (pattern instanceof RegExp) {
        return pattern.test(constant);
      } else if (typeof pattern === "function") {
        return pattern(constant);
      } else {
        throw new TypeError("Pattern is in unsupported datatype");
      }
    };
    var isLayerIgnored = (name, type, config) => {
      var _a2;
      if (Array.isArray(config === null || config === void 0 ? void 0 : config.ignoreLayersType) && ((_a2 = config === null || config === void 0 ? void 0 : config.ignoreLayersType) === null || _a2 === void 0 ? void 0 : _a2.includes(type))) {
        return true;
      }
      if (Array.isArray(config === null || config === void 0 ? void 0 : config.ignoreLayers) === false)
        return false;
      try {
        for (const pattern of config.ignoreLayers) {
          if (satisfiesPattern(name, pattern)) {
            return true;
          }
        }
      } catch (e) {
      }
      return false;
    };
    exports.isLayerIgnored = isLayerIgnored;
    var asErrorAndMessage = (error) => error instanceof Error ? [error, error.message] : [String(error), String(error)];
    exports.asErrorAndMessage = asErrorAndMessage;
    var getLayerPath = (args) => {
      if (Array.isArray(args[0])) {
        return args[0].map((arg) => extractLayerPathSegment(arg) || "").join(",");
      }
      return extractLayerPathSegment(args[0]);
    };
    exports.getLayerPath = getLayerPath;
    var extractLayerPathSegment = (arg) => {
      if (typeof arg === "string") {
        return arg;
      }
      if (arg instanceof RegExp || typeof arg === "number") {
        return arg.toString();
      }
      return;
    };
  }
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/version.js
var require_version2 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-express/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.41.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-express";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/instrumentation.js
var require_instrumentation = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-express/build/src/instrumentation.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExpressInstrumentation = void 0;
    var core_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var ExpressLayerType_1 = require_ExpressLayerType();
    var AttributeNames_1 = require_AttributeNames2();
    var utils_1 = require_utils2();
    var version_1 = require_version2();
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var internal_types_1 = require_internal_types();
    var ExpressInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      }
      setConfig(config = {}) {
        this._config = Object.assign({}, config);
      }
      getConfig() {
        return this._config;
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("express", [">=4.0.0 <5"], (moduleExports) => {
            const routerProto = moduleExports.Router;
            if ((0, instrumentation_1.isWrapped)(routerProto.route)) {
              this._unwrap(routerProto, "route");
            }
            this._wrap(routerProto, "route", this._getRoutePatch());
            if ((0, instrumentation_1.isWrapped)(routerProto.use)) {
              this._unwrap(routerProto, "use");
            }
            this._wrap(routerProto, "use", this._getRouterUsePatch());
            if ((0, instrumentation_1.isWrapped)(moduleExports.application.use)) {
              this._unwrap(moduleExports.application, "use");
            }
            this._wrap(
              moduleExports.application,
              "use",
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              this._getAppUsePatch()
            );
            return moduleExports;
          }, (moduleExports) => {
            if (moduleExports === void 0)
              return;
            const routerProto = moduleExports.Router;
            this._unwrap(routerProto, "route");
            this._unwrap(routerProto, "use");
            this._unwrap(moduleExports.application, "use");
          })
        ];
      }
      /**
       * Get the patch for Router.route function
       */
      _getRoutePatch() {
        const instrumentation = this;
        return function(original) {
          return function route_trace(...args) {
            const route = original.apply(this, args);
            const layer = this.stack[this.stack.length - 1];
            instrumentation._applyPatch(layer, (0, utils_1.getLayerPath)(args));
            return route;
          };
        };
      }
      /**
       * Get the patch for Router.use function
       */
      _getRouterUsePatch() {
        const instrumentation = this;
        return function(original) {
          return function use(...args) {
            const route = original.apply(this, args);
            const layer = this.stack[this.stack.length - 1];
            instrumentation._applyPatch(layer, (0, utils_1.getLayerPath)(args));
            return route;
          };
        };
      }
      /**
       * Get the patch for Application.use function
       */
      _getAppUsePatch() {
        const instrumentation = this;
        return function(original) {
          return function use(...args) {
            const route = original.apply(this, args);
            const layer = this._router.stack[this._router.stack.length - 1];
            instrumentation._applyPatch(layer, (0, utils_1.getLayerPath)(args));
            return route;
          };
        };
      }
      /** Patch each express layer to create span and propagate context */
      _applyPatch(layer, layerPath) {
        const instrumentation = this;
        if (layer[internal_types_1.kLayerPatched] === true)
          return;
        layer[internal_types_1.kLayerPatched] = true;
        this._wrap(layer, "handle", (original) => {
          if (original.length === 4)
            return original;
          const patched = function(req, res) {
            (0, utils_1.storeLayerPath)(req, layerPath);
            const route = req[internal_types_1._LAYERS_STORE_PROPERTY].filter((path3) => path3 !== "/" && path3 !== "/*").join("").replace(/\/{2,}/g, "/");
            const attributes = {
              [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: route.length > 0 ? route : "/"
            };
            const metadata = (0, utils_1.getLayerMetadata)(layer, layerPath);
            const type = metadata.attributes[AttributeNames_1.AttributeNames.EXPRESS_TYPE];
            const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
            if ((rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP) {
              rpcMetadata.route = route || "/";
            }
            if ((0, utils_1.isLayerIgnored)(metadata.name, type, instrumentation._config)) {
              if (type === ExpressLayerType_1.ExpressLayerType.MIDDLEWARE) {
                req[internal_types_1._LAYERS_STORE_PROPERTY].pop();
              }
              return original.apply(this, arguments);
            }
            if (api_1.trace.getSpan(api_1.context.active()) === void 0) {
              return original.apply(this, arguments);
            }
            const spanName = instrumentation._getSpanName({
              request: req,
              layerType: type,
              route
            }, metadata.name);
            const span = instrumentation.tracer.startSpan(spanName, {
              attributes: Object.assign(attributes, metadata.attributes)
            });
            if (instrumentation.getConfig().requestHook) {
              (0, instrumentation_1.safeExecuteInTheMiddle)(() => instrumentation.getConfig().requestHook(span, {
                request: req,
                layerType: type,
                route
              }), (e) => {
                if (e) {
                  api_1.diag.error("express instrumentation: request hook failed", e);
                }
              }, true);
            }
            let spanHasEnded = false;
            if (metadata.attributes[AttributeNames_1.AttributeNames.EXPRESS_TYPE] !== ExpressLayerType_1.ExpressLayerType.MIDDLEWARE) {
              span.end();
              spanHasEnded = true;
            }
            const onResponseFinish = () => {
              if (spanHasEnded === false) {
                spanHasEnded = true;
                span.end();
              }
            };
            const args = Array.from(arguments);
            const callbackIdx = args.findIndex((arg) => typeof arg === "function");
            if (callbackIdx >= 0) {
              arguments[callbackIdx] = function() {
                var _a2;
                const maybeError = arguments[0];
                const isError = ![void 0, null, "route", "router"].includes(maybeError);
                if (!spanHasEnded && isError) {
                  const [error, message] = (0, utils_1.asErrorAndMessage)(maybeError);
                  span.recordException(error);
                  span.setStatus({
                    code: api_1.SpanStatusCode.ERROR,
                    message
                  });
                }
                if (spanHasEnded === false) {
                  spanHasEnded = true;
                  (_a2 = req.res) === null || _a2 === void 0 ? void 0 : _a2.removeListener("finish", onResponseFinish);
                  span.end();
                }
                if (!(req.route && isError)) {
                  req[internal_types_1._LAYERS_STORE_PROPERTY].pop();
                }
                const callback = args[callbackIdx];
                return callback.apply(this, arguments);
              };
            }
            try {
              return original.apply(this, arguments);
            } catch (anyError) {
              const [error, message] = (0, utils_1.asErrorAndMessage)(anyError);
              span.recordException(error);
              span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message
              });
              throw anyError;
            } finally {
              if (!spanHasEnded) {
                res.once("finish", onResponseFinish);
              }
            }
          };
          Object.keys(original).forEach((key) => {
            Object.defineProperty(patched, key, {
              get() {
                return original[key];
              },
              set(value) {
                original[key] = value;
              }
            });
          });
          return patched;
        });
      }
      _getSpanName(info, defaultName) {
        var _a2;
        const hook = this.getConfig().spanNameHook;
        if (!(hook instanceof Function)) {
          return defaultName;
        }
        try {
          return (_a2 = hook(info, defaultName)) !== null && _a2 !== void 0 ? _a2 : defaultName;
        } catch (err) {
          api_1.diag.error("express instrumentation: error calling span name rewrite hook", err);
          return defaultName;
        }
      }
    };
    exports.ExpressInstrumentation = ExpressInstrumentation2;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/types.js
var require_types2 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-express/build/src/types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@opentelemetry/instrumentation-express/build/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-express/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_instrumentation(), exports);
    __exportStar(require_ExpressLayerType(), exports);
    __exportStar(require_AttributeNames2(), exports);
    __exportStar(require_types2(), exports);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-fastify/build/src/enums/AttributeNames.js
var require_AttributeNames3 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-fastify/build/src/enums/AttributeNames.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FastifyNames = exports.FastifyTypes = exports.AttributeNames = void 0;
    var AttributeNames;
    (function(AttributeNames2) {
      AttributeNames2["FASTIFY_NAME"] = "fastify.name";
      AttributeNames2["FASTIFY_TYPE"] = "fastify.type";
      AttributeNames2["HOOK_NAME"] = "hook.name";
      AttributeNames2["PLUGIN_NAME"] = "plugin.name";
    })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
    var FastifyTypes;
    (function(FastifyTypes2) {
      FastifyTypes2["MIDDLEWARE"] = "middleware";
      FastifyTypes2["REQUEST_HANDLER"] = "request_handler";
    })(FastifyTypes = exports.FastifyTypes || (exports.FastifyTypes = {}));
    var FastifyNames;
    (function(FastifyNames2) {
      FastifyNames2["MIDDLEWARE"] = "middleware";
      FastifyNames2["REQUEST_HANDLER"] = "request handler";
    })(FastifyNames = exports.FastifyNames || (exports.FastifyNames = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-fastify/build/src/types.js
var require_types3 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-fastify/build/src/types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@opentelemetry/instrumentation-fastify/build/src/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-fastify/build/src/constants.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hooksNamesToWrap = exports.spanRequestSymbol = void 0;
    exports.spanRequestSymbol = Symbol("opentelemetry.instrumentation.fastify.request_active_span");
    exports.hooksNamesToWrap = /* @__PURE__ */ new Set([
      "onTimeout",
      "onRequest",
      "preParsing",
      "preValidation",
      "preSerialization",
      "preHandler",
      "onSend",
      "onResponse",
      "onError"
    ]);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-fastify/build/src/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-fastify/build/src/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeExecuteInTheMiddleMaybePromise = exports.endSpan = exports.startSpan = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var constants_1 = require_constants2();
    function startSpan2(reply, tracer, spanName, spanAttributes = {}) {
      const span = tracer.startSpan(spanName, { attributes: spanAttributes });
      const spans = reply[constants_1.spanRequestSymbol] || [];
      spans.push(span);
      Object.defineProperty(reply, constants_1.spanRequestSymbol, {
        enumerable: false,
        configurable: true,
        value: spans
      });
      return span;
    }
    exports.startSpan = startSpan2;
    function endSpan(reply, err) {
      const spans = reply[constants_1.spanRequestSymbol] || [];
      if (!spans.length) {
        return;
      }
      spans.forEach((span) => {
        if (err) {
          span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: err.message
          });
          span.recordException(err);
        }
        span.end();
      });
      delete reply[constants_1.spanRequestSymbol];
    }
    exports.endSpan = endSpan;
    function safeExecuteInTheMiddleMaybePromise(execute, onFinish, preventThrowingError) {
      let error;
      let result = void 0;
      try {
        result = execute();
        if (isPromise(result)) {
          result.then((res) => onFinish(void 0, res), (err) => onFinish(err));
        }
      } catch (e) {
        error = e;
      } finally {
        if (!isPromise(result)) {
          onFinish(error, result);
          if (error && !preventThrowingError) {
            throw error;
          }
        }
        return result;
      }
    }
    exports.safeExecuteInTheMiddleMaybePromise = safeExecuteInTheMiddleMaybePromise;
    function isPromise(val) {
      var _a2;
      return typeof val === "object" && val && typeof ((_a2 = Object.getOwnPropertyDescriptor(val, "then")) === null || _a2 === void 0 ? void 0 : _a2.value) === "function" || false;
    }
  }
});

// ../../node_modules/@opentelemetry/instrumentation-fastify/build/src/version.js
var require_version3 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-fastify/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.38.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-fastify";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-fastify/build/src/instrumentation.js
var require_instrumentation2 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-fastify/build/src/instrumentation.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FastifyInstrumentation = exports.ANONYMOUS_NAME = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var constants_1 = require_constants2();
    var AttributeNames_1 = require_AttributeNames3();
    var utils_1 = require_utils3();
    var version_1 = require_version3();
    exports.ANONYMOUS_NAME = "anonymous";
    var FastifyInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      }
      setConfig(config = {}) {
        this._config = Object.assign({}, config);
      }
      getConfig() {
        return this._config;
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("fastify", [">=3.0.0 <5"], (moduleExports) => {
            return this._patchConstructor(moduleExports);
          })
        ];
      }
      _hookOnRequest() {
        const instrumentation = this;
        return function onRequest(request, reply, done) {
          if (!instrumentation.isEnabled()) {
            return done();
          }
          instrumentation._wrap(reply, "send", instrumentation._patchSend());
          const anyRequest = request;
          const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
          const routeName = anyRequest.routeOptions ? anyRequest.routeOptions.url : request.routerPath;
          if (routeName && (rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP) {
            rpcMetadata.route = routeName;
          }
          done();
        };
      }
      _wrapHandler(pluginName, hookName, original, syncFunctionWithDone) {
        const instrumentation = this;
        this._diag.debug("Patching fastify route.handler function");
        return function(...args) {
          if (!instrumentation.isEnabled()) {
            return original.apply(this, args);
          }
          const name = original.name || pluginName || exports.ANONYMOUS_NAME;
          const spanName = `${AttributeNames_1.FastifyNames.MIDDLEWARE} - ${name}`;
          const reply = args[1];
          const span = (0, utils_1.startSpan)(reply, instrumentation.tracer, spanName, {
            [AttributeNames_1.AttributeNames.FASTIFY_TYPE]: AttributeNames_1.FastifyTypes.MIDDLEWARE,
            [AttributeNames_1.AttributeNames.PLUGIN_NAME]: pluginName,
            [AttributeNames_1.AttributeNames.HOOK_NAME]: hookName
          });
          const origDone = syncFunctionWithDone && args[args.length - 1];
          if (origDone) {
            args[args.length - 1] = function(...doneArgs) {
              (0, utils_1.endSpan)(reply);
              origDone.apply(this, doneArgs);
            };
          }
          return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
            return (0, utils_1.safeExecuteInTheMiddleMaybePromise)(() => {
              return original.apply(this, args);
            }, (err) => {
              if (err instanceof Error) {
                span.setStatus({
                  code: api_1.SpanStatusCode.ERROR,
                  message: err.message
                });
                span.recordException(err);
              }
              if (!syncFunctionWithDone) {
                (0, utils_1.endSpan)(reply);
              }
            });
          });
        };
      }
      _wrapAddHook() {
        const instrumentation = this;
        this._diag.debug("Patching fastify server.addHook function");
        return function(original) {
          return function wrappedAddHook(...args) {
            const name = args[0];
            const handler = args[1];
            const pluginName = this.pluginName;
            if (!constants_1.hooksNamesToWrap.has(name)) {
              return original.apply(this, args);
            }
            const syncFunctionWithDone = typeof args[args.length - 1] === "function" && handler.constructor.name !== "AsyncFunction";
            return original.apply(this, [
              name,
              instrumentation._wrapHandler(pluginName, name, handler, syncFunctionWithDone)
            ]);
          };
        };
      }
      _patchConstructor(moduleExports) {
        const instrumentation = this;
        function fastify(...args) {
          const app = moduleExports.fastify.apply(this, args);
          app.addHook("onRequest", instrumentation._hookOnRequest());
          app.addHook("preHandler", instrumentation._hookPreHandler());
          instrumentation._wrap(app, "addHook", instrumentation._wrapAddHook());
          return app;
        }
        fastify.fastify = fastify;
        fastify.default = fastify;
        return fastify;
      }
      _patchSend() {
        const instrumentation = this;
        this._diag.debug("Patching fastify reply.send function");
        return function patchSend(original) {
          return function send(...args) {
            const maybeError = args[0];
            if (!instrumentation.isEnabled()) {
              return original.apply(this, args);
            }
            return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
              return original.apply(this, args);
            }, (err) => {
              if (!err && maybeError instanceof Error) {
                err = maybeError;
              }
              (0, utils_1.endSpan)(this, err);
            });
          };
        };
      }
      _hookPreHandler() {
        const instrumentation = this;
        this._diag.debug("Patching fastify preHandler function");
        return function preHandler(request, reply, done) {
          var _a2, _b;
          if (!instrumentation.isEnabled()) {
            return done();
          }
          const anyRequest = request;
          const handler = ((_a2 = anyRequest.routeOptions) === null || _a2 === void 0 ? void 0 : _a2.handler) || ((_b = anyRequest.context) === null || _b === void 0 ? void 0 : _b.handler);
          const handlerName = (handler === null || handler === void 0 ? void 0 : handler.name.startsWith("bound ")) ? handler.name.substr(6) : handler === null || handler === void 0 ? void 0 : handler.name;
          const spanName = `${AttributeNames_1.FastifyNames.REQUEST_HANDLER} - ${handlerName || this.pluginName || exports.ANONYMOUS_NAME}`;
          const spanAttributes = {
            [AttributeNames_1.AttributeNames.PLUGIN_NAME]: this.pluginName,
            [AttributeNames_1.AttributeNames.FASTIFY_TYPE]: AttributeNames_1.FastifyTypes.REQUEST_HANDLER,
            [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: anyRequest.routeOptions ? anyRequest.routeOptions.url : request.routerPath
          };
          if (handlerName) {
            spanAttributes[AttributeNames_1.AttributeNames.FASTIFY_NAME] = handlerName;
          }
          const span = (0, utils_1.startSpan)(reply, instrumentation.tracer, spanName, spanAttributes);
          if (instrumentation.getConfig().requestHook) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => instrumentation.getConfig().requestHook(span, { request }), (e) => {
              if (e) {
                instrumentation._diag.error("request hook failed", e);
              }
            }, true);
          }
          return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
            done();
          });
        };
      }
    };
    exports.FastifyInstrumentation = FastifyInstrumentation2;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-fastify/build/src/index.js
var require_src4 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-fastify/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_AttributeNames3(), exports);
    __exportStar(require_types3(), exports);
    __exportStar(require_instrumentation2(), exports);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/enum.js
var require_enum = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-graphql/build/src/enum.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpanNames = exports.TokenKind = exports.AllowedOperationTypes = void 0;
    var AllowedOperationTypes;
    (function(AllowedOperationTypes2) {
      AllowedOperationTypes2["QUERY"] = "query";
      AllowedOperationTypes2["MUTATION"] = "mutation";
      AllowedOperationTypes2["SUBSCRIPTION"] = "subscription";
    })(AllowedOperationTypes = exports.AllowedOperationTypes || (exports.AllowedOperationTypes = {}));
    var TokenKind;
    (function(TokenKind2) {
      TokenKind2["SOF"] = "<SOF>";
      TokenKind2["EOF"] = "<EOF>";
      TokenKind2["BANG"] = "!";
      TokenKind2["DOLLAR"] = "$";
      TokenKind2["AMP"] = "&";
      TokenKind2["PAREN_L"] = "(";
      TokenKind2["PAREN_R"] = ")";
      TokenKind2["SPREAD"] = "...";
      TokenKind2["COLON"] = ":";
      TokenKind2["EQUALS"] = "=";
      TokenKind2["AT"] = "@";
      TokenKind2["BRACKET_L"] = "[";
      TokenKind2["BRACKET_R"] = "]";
      TokenKind2["BRACE_L"] = "{";
      TokenKind2["PIPE"] = "|";
      TokenKind2["BRACE_R"] = "}";
      TokenKind2["NAME"] = "Name";
      TokenKind2["INT"] = "Int";
      TokenKind2["FLOAT"] = "Float";
      TokenKind2["STRING"] = "String";
      TokenKind2["BLOCK_STRING"] = "BlockString";
      TokenKind2["COMMENT"] = "Comment";
    })(TokenKind = exports.TokenKind || (exports.TokenKind = {}));
    var SpanNames;
    (function(SpanNames2) {
      SpanNames2["EXECUTE"] = "graphql.execute";
      SpanNames2["PARSE"] = "graphql.parse";
      SpanNames2["RESOLVE"] = "graphql.resolve";
      SpanNames2["VALIDATE"] = "graphql.validate";
      SpanNames2["SCHEMA_VALIDATE"] = "graphql.validateSchema";
      SpanNames2["SCHEMA_PARSE"] = "graphql.parseSchema";
    })(SpanNames = exports.SpanNames || (exports.SpanNames = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/enums/AttributeNames.js
var require_AttributeNames4 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-graphql/build/src/enums/AttributeNames.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeNames = void 0;
    var AttributeNames;
    (function(AttributeNames2) {
      AttributeNames2["SOURCE"] = "graphql.source";
      AttributeNames2["FIELD_NAME"] = "graphql.field.name";
      AttributeNames2["FIELD_PATH"] = "graphql.field.path";
      AttributeNames2["FIELD_TYPE"] = "graphql.field.type";
      AttributeNames2["OPERATION_TYPE"] = "graphql.operation.type";
      AttributeNames2["OPERATION_NAME"] = "graphql.operation.name";
      AttributeNames2["VARIABLES"] = "graphql.variables.";
      AttributeNames2["ERROR_VALIDATION_NAME"] = "graphql.validation.error";
    })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/symbols.js
var require_symbols = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-graphql/build/src/symbols.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OTEL_GRAPHQL_DATA_SYMBOL = exports.OTEL_PATCHED_SYMBOL = void 0;
    exports.OTEL_PATCHED_SYMBOL = Symbol.for("opentelemetry.patched");
    exports.OTEL_GRAPHQL_DATA_SYMBOL = Symbol.for("opentelemetry.graphql_data");
  }
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/internal-types.js
var require_internal_types2 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-graphql/build/src/internal-types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OPERATION_NOT_SUPPORTED = void 0;
    var symbols_1 = require_symbols();
    exports.OPERATION_NOT_SUPPORTED = "Operation$operationName$not supported";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-graphql/build/src/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapFieldResolver = exports.wrapFields = exports.getSourceFromLocation = exports.getOperation = exports.endSpan = exports.addSpanSource = exports.addInputVariableAttributes = exports.isPromise = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var enum_1 = require_enum();
    var AttributeNames_1 = require_AttributeNames4();
    var symbols_1 = require_symbols();
    var OPERATION_VALUES = Object.values(enum_1.AllowedOperationTypes);
    var isPromise = (value) => {
      return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
    };
    exports.isPromise = isPromise;
    var isObjectLike2 = (value) => {
      return typeof value == "object" && value !== null;
    };
    function addInputVariableAttribute(span, key, variable) {
      if (Array.isArray(variable)) {
        variable.forEach((value, idx) => {
          addInputVariableAttribute(span, `${key}.${idx}`, value);
        });
      } else if (variable instanceof Object) {
        Object.entries(variable).forEach(([nestedKey, value]) => {
          addInputVariableAttribute(span, `${key}.${nestedKey}`, value);
        });
      } else {
        span.setAttribute(`${AttributeNames_1.AttributeNames.VARIABLES}${String(key)}`, variable);
      }
    }
    function addInputVariableAttributes(span, variableValues) {
      Object.entries(variableValues).forEach(([key, value]) => {
        addInputVariableAttribute(span, key, value);
      });
    }
    exports.addInputVariableAttributes = addInputVariableAttributes;
    function addSpanSource(span, loc, allowValues, start, end) {
      const source = getSourceFromLocation(loc, allowValues, start, end);
      span.setAttribute(AttributeNames_1.AttributeNames.SOURCE, source);
    }
    exports.addSpanSource = addSpanSource;
    function createFieldIfNotExists(tracer, getConfig, contextValue, info, path3) {
      let field = getField(contextValue, path3);
      let spanAdded = false;
      if (!field) {
        spanAdded = true;
        const parent = getParentField(contextValue, path3);
        field = {
          parent,
          span: createResolverSpan(tracer, getConfig, contextValue, info, path3, parent.span),
          error: null
        };
        addField(contextValue, path3, field);
      }
      return { spanAdded, field };
    }
    function createResolverSpan(tracer, getConfig, contextValue, info, path3, parentSpan) {
      var _a2, _b;
      const attributes = {
        [AttributeNames_1.AttributeNames.FIELD_NAME]: info.fieldName,
        [AttributeNames_1.AttributeNames.FIELD_PATH]: path3.join("."),
        [AttributeNames_1.AttributeNames.FIELD_TYPE]: info.returnType.toString()
      };
      const span = tracer.startSpan(`${enum_1.SpanNames.RESOLVE} ${attributes[AttributeNames_1.AttributeNames.FIELD_PATH]}`, {
        attributes
      }, parentSpan ? api.trace.setSpan(api.context.active(), parentSpan) : void 0);
      const document = contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].source;
      const fieldNode = info.fieldNodes.find((fieldNode2) => fieldNode2.kind === "Field");
      if (fieldNode) {
        addSpanSource(span, document.loc, getConfig().allowValues, (_a2 = fieldNode.loc) === null || _a2 === void 0 ? void 0 : _a2.start, (_b = fieldNode.loc) === null || _b === void 0 ? void 0 : _b.end);
      }
      return span;
    }
    function endSpan(span, error) {
      if (error) {
        span.recordException(error);
      }
      span.end();
    }
    exports.endSpan = endSpan;
    function getOperation(document, operationName) {
      if (!document || !Array.isArray(document.definitions)) {
        return void 0;
      }
      if (operationName) {
        return document.definitions.filter((definition) => {
          var _a2;
          return OPERATION_VALUES.indexOf((_a2 = definition) === null || _a2 === void 0 ? void 0 : _a2.operation) !== -1;
        }).find((definition) => {
          var _a2, _b;
          return operationName === ((_b = (_a2 = definition) === null || _a2 === void 0 ? void 0 : _a2.name) === null || _b === void 0 ? void 0 : _b.value);
        });
      } else {
        return document.definitions.find((definition) => {
          var _a2;
          return OPERATION_VALUES.indexOf((_a2 = definition) === null || _a2 === void 0 ? void 0 : _a2.operation) !== -1;
        });
      }
    }
    exports.getOperation = getOperation;
    function addField(contextValue, path3, field) {
      return contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].fields[path3.join(".")] = field;
    }
    function getField(contextValue, path3) {
      return contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].fields[path3.join(".")];
    }
    function getParentField(contextValue, path3) {
      for (let i = path3.length - 1; i > 0; i--) {
        const field = getField(contextValue, path3.slice(0, i));
        if (field) {
          return field;
        }
      }
      return {
        span: contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL].span
      };
    }
    function pathToArray(mergeItems, path3) {
      const flattened = [];
      let curr = path3;
      while (curr) {
        let key = curr.key;
        if (mergeItems && typeof key === "number") {
          key = "*";
        }
        flattened.push(String(key));
        curr = curr.prev;
      }
      return flattened.reverse();
    }
    function repeatBreak(i) {
      return repeatChar("\n", i);
    }
    function repeatSpace(i) {
      return repeatChar(" ", i);
    }
    function repeatChar(char, to) {
      let text = "";
      for (let i = 0; i < to; i++) {
        text += char;
      }
      return text;
    }
    var KindsToBeRemoved = [
      enum_1.TokenKind.FLOAT,
      enum_1.TokenKind.STRING,
      enum_1.TokenKind.INT,
      enum_1.TokenKind.BLOCK_STRING
    ];
    function getSourceFromLocation(loc, allowValues = false, inputStart, inputEnd) {
      var _a2, _b;
      let source = "";
      if (loc === null || loc === void 0 ? void 0 : loc.startToken) {
        const start = typeof inputStart === "number" ? inputStart : loc.start;
        const end = typeof inputEnd === "number" ? inputEnd : loc.end;
        let next = loc.startToken.next;
        let previousLine = 1;
        while (next) {
          if (next.start < start) {
            next = next.next;
            previousLine = next === null || next === void 0 ? void 0 : next.line;
            continue;
          }
          if (next.end > end) {
            next = next.next;
            previousLine = next === null || next === void 0 ? void 0 : next.line;
            continue;
          }
          let value = next.value || next.kind;
          let space = "";
          if (!allowValues && KindsToBeRemoved.indexOf(next.kind) >= 0) {
            value = "*";
          }
          if (next.kind === enum_1.TokenKind.STRING) {
            value = `"${value}"`;
          }
          if (next.kind === enum_1.TokenKind.EOF) {
            value = "";
          }
          if (next.line > previousLine) {
            source += repeatBreak(next.line - previousLine);
            previousLine = next.line;
            space = repeatSpace(next.column - 1);
          } else {
            if (next.line === ((_a2 = next.prev) === null || _a2 === void 0 ? void 0 : _a2.line)) {
              space = repeatSpace(next.start - (((_b = next.prev) === null || _b === void 0 ? void 0 : _b.end) || 0));
            }
          }
          source += space + value;
          if (next) {
            next = next.next;
          }
        }
      }
      return source;
    }
    exports.getSourceFromLocation = getSourceFromLocation;
    function wrapFields(type, tracer, getConfig) {
      if (!type || typeof type.getFields !== "function" || type[symbols_1.OTEL_PATCHED_SYMBOL]) {
        return;
      }
      const fields3 = type.getFields();
      type[symbols_1.OTEL_PATCHED_SYMBOL] = true;
      Object.keys(fields3).forEach((key) => {
        const field = fields3[key];
        if (!field) {
          return;
        }
        if (field.resolve) {
          field.resolve = wrapFieldResolver(tracer, getConfig, field.resolve);
        }
        if (field.type) {
          let unwrappedType = field.type;
          while (unwrappedType.ofType) {
            unwrappedType = unwrappedType.ofType;
          }
          wrapFields(unwrappedType, tracer, getConfig);
        }
      });
    }
    exports.wrapFields = wrapFields;
    var handleResolveSpanError = (resolveSpan, err, shouldEndSpan) => {
      if (!shouldEndSpan) {
        return;
      }
      resolveSpan.recordException(err);
      resolveSpan.setStatus({
        code: api.SpanStatusCode.ERROR,
        message: err.message
      });
      resolveSpan.end();
    };
    var handleResolveSpanSuccess = (resolveSpan, shouldEndSpan) => {
      if (!shouldEndSpan) {
        return;
      }
      resolveSpan.end();
    };
    function wrapFieldResolver(tracer, getConfig, fieldResolver, isDefaultResolver = false) {
      if (wrappedFieldResolver[symbols_1.OTEL_PATCHED_SYMBOL] || typeof fieldResolver !== "function") {
        return fieldResolver;
      }
      function wrappedFieldResolver(source, args, contextValue, info) {
        if (!fieldResolver) {
          return void 0;
        }
        const config = getConfig();
        if (config.ignoreTrivialResolveSpans && isDefaultResolver && (isObjectLike2(source) || typeof source === "function")) {
          const property = source[info.fieldName];
          if (typeof property !== "function") {
            return fieldResolver.call(this, source, args, contextValue, info);
          }
        }
        if (!contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL]) {
          return fieldResolver.call(this, source, args, contextValue, info);
        }
        const path3 = pathToArray(config.mergeItems, info && info.path);
        const depth = path3.filter((item) => typeof item === "string").length;
        let field;
        let shouldEndSpan = false;
        if (config.depth >= 0 && config.depth < depth) {
          field = getParentField(contextValue, path3);
        } else {
          const newField = createFieldIfNotExists(tracer, getConfig, contextValue, info, path3);
          field = newField.field;
          shouldEndSpan = newField.spanAdded;
        }
        return api.context.with(api.trace.setSpan(api.context.active(), field.span), () => {
          try {
            const res = fieldResolver.call(this, source, args, contextValue, info);
            if ((0, exports.isPromise)(res)) {
              return res.then((r) => {
                handleResolveSpanSuccess(field.span, shouldEndSpan);
                return r;
              }, (err) => {
                handleResolveSpanError(field.span, err, shouldEndSpan);
                throw err;
              });
            } else {
              handleResolveSpanSuccess(field.span, shouldEndSpan);
              return res;
            }
          } catch (err) {
            handleResolveSpanError(field.span, err, shouldEndSpan);
            throw err;
          }
        });
      }
      wrappedFieldResolver[symbols_1.OTEL_PATCHED_SYMBOL] = true;
      return wrappedFieldResolver;
    }
    exports.wrapFieldResolver = wrapFieldResolver;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/version.js
var require_version4 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-graphql/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.42.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-graphql";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/instrumentation.js
var require_instrumentation3 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-graphql/build/src/instrumentation.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GraphQLInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var enum_1 = require_enum();
    var AttributeNames_1 = require_AttributeNames4();
    var symbols_1 = require_symbols();
    var internal_types_1 = require_internal_types2();
    var utils_1 = require_utils4();
    var version_1 = require_version4();
    var DEFAULT_CONFIG = {
      mergeItems: false,
      depth: -1,
      allowValues: false,
      ignoreResolveSpans: false
    };
    var supportedVersions = [">=14.0.0 <17"];
    var GraphQLInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign({}, DEFAULT_CONFIG, config));
      }
      _getConfig() {
        return this._config;
      }
      setConfig(config = {}) {
        this._config = Object.assign({}, DEFAULT_CONFIG, config);
      }
      init() {
        const module3 = new instrumentation_1.InstrumentationNodeModuleDefinition("graphql", supportedVersions);
        module3.files.push(this._addPatchingExecute());
        module3.files.push(this._addPatchingParser());
        module3.files.push(this._addPatchingValidate());
        return module3;
      }
      _addPatchingExecute() {
        return new instrumentation_1.InstrumentationNodeModuleFile(
          "graphql/execution/execute.js",
          supportedVersions,
          // cannot make it work with appropriate type as execute function has 2
          //types and/cannot import function but only types
          (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.execute)) {
              this._unwrap(moduleExports, "execute");
            }
            this._wrap(moduleExports, "execute", this._patchExecute(moduleExports.defaultFieldResolver));
            return moduleExports;
          },
          (moduleExports) => {
            if (moduleExports) {
              this._unwrap(moduleExports, "execute");
            }
          }
        );
      }
      _addPatchingParser() {
        return new instrumentation_1.InstrumentationNodeModuleFile("graphql/language/parser.js", supportedVersions, (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.parse)) {
            this._unwrap(moduleExports, "parse");
          }
          this._wrap(moduleExports, "parse", this._patchParse());
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports) {
            this._unwrap(moduleExports, "parse");
          }
        });
      }
      _addPatchingValidate() {
        return new instrumentation_1.InstrumentationNodeModuleFile("graphql/validation/validate.js", supportedVersions, (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.validate)) {
            this._unwrap(moduleExports, "validate");
          }
          this._wrap(moduleExports, "validate", this._patchValidate());
          return moduleExports;
        }, (moduleExports) => {
          if (moduleExports) {
            this._unwrap(moduleExports, "validate");
          }
        });
      }
      _patchExecute(defaultFieldResolved) {
        const instrumentation = this;
        return function execute(original) {
          return function patchExecute() {
            let processedArgs;
            if (arguments.length >= 2) {
              const args = arguments;
              processedArgs = instrumentation._wrapExecuteArgs(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], defaultFieldResolved);
            } else {
              const args = arguments[0];
              processedArgs = instrumentation._wrapExecuteArgs(args.schema, args.document, args.rootValue, args.contextValue, args.variableValues, args.operationName, args.fieldResolver, args.typeResolver, defaultFieldResolved);
            }
            const operation = (0, utils_1.getOperation)(processedArgs.document, processedArgs.operationName);
            const span = instrumentation._createExecuteSpan(operation, processedArgs);
            processedArgs.contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL] = {
              source: processedArgs.document ? processedArgs.document || processedArgs.document[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL] : void 0,
              span,
              fields: {}
            };
            return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
              return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
                return original.apply(this, [
                  processedArgs
                ]);
              }, (err, result) => {
                instrumentation._handleExecutionResult(span, err, result);
              });
            });
          };
        };
      }
      _handleExecutionResult(span, err, result) {
        const config = this._getConfig();
        if (result === void 0 || err) {
          (0, utils_1.endSpan)(span, err);
          return;
        }
        if ((0, utils_1.isPromise)(result)) {
          result.then((resultData) => {
            if (typeof config.responseHook !== "function") {
              (0, utils_1.endSpan)(span);
              return;
            }
            this._executeResponseHook(span, resultData);
          }, (error) => {
            (0, utils_1.endSpan)(span, error);
          });
        } else {
          if (typeof config.responseHook !== "function") {
            (0, utils_1.endSpan)(span);
            return;
          }
          this._executeResponseHook(span, result);
        }
      }
      _executeResponseHook(span, result) {
        const config = this._getConfig();
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          config.responseHook(span, result);
        }, (err) => {
          if (err) {
            this._diag.error("Error running response hook", err);
          }
          (0, utils_1.endSpan)(span, void 0);
        }, true);
      }
      _patchParse() {
        const instrumentation = this;
        return function parse(original) {
          return function patchParse(source, options) {
            return instrumentation._parse(this, original, source, options);
          };
        };
      }
      _patchValidate() {
        const instrumentation = this;
        return function validate(original) {
          return function patchValidate(schema, documentAST, rules, options, typeInfo) {
            return instrumentation._validate(this, original, schema, documentAST, rules, typeInfo, options);
          };
        };
      }
      _parse(obj, original, source, options) {
        const config = this._getConfig();
        const span = this.tracer.startSpan(enum_1.SpanNames.PARSE);
        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
          return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
            return original.call(obj, source, options);
          }, (err, result) => {
            if (result) {
              const operation = (0, utils_1.getOperation)(result);
              if (!operation) {
                span.updateName(enum_1.SpanNames.SCHEMA_PARSE);
              } else if (result.loc) {
                (0, utils_1.addSpanSource)(span, result.loc, config.allowValues);
              }
            }
            (0, utils_1.endSpan)(span, err);
          });
        });
      }
      _validate(obj, original, schema, documentAST, rules, typeInfo, options) {
        const span = this.tracer.startSpan(enum_1.SpanNames.VALIDATE, {});
        return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
          return (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
            return original.call(obj, schema, documentAST, rules, options, typeInfo);
          }, (err, errors) => {
            if (!documentAST.loc) {
              span.updateName(enum_1.SpanNames.SCHEMA_VALIDATE);
            }
            if (errors && errors.length) {
              span.recordException({
                name: AttributeNames_1.AttributeNames.ERROR_VALIDATION_NAME,
                message: JSON.stringify(errors)
              });
            }
            (0, utils_1.endSpan)(span, err);
          });
        });
      }
      _createExecuteSpan(operation, processedArgs) {
        var _a2;
        const config = this._getConfig();
        const span = this.tracer.startSpan(enum_1.SpanNames.EXECUTE, {});
        if (operation) {
          const { operation: operationType, name: nameNode } = operation;
          span.setAttribute(AttributeNames_1.AttributeNames.OPERATION_TYPE, operationType);
          const operationName = nameNode === null || nameNode === void 0 ? void 0 : nameNode.value;
          if (operationName) {
            span.setAttribute(AttributeNames_1.AttributeNames.OPERATION_NAME, operationName);
            span.updateName(`${operationType} ${operationName}`);
          } else {
            span.updateName(operationType);
          }
        } else {
          let operationName = " ";
          if (processedArgs.operationName) {
            operationName = ` "${processedArgs.operationName}" `;
          }
          operationName = internal_types_1.OPERATION_NOT_SUPPORTED.replace("$operationName$", operationName);
          span.setAttribute(AttributeNames_1.AttributeNames.OPERATION_NAME, operationName);
        }
        if ((_a2 = processedArgs.document) === null || _a2 === void 0 ? void 0 : _a2.loc) {
          (0, utils_1.addSpanSource)(span, processedArgs.document.loc, config.allowValues);
        }
        if (processedArgs.variableValues && config.allowValues) {
          (0, utils_1.addInputVariableAttributes)(span, processedArgs.variableValues);
        }
        return span;
      }
      _wrapExecuteArgs(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver, defaultFieldResolved) {
        if (!contextValue) {
          contextValue = {};
        }
        if (contextValue[symbols_1.OTEL_GRAPHQL_DATA_SYMBOL] || this._getConfig().ignoreResolveSpans) {
          return {
            schema,
            document,
            rootValue,
            contextValue,
            variableValues,
            operationName,
            fieldResolver,
            typeResolver
          };
        }
        const isUsingDefaultResolver = fieldResolver == null;
        const fieldResolverForExecute = fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolved;
        fieldResolver = (0, utils_1.wrapFieldResolver)(this.tracer, this._getConfig.bind(this), fieldResolverForExecute, isUsingDefaultResolver);
        if (schema) {
          (0, utils_1.wrapFields)(schema.getQueryType(), this.tracer, this._getConfig.bind(this));
          (0, utils_1.wrapFields)(schema.getMutationType(), this.tracer, this._getConfig.bind(this));
        }
        return {
          schema,
          document,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        };
      }
    };
    exports.GraphQLInstrumentation = GraphQLInstrumentation2;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/types.js
var require_types4 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-graphql/build/src/types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@opentelemetry/instrumentation-graphql/build/src/index.js
var require_src5 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-graphql/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_instrumentation3(), exports);
    __exportStar(require_types4(), exports);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/internal-types.js
var require_internal_types3 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/internal-types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongodbCommandType = void 0;
    var MongodbCommandType;
    (function(MongodbCommandType2) {
      MongodbCommandType2["CREATE_INDEXES"] = "createIndexes";
      MongodbCommandType2["FIND_AND_MODIFY"] = "findAndModify";
      MongodbCommandType2["IS_MASTER"] = "isMaster";
      MongodbCommandType2["COUNT"] = "count";
      MongodbCommandType2["AGGREGATE"] = "aggregate";
      MongodbCommandType2["UNKNOWN"] = "unknown";
    })(MongodbCommandType = exports.MongodbCommandType || (exports.MongodbCommandType = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/version.js
var require_version5 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.46.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-mongodb";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/instrumentation.js
var require_instrumentation4 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/instrumentation.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongoDBInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var internal_types_1 = require_internal_types3();
    var version_1 = require_version5();
    var MongoDBInstrumentation2 = class _MongoDBInstrumentation extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      }
      _updateMetricInstruments() {
        this._connectionsUsage = this.meter.createUpDownCounter("db.client.connections.usage", {
          description: "The number of connections that are currently in state described by the state attribute.",
          unit: "{connection}"
        });
      }
      init() {
        const { v3PatchConnection, v3UnpatchConnection } = this._getV3ConnectionPatches();
        const { v4PatchConnect, v4UnpatchConnect } = this._getV4ConnectPatches();
        const { v4PatchConnectionCallback, v4PatchConnectionPromise, v4UnpatchConnection } = this._getV4ConnectionPatches();
        const { v4PatchConnectionPool, v4UnpatchConnectionPool } = this._getV4ConnectionPoolPatches();
        const { v4PatchSessions, v4UnpatchSessions } = this._getV4SessionsPatches();
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("mongodb", [">=3.3.0 <4"], void 0, void 0, [
            new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/core/wireprotocol/index.js", [">=3.3.0 <4"], v3PatchConnection, v3UnpatchConnection)
          ]),
          new instrumentation_1.InstrumentationNodeModuleDefinition("mongodb", [">=4.0.0 <7"], void 0, void 0, [
            new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection.js", [">=4.0.0 <6.4"], v4PatchConnectionCallback, v4UnpatchConnection),
            new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection.js", [">=6.4.0 <7"], v4PatchConnectionPromise, v4UnpatchConnection),
            new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection_pool.js", [">=4.0.0 <6.4"], v4PatchConnectionPool, v4UnpatchConnectionPool),
            new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/cmap/connect.js", [">=4.0.0 <7"], v4PatchConnect, v4UnpatchConnect),
            new instrumentation_1.InstrumentationNodeModuleFile("mongodb/lib/sessions.js", [">=4.0.0 <7"], v4PatchSessions, v4UnpatchSessions)
          ])
        ];
      }
      _getV3ConnectionPatches() {
        return {
          v3PatchConnection: (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.insert)) {
              this._unwrap(moduleExports, "insert");
            }
            this._wrap(moduleExports, "insert", this._getV3PatchOperation("insert"));
            if ((0, instrumentation_1.isWrapped)(moduleExports.remove)) {
              this._unwrap(moduleExports, "remove");
            }
            this._wrap(moduleExports, "remove", this._getV3PatchOperation("remove"));
            if ((0, instrumentation_1.isWrapped)(moduleExports.update)) {
              this._unwrap(moduleExports, "update");
            }
            this._wrap(moduleExports, "update", this._getV3PatchOperation("update"));
            if ((0, instrumentation_1.isWrapped)(moduleExports.command)) {
              this._unwrap(moduleExports, "command");
            }
            this._wrap(moduleExports, "command", this._getV3PatchCommand());
            if ((0, instrumentation_1.isWrapped)(moduleExports.query)) {
              this._unwrap(moduleExports, "query");
            }
            this._wrap(moduleExports, "query", this._getV3PatchFind());
            if ((0, instrumentation_1.isWrapped)(moduleExports.getMore)) {
              this._unwrap(moduleExports, "getMore");
            }
            this._wrap(moduleExports, "getMore", this._getV3PatchCursor());
            return moduleExports;
          },
          v3UnpatchConnection: (moduleExports) => {
            if (moduleExports === void 0)
              return;
            this._unwrap(moduleExports, "insert");
            this._unwrap(moduleExports, "remove");
            this._unwrap(moduleExports, "update");
            this._unwrap(moduleExports, "command");
            this._unwrap(moduleExports, "query");
            this._unwrap(moduleExports, "getMore");
          }
        };
      }
      _getV4SessionsPatches() {
        return {
          v4PatchSessions: (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.acquire)) {
              this._unwrap(moduleExports, "acquire");
            }
            this._wrap(moduleExports.ServerSessionPool.prototype, "acquire", this._getV4AcquireCommand());
            if ((0, instrumentation_1.isWrapped)(moduleExports.release)) {
              this._unwrap(moduleExports, "release");
            }
            this._wrap(moduleExports.ServerSessionPool.prototype, "release", this._getV4ReleaseCommand());
            return moduleExports;
          },
          v4UnpatchSessions: (moduleExports) => {
            if (moduleExports === void 0)
              return;
            if ((0, instrumentation_1.isWrapped)(moduleExports.acquire)) {
              this._unwrap(moduleExports, "acquire");
            }
            if ((0, instrumentation_1.isWrapped)(moduleExports.release)) {
              this._unwrap(moduleExports, "release");
            }
          }
        };
      }
      _getV4AcquireCommand() {
        const instrumentation = this;
        return (original) => {
          return function patchAcquire() {
            const nSessionsBeforeAcquire = this.sessions.length;
            const session = original.call(this);
            const nSessionsAfterAcquire = this.sessions.length;
            if (nSessionsBeforeAcquire === nSessionsAfterAcquire) {
              instrumentation._connectionsUsage.add(1, {
                state: "used",
                "pool.name": instrumentation._poolName
              });
            } else if (nSessionsBeforeAcquire - 1 === nSessionsAfterAcquire) {
              instrumentation._connectionsUsage.add(-1, {
                state: "idle",
                "pool.name": instrumentation._poolName
              });
              instrumentation._connectionsUsage.add(1, {
                state: "used",
                "pool.name": instrumentation._poolName
              });
            }
            return session;
          };
        };
      }
      _getV4ReleaseCommand() {
        const instrumentation = this;
        return (original) => {
          return function patchRelease(session) {
            const cmdPromise = original.call(this, session);
            instrumentation._connectionsUsage.add(-1, {
              state: "used",
              "pool.name": instrumentation._poolName
            });
            instrumentation._connectionsUsage.add(1, {
              state: "idle",
              "pool.name": instrumentation._poolName
            });
            return cmdPromise;
          };
        };
      }
      _getV4ConnectionPoolPatches() {
        return {
          v4PatchConnectionPool: (moduleExports) => {
            const poolPrototype = moduleExports.ConnectionPool.prototype;
            if ((0, instrumentation_1.isWrapped)(poolPrototype.checkOut)) {
              this._unwrap(poolPrototype, "checkOut");
            }
            this._wrap(poolPrototype, "checkOut", this._getV4ConnectionPoolCheckOut());
            return moduleExports;
          },
          v4UnpatchConnectionPool: (moduleExports) => {
            if (moduleExports === void 0)
              return;
            this._unwrap(moduleExports.ConnectionPool.prototype, "checkOut");
          }
        };
      }
      _getV4ConnectPatches() {
        return {
          v4PatchConnect: (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.connect)) {
              this._unwrap(moduleExports, "connect");
            }
            this._wrap(moduleExports, "connect", this._getV4ConnectCommand());
            return moduleExports;
          },
          v4UnpatchConnect: (moduleExports) => {
            if (moduleExports === void 0)
              return;
            this._unwrap(moduleExports, "connect");
          }
        };
      }
      // This patch will become unnecessary once
      // https://jira.mongodb.org/browse/NODE-5639 is done.
      _getV4ConnectionPoolCheckOut() {
        return (original) => {
          return function patchedCheckout(callback) {
            const patchedCallback = api_1.context.bind(api_1.context.active(), callback);
            return original.call(this, patchedCallback);
          };
        };
      }
      _getV4ConnectCommand() {
        const instrumentation = this;
        return (original) => {
          return function patchedConnect(options, callback) {
            if (original.length === 1) {
              const result = original.call(this, options);
              if (result && typeof result.then === "function") {
                result.then(
                  () => instrumentation.setPoolName(options),
                  // this handler is set to pass the lint rules
                  () => void 0
                );
              }
              return result;
            }
            const patchedCallback = function(err, conn) {
              if (err || !conn) {
                callback(err, conn);
                return;
              }
              instrumentation.setPoolName(options);
              callback(err, conn);
            };
            return original.call(this, options, patchedCallback);
          };
        };
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _getV4ConnectionPatches() {
        return {
          v4PatchConnectionCallback: (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.Connection.prototype.command)) {
              this._unwrap(moduleExports.Connection.prototype, "command");
            }
            this._wrap(moduleExports.Connection.prototype, "command", this._getV4PatchCommandCallback());
            return moduleExports;
          },
          v4PatchConnectionPromise: (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.Connection.prototype.command)) {
              this._unwrap(moduleExports.Connection.prototype, "command");
            }
            this._wrap(moduleExports.Connection.prototype, "command", this._getV4PatchCommandPromise());
            return moduleExports;
          },
          v4UnpatchConnection: (moduleExports) => {
            if (moduleExports === void 0)
              return;
            this._unwrap(moduleExports.Connection.prototype, "command");
          }
        };
      }
      /** Creates spans for common operations */
      _getV3PatchOperation(operationName) {
        const instrumentation = this;
        return (original) => {
          return function patchedServerCommand(server, ns, ops, options, callback) {
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const resultHandler = typeof options === "function" ? options : callback;
            if (!currentSpan || typeof resultHandler !== "function" || typeof ops !== "object") {
              if (typeof options === "function") {
                return original.call(this, server, ns, ops, options);
              } else {
                return original.call(this, server, ns, ops, options, callback);
              }
            }
            const span = instrumentation.tracer.startSpan(`mongodb.${operationName}`, {
              kind: api_1.SpanKind.CLIENT
            });
            instrumentation._populateV3Attributes(
              span,
              ns,
              server,
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              ops[0],
              operationName
            );
            const patchedCallback = instrumentation._patchEnd(span, resultHandler);
            if (typeof options === "function") {
              return original.call(this, server, ns, ops, patchedCallback);
            } else {
              return original.call(this, server, ns, ops, options, patchedCallback);
            }
          };
        };
      }
      /** Creates spans for command operation */
      _getV3PatchCommand() {
        const instrumentation = this;
        return (original) => {
          return function patchedServerCommand(server, ns, cmd, options, callback) {
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const resultHandler = typeof options === "function" ? options : callback;
            if (!currentSpan || typeof resultHandler !== "function" || typeof cmd !== "object") {
              if (typeof options === "function") {
                return original.call(this, server, ns, cmd, options);
              } else {
                return original.call(this, server, ns, cmd, options, callback);
              }
            }
            const commandType = _MongoDBInstrumentation._getCommandType(cmd);
            const type = commandType === internal_types_1.MongodbCommandType.UNKNOWN ? "command" : commandType;
            const span = instrumentation.tracer.startSpan(`mongodb.${type}`, {
              kind: api_1.SpanKind.CLIENT
            });
            const operation = commandType === internal_types_1.MongodbCommandType.UNKNOWN ? void 0 : commandType;
            instrumentation._populateV3Attributes(span, ns, server, cmd, operation);
            const patchedCallback = instrumentation._patchEnd(span, resultHandler);
            if (typeof options === "function") {
              return original.call(this, server, ns, cmd, patchedCallback);
            } else {
              return original.call(this, server, ns, cmd, options, patchedCallback);
            }
          };
        };
      }
      /** Creates spans for command operation */
      _getV4PatchCommandCallback() {
        const instrumentation = this;
        return (original) => {
          return function patchedV4ServerCommand(ns, cmd, options, callback) {
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const resultHandler = callback;
            const commandType = Object.keys(cmd)[0];
            if (typeof resultHandler !== "function" || typeof cmd !== "object" || cmd.ismaster || cmd.hello) {
              return original.call(this, ns, cmd, options, callback);
            }
            let span = void 0;
            if (currentSpan) {
              span = instrumentation.tracer.startSpan(`mongodb.${commandType}`, {
                kind: api_1.SpanKind.CLIENT
              });
              instrumentation._populateV4Attributes(span, this, ns, cmd, commandType);
            }
            const patchedCallback = instrumentation._patchEnd(span, resultHandler, this.id, commandType);
            return original.call(this, ns, cmd, options, patchedCallback);
          };
        };
      }
      _getV4PatchCommandPromise() {
        const instrumentation = this;
        return (original) => {
          return function patchedV4ServerCommand(...args) {
            const [ns, cmd] = args;
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const commandType = Object.keys(cmd)[0];
            const resultHandler = () => void 0;
            if (typeof cmd !== "object" || cmd.ismaster || cmd.hello) {
              return original.apply(this, args);
            }
            let span = void 0;
            if (currentSpan) {
              span = instrumentation.tracer.startSpan(`mongodb.${commandType}`, {
                kind: api_1.SpanKind.CLIENT
              });
              instrumentation._populateV4Attributes(span, this, ns, cmd, commandType);
            }
            const patchedCallback = instrumentation._patchEnd(span, resultHandler, this.id, commandType);
            const result = original.apply(this, args);
            result.then((res) => patchedCallback(null, res), (err) => patchedCallback(err));
            return result;
          };
        };
      }
      /** Creates spans for find operation */
      _getV3PatchFind() {
        const instrumentation = this;
        return (original) => {
          return function patchedServerCommand(server, ns, cmd, cursorState, options, callback) {
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const resultHandler = typeof options === "function" ? options : callback;
            if (!currentSpan || typeof resultHandler !== "function" || typeof cmd !== "object") {
              if (typeof options === "function") {
                return original.call(this, server, ns, cmd, cursorState, options);
              } else {
                return original.call(this, server, ns, cmd, cursorState, options, callback);
              }
            }
            const span = instrumentation.tracer.startSpan("mongodb.find", {
              kind: api_1.SpanKind.CLIENT
            });
            instrumentation._populateV3Attributes(span, ns, server, cmd, "find");
            const patchedCallback = instrumentation._patchEnd(span, resultHandler);
            if (typeof options === "function") {
              return original.call(this, server, ns, cmd, cursorState, patchedCallback);
            } else {
              return original.call(this, server, ns, cmd, cursorState, options, patchedCallback);
            }
          };
        };
      }
      /** Creates spans for find operation */
      _getV3PatchCursor() {
        const instrumentation = this;
        return (original) => {
          return function patchedServerCommand(server, ns, cursorState, batchSize, options, callback) {
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const resultHandler = typeof options === "function" ? options : callback;
            if (!currentSpan || typeof resultHandler !== "function") {
              if (typeof options === "function") {
                return original.call(this, server, ns, cursorState, batchSize, options);
              } else {
                return original.call(this, server, ns, cursorState, batchSize, options, callback);
              }
            }
            const span = instrumentation.tracer.startSpan("mongodb.getMore", {
              kind: api_1.SpanKind.CLIENT
            });
            instrumentation._populateV3Attributes(span, ns, server, cursorState.cmd, "getMore");
            const patchedCallback = instrumentation._patchEnd(span, resultHandler);
            if (typeof options === "function") {
              return original.call(this, server, ns, cursorState, batchSize, patchedCallback);
            } else {
              return original.call(this, server, ns, cursorState, batchSize, options, patchedCallback);
            }
          };
        };
      }
      /**
       * Get the mongodb command type from the object.
       * @param command Internal mongodb command object
       */
      static _getCommandType(command) {
        if (command.createIndexes !== void 0) {
          return internal_types_1.MongodbCommandType.CREATE_INDEXES;
        } else if (command.findandmodify !== void 0) {
          return internal_types_1.MongodbCommandType.FIND_AND_MODIFY;
        } else if (command.ismaster !== void 0) {
          return internal_types_1.MongodbCommandType.IS_MASTER;
        } else if (command.count !== void 0) {
          return internal_types_1.MongodbCommandType.COUNT;
        } else if (command.aggregate !== void 0) {
          return internal_types_1.MongodbCommandType.AGGREGATE;
        } else {
          return internal_types_1.MongodbCommandType.UNKNOWN;
        }
      }
      /**
       * Populate span's attributes by fetching related metadata from the context
       * @param span span to add attributes to
       * @param connectionCtx mongodb internal connection context
       * @param ns mongodb namespace
       * @param command mongodb internal representation of a command
       */
      _populateV4Attributes(span, connectionCtx, ns, command, operation) {
        let host, port;
        if (connectionCtx) {
          const hostParts = typeof connectionCtx.address === "string" ? connectionCtx.address.split(":") : "";
          if (hostParts.length === 2) {
            host = hostParts[0];
            port = hostParts[1];
          }
        }
        let commandObj;
        if ((command === null || command === void 0 ? void 0 : command.documents) && command.documents[0]) {
          commandObj = command.documents[0];
        } else if (command === null || command === void 0 ? void 0 : command.cursors) {
          commandObj = command.cursors;
        } else {
          commandObj = command;
        }
        this._addAllSpanAttributes(span, ns.db, ns.collection, host, port, commandObj, operation);
      }
      /**
       * Populate span's attributes by fetching related metadata from the context
       * @param span span to add attributes to
       * @param ns mongodb namespace
       * @param topology mongodb internal representation of the network topology
       * @param command mongodb internal representation of a command
       */
      _populateV3Attributes(span, ns, topology, command, operation) {
        var _a2, _b, _c, _d, _e, _f, _g, _h;
        let host;
        let port;
        if (topology && topology.s) {
          host = (_b = (_a2 = topology.s.options) === null || _a2 === void 0 ? void 0 : _a2.host) !== null && _b !== void 0 ? _b : topology.s.host;
          port = (_e = (_d = (_c = topology.s.options) === null || _c === void 0 ? void 0 : _c.port) !== null && _d !== void 0 ? _d : topology.s.port) === null || _e === void 0 ? void 0 : _e.toString();
          if (host == null || port == null) {
            const address = (_f = topology.description) === null || _f === void 0 ? void 0 : _f.address;
            if (address) {
              const addressSegments = address.split(":");
              host = addressSegments[0];
              port = addressSegments[1];
            }
          }
        }
        const [dbName, dbCollection] = ns.toString().split(".");
        const commandObj = (_h = (_g = command === null || command === void 0 ? void 0 : command.query) !== null && _g !== void 0 ? _g : command === null || command === void 0 ? void 0 : command.q) !== null && _h !== void 0 ? _h : command;
        this._addAllSpanAttributes(span, dbName, dbCollection, host, port, commandObj, operation);
      }
      _addAllSpanAttributes(span, dbName, dbCollection, host, port, commandObj, operation) {
        span.setAttributes({
          [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MONGODB,
          [semantic_conventions_1.SEMATTRS_DB_NAME]: dbName,
          [semantic_conventions_1.SEMATTRS_DB_MONGODB_COLLECTION]: dbCollection,
          [semantic_conventions_1.SEMATTRS_DB_OPERATION]: operation,
          [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: `mongodb://${host}:${port}/${dbName}`
        });
        if (host && port) {
          span.setAttribute(semantic_conventions_1.SEMATTRS_NET_PEER_NAME, host);
          const portNumber = parseInt(port, 10);
          if (!isNaN(portNumber)) {
            span.setAttribute(semantic_conventions_1.SEMATTRS_NET_PEER_PORT, portNumber);
          }
        }
        if (!commandObj)
          return;
        const dbStatementSerializer = typeof this._config.dbStatementSerializer === "function" ? this._config.dbStatementSerializer : this._defaultDbStatementSerializer.bind(this);
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          const query = dbStatementSerializer(commandObj);
          span.setAttribute(semantic_conventions_1.SEMATTRS_DB_STATEMENT, query);
        }, (err) => {
          if (err) {
            this._diag.error("Error running dbStatementSerializer hook", err);
          }
        }, true);
      }
      _defaultDbStatementSerializer(commandObj) {
        var _a2;
        const enhancedDbReporting = !!((_a2 = this._config) === null || _a2 === void 0 ? void 0 : _a2.enhancedDatabaseReporting);
        const resultObj = enhancedDbReporting ? commandObj : this._scrubStatement(commandObj);
        return JSON.stringify(resultObj);
      }
      _scrubStatement(value) {
        if (Array.isArray(value)) {
          return value.map((element) => this._scrubStatement(element));
        }
        if (typeof value === "object" && value !== null) {
          return Object.fromEntries(Object.entries(value).map(([key, element]) => [
            key,
            this._scrubStatement(element)
          ]));
        }
        return "?";
      }
      /**
       * Triggers the response hook in case it is defined.
       * @param span The span to add the results to.
       * @param result The command result
       */
      _handleExecutionResult(span, result) {
        const config = this.getConfig();
        if (typeof config.responseHook === "function") {
          (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
            config.responseHook(span, { data: result });
          }, (err) => {
            if (err) {
              this._diag.error("Error running response hook", err);
            }
          }, true);
        }
      }
      /**
       * Ends a created span.
       * @param span The created span to end.
       * @param resultHandler A callback function.
       * @param connectionId: The connection ID of the Command response.
       */
      _patchEnd(span, resultHandler, connectionId, commandType) {
        const activeContext = api_1.context.active();
        const instrumentation = this;
        return function patchedEnd(...args) {
          const error = args[0];
          if (span) {
            if (error instanceof Error) {
              span === null || span === void 0 ? void 0 : span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: error.message
              });
            } else {
              const result = args[1];
              instrumentation._handleExecutionResult(span, result);
            }
            span.end();
          }
          return api_1.context.with(activeContext, () => {
            if (commandType === "endSessions") {
              instrumentation._connectionsUsage.add(-1, {
                state: "idle",
                "pool.name": instrumentation._poolName
              });
            }
            return resultHandler.apply(this, args);
          });
        };
      }
      setPoolName(options) {
        var _a2, _b;
        const host = (_a2 = options.hostAddress) === null || _a2 === void 0 ? void 0 : _a2.host;
        const port = (_b = options.hostAddress) === null || _b === void 0 ? void 0 : _b.port;
        const database = options.dbName;
        const poolName = `mongodb://${host}:${port}/${database}`;
        this._poolName = poolName;
      }
    };
    exports.MongoDBInstrumentation = MongoDBInstrumentation2;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/types.js
var require_types5 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongodbCommandType = void 0;
    var MongodbCommandType;
    (function(MongodbCommandType2) {
      MongodbCommandType2["CREATE_INDEXES"] = "createIndexes";
      MongodbCommandType2["FIND_AND_MODIFY"] = "findAndModify";
      MongodbCommandType2["IS_MASTER"] = "isMaster";
      MongodbCommandType2["COUNT"] = "count";
      MongodbCommandType2["UNKNOWN"] = "unknown";
    })(MongodbCommandType = exports.MongodbCommandType || (exports.MongodbCommandType = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/index.js
var require_src6 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mongodb/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_instrumentation4(), exports);
    __exportStar(require_types5(), exports);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/utils.js
var require_utils5 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleCallbackResponse = exports.handlePromiseResponse = exports.getAttributesFromCollection = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    function getAttributesFromCollection(collection) {
      return {
        [semantic_conventions_1.SEMATTRS_DB_MONGODB_COLLECTION]: collection.name,
        [semantic_conventions_1.SEMATTRS_DB_NAME]: collection.conn.name,
        [semantic_conventions_1.SEMATTRS_DB_USER]: collection.conn.user,
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: collection.conn.host,
        [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: collection.conn.port
      };
    }
    exports.getAttributesFromCollection = getAttributesFromCollection;
    function setErrorStatus(span, error = {}) {
      span.recordException(error);
      span.setStatus({
        code: api_1.SpanStatusCode.ERROR,
        message: `${error.message} ${error.code ? `
Mongoose Error Code: ${error.code}` : ""}`
      });
    }
    function applyResponseHook(span, response, responseHook, moduleVersion = void 0) {
      if (!responseHook) {
        return;
      }
      (0, instrumentation_1.safeExecuteInTheMiddle)(() => responseHook(span, { moduleVersion, response }), (e) => {
        if (e) {
          api_1.diag.error("mongoose instrumentation: responseHook error", e);
        }
      }, true);
    }
    function handlePromiseResponse(execResponse, span, responseHook, moduleVersion = void 0) {
      if (!(execResponse instanceof Promise)) {
        applyResponseHook(span, execResponse, responseHook, moduleVersion);
        span.end();
        return execResponse;
      }
      return execResponse.then((response) => {
        applyResponseHook(span, response, responseHook, moduleVersion);
        return response;
      }).catch((err) => {
        setErrorStatus(span, err);
        throw err;
      }).finally(() => span.end());
    }
    exports.handlePromiseResponse = handlePromiseResponse;
    function handleCallbackResponse(callback, exec, originalThis, span, args, responseHook, moduleVersion = void 0) {
      let callbackArgumentIndex = 0;
      if (args.length === 2) {
        callbackArgumentIndex = 1;
      }
      args[callbackArgumentIndex] = (err, response) => {
        err ? setErrorStatus(span, err) : applyResponseHook(span, response, responseHook, moduleVersion);
        span.end();
        return callback(err, response);
      };
      return exec.apply(originalThis, args);
    }
    exports.handleCallbackResponse = handleCallbackResponse;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/version.js
var require_version6 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.40.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-mongoose";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/mongoose.js
var require_mongoose = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/mongoose.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongooseInstrumentation = exports._STORED_PARENT_SPAN = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var utils_1 = require_utils5();
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var version_1 = require_version6();
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var contextCaptureFunctions = [
      "remove",
      "deleteOne",
      "deleteMany",
      "find",
      "findOne",
      "estimatedDocumentCount",
      "countDocuments",
      "count",
      "distinct",
      "where",
      "$where",
      "findOneAndUpdate",
      "findOneAndDelete",
      "findOneAndReplace",
      "findOneAndRemove"
    ];
    exports._STORED_PARENT_SPAN = Symbol("stored-parent-span");
    var MongooseInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      }
      setConfig(config = {}) {
        this._config = Object.assign({}, config);
      }
      init() {
        const module3 = new instrumentation_1.InstrumentationNodeModuleDefinition("mongoose", [">=5.9.7 <7"], this.patch.bind(this), this.unpatch.bind(this));
        return module3;
      }
      patch(moduleExports, moduleVersion) {
        this._wrap(moduleExports.Model.prototype, "save", this.patchOnModelMethods("save", moduleVersion));
        moduleExports.Model.prototype.$save = moduleExports.Model.prototype.save;
        this._wrap(moduleExports.Model.prototype, "remove", this.patchOnModelMethods("remove", moduleVersion));
        this._wrap(moduleExports.Query.prototype, "exec", this.patchQueryExec(moduleVersion));
        this._wrap(moduleExports.Aggregate.prototype, "exec", this.patchAggregateExec(moduleVersion));
        contextCaptureFunctions.forEach((funcName) => {
          this._wrap(moduleExports.Query.prototype, funcName, this.patchAndCaptureSpanContext(funcName));
        });
        this._wrap(moduleExports.Model, "aggregate", this.patchModelAggregate());
        return moduleExports;
      }
      unpatch(moduleExports) {
        this._unwrap(moduleExports.Model.prototype, "save");
        moduleExports.Model.prototype.$save = moduleExports.Model.prototype.save;
        this._unwrap(moduleExports.Model.prototype, "remove");
        this._unwrap(moduleExports.Query.prototype, "exec");
        this._unwrap(moduleExports.Aggregate.prototype, "exec");
        contextCaptureFunctions.forEach((funcName) => {
          this._unwrap(moduleExports.Query.prototype, funcName);
        });
        this._unwrap(moduleExports.Model, "aggregate");
      }
      patchAggregateExec(moduleVersion) {
        const self = this;
        return (originalAggregate) => {
          return function exec(callback) {
            var _a2;
            if (self._config.requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === void 0) {
              return originalAggregate.apply(this, arguments);
            }
            const parentSpan = this[exports._STORED_PARENT_SPAN];
            const attributes = {};
            if (self._config.dbStatementSerializer) {
              attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = self._config.dbStatementSerializer("aggregate", {
                options: this.options,
                aggregatePipeline: this._pipeline
              });
            }
            const span = self._startSpan(this._model.collection, (_a2 = this._model) === null || _a2 === void 0 ? void 0 : _a2.modelName, "aggregate", attributes, parentSpan);
            return self._handleResponse(span, originalAggregate, this, arguments, callback, moduleVersion);
          };
        };
      }
      patchQueryExec(moduleVersion) {
        const self = this;
        return (originalExec) => {
          return function exec(callback) {
            if (self._config.requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === void 0) {
              return originalExec.apply(this, arguments);
            }
            const parentSpan = this[exports._STORED_PARENT_SPAN];
            const attributes = {};
            if (self._config.dbStatementSerializer) {
              attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = self._config.dbStatementSerializer(this.op, {
                condition: this._conditions,
                updates: this._update,
                options: this.options,
                fields: this._fields
              });
            }
            const span = self._startSpan(this.mongooseCollection, this.model.modelName, this.op, attributes, parentSpan);
            return self._handleResponse(span, originalExec, this, arguments, callback, moduleVersion);
          };
        };
      }
      patchOnModelMethods(op, moduleVersion) {
        const self = this;
        return (originalOnModelFunction) => {
          return function method(options, callback) {
            if (self._config.requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === void 0) {
              return originalOnModelFunction.apply(this, arguments);
            }
            const serializePayload = { document: this };
            if (options && !(options instanceof Function)) {
              serializePayload.options = options;
            }
            const attributes = {};
            if (self._config.dbStatementSerializer) {
              attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = self._config.dbStatementSerializer(op, serializePayload);
            }
            const span = self._startSpan(this.constructor.collection, this.constructor.modelName, op, attributes);
            if (options instanceof Function) {
              callback = options;
              options = void 0;
            }
            return self._handleResponse(span, originalOnModelFunction, this, arguments, callback, moduleVersion);
          };
        };
      }
      // we want to capture the otel span on the object which is calling exec.
      // in the special case of aggregate, we need have no function to path
      // on the Aggregate object to capture the context on, so we patch
      // the aggregate of Model, and set the context on the Aggregate object
      patchModelAggregate() {
        const self = this;
        return (original) => {
          return function captureSpanContext() {
            const currentSpan = api_1.trace.getSpan(api_1.context.active());
            const aggregate = self._callOriginalFunction(() => original.apply(this, arguments));
            if (aggregate)
              aggregate[exports._STORED_PARENT_SPAN] = currentSpan;
            return aggregate;
          };
        };
      }
      patchAndCaptureSpanContext(funcName) {
        const self = this;
        return (original) => {
          return function captureSpanContext() {
            this[exports._STORED_PARENT_SPAN] = api_1.trace.getSpan(api_1.context.active());
            return self._callOriginalFunction(() => original.apply(this, arguments));
          };
        };
      }
      _startSpan(collection, modelName, operation, attributes, parentSpan) {
        return this.tracer.startSpan(`mongoose.${modelName}.${operation}`, {
          kind: api_1.SpanKind.CLIENT,
          attributes: Object.assign(Object.assign(Object.assign({}, attributes), (0, utils_1.getAttributesFromCollection)(collection)), { [semantic_conventions_1.SEMATTRS_DB_OPERATION]: operation, [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: "mongoose" })
        }, parentSpan ? api_1.trace.setSpan(api_1.context.active(), parentSpan) : void 0);
      }
      _handleResponse(span, exec, originalThis, args, callback, moduleVersion = void 0) {
        const self = this;
        if (callback instanceof Function) {
          return self._callOriginalFunction(() => (0, utils_1.handleCallbackResponse)(callback, exec, originalThis, span, args, self._config.responseHook, moduleVersion));
        } else {
          const response = self._callOriginalFunction(() => exec.apply(originalThis, args));
          return (0, utils_1.handlePromiseResponse)(response, span, self._config.responseHook, moduleVersion);
        }
      }
      _callOriginalFunction(originalFunction) {
        var _a2;
        if ((_a2 = this._config) === null || _a2 === void 0 ? void 0 : _a2.suppressInternalInstrumentation) {
          return api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), originalFunction);
        } else {
          return originalFunction();
        }
      }
    };
    exports.MongooseInstrumentation = MongooseInstrumentation2;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/types.js
var require_types6 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/index.js
var require_src7 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mongoose/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_mongoose(), exports);
    __exportStar(require_types6(), exports);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mysql/build/src/AttributeNames.js
var require_AttributeNames5 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mysql/build/src/AttributeNames.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeNames = void 0;
    var AttributeNames;
    (function(AttributeNames2) {
      AttributeNames2["MYSQL_VALUES"] = "db.mysql.values";
    })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mysql/build/src/utils.js
var require_utils6 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mysql/build/src/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPoolName = exports.arrayStringifyHelper = exports.getSpanName = exports.getDbValues = exports.getDbStatement = exports.getConnectionAttributes = void 0;
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    function getConnectionAttributes(config) {
      const { host, port, database, user } = getConfig(config);
      const portNumber = parseInt(port, 10);
      if (!isNaN(portNumber)) {
        return {
          [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
          [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: portNumber,
          [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
          [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
          [semantic_conventions_1.SEMATTRS_DB_USER]: user
        };
      }
      return {
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
        [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
        [semantic_conventions_1.SEMATTRS_DB_USER]: user
      };
    }
    exports.getConnectionAttributes = getConnectionAttributes;
    function getConfig(config) {
      const { host, port, database, user } = config && config.connectionConfig || config || {};
      return { host, port, database, user };
    }
    function getJDBCString(host, port, database) {
      let jdbcString = `jdbc:mysql://${host || "localhost"}`;
      if (typeof port === "number") {
        jdbcString += `:${port}`;
      }
      if (typeof database === "string") {
        jdbcString += `/${database}`;
      }
      return jdbcString;
    }
    function getDbStatement(query) {
      if (typeof query === "string") {
        return query;
      } else {
        return query.sql;
      }
    }
    exports.getDbStatement = getDbStatement;
    function getDbValues(query, values) {
      if (typeof query === "string") {
        return arrayStringifyHelper(values);
      } else {
        return arrayStringifyHelper(values || query.values);
      }
    }
    exports.getDbValues = getDbValues;
    function getSpanName(query) {
      if (typeof query === "object") {
        return query.sql;
      }
      return query.split(" ")[0];
    }
    exports.getSpanName = getSpanName;
    function arrayStringifyHelper(arr) {
      if (arr)
        return `[${arr.toString()}]`;
      return "";
    }
    exports.arrayStringifyHelper = arrayStringifyHelper;
    function getPoolName(pool) {
      const c = pool.config.connectionConfig;
      let poolName = "";
      poolName += c.host ? `host: '${c.host}', ` : "";
      poolName += c.port ? `port: ${c.port}, ` : "";
      poolName += c.database ? `database: '${c.database}', ` : "";
      poolName += c.user ? `user: '${c.user}'` : "";
      if (!c.user) {
        poolName = poolName.substring(0, poolName.length - 2);
      }
      return poolName.trim();
    }
    exports.getPoolName = getPoolName;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mysql/build/src/version.js
var require_version7 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mysql/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.40.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-mysql";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mysql/build/src/instrumentation.js
var require_instrumentation5 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mysql/build/src/instrumentation.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MySQLInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var AttributeNames_1 = require_AttributeNames5();
    var utils_1 = require_utils6();
    var version_1 = require_version7();
    var MySQLInstrumentation2 = class _MySQLInstrumentation extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
        this._setMetricInstruments();
      }
      setMeterProvider(meterProvider) {
        super.setMeterProvider(meterProvider);
        this._setMetricInstruments();
      }
      _setMetricInstruments() {
        this._connectionsUsage = this.meter.createUpDownCounter(
          "db.client.connections.usage",
          //TODO:: use semantic convention
          {
            description: "The number of connections that are currently in state described by the state attribute.",
            unit: "{connection}"
          }
        );
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("mysql", [">=2.0.0 <3"], (moduleExports) => {
            if ((0, instrumentation_1.isWrapped)(moduleExports.createConnection)) {
              this._unwrap(moduleExports, "createConnection");
            }
            this._wrap(moduleExports, "createConnection", this._patchCreateConnection());
            if ((0, instrumentation_1.isWrapped)(moduleExports.createPool)) {
              this._unwrap(moduleExports, "createPool");
            }
            this._wrap(moduleExports, "createPool", this._patchCreatePool());
            if ((0, instrumentation_1.isWrapped)(moduleExports.createPoolCluster)) {
              this._unwrap(moduleExports, "createPoolCluster");
            }
            this._wrap(moduleExports, "createPoolCluster", this._patchCreatePoolCluster());
            return moduleExports;
          }, (moduleExports) => {
            if (moduleExports === void 0)
              return;
            this._unwrap(moduleExports, "createConnection");
            this._unwrap(moduleExports, "createPool");
            this._unwrap(moduleExports, "createPoolCluster");
          })
        ];
      }
      // global export function
      _patchCreateConnection() {
        return (originalCreateConnection) => {
          const thisPlugin = this;
          return function createConnection(_connectionUri) {
            const originalResult = originalCreateConnection(...arguments);
            thisPlugin._wrap(originalResult, "query", thisPlugin._patchQuery(originalResult));
            return originalResult;
          };
        };
      }
      // global export function
      _patchCreatePool() {
        return (originalCreatePool) => {
          const thisPlugin = this;
          return function createPool(_config) {
            const pool = originalCreatePool(...arguments);
            thisPlugin._wrap(pool, "query", thisPlugin._patchQuery(pool));
            thisPlugin._wrap(pool, "getConnection", thisPlugin._patchGetConnection(pool));
            thisPlugin._wrap(pool, "end", thisPlugin._patchPoolEnd(pool));
            thisPlugin._setPoolcallbacks(pool, thisPlugin, "");
            return pool;
          };
        };
      }
      _patchPoolEnd(pool) {
        return (originalPoolEnd) => {
          const thisPlugin = this;
          return function end(callback) {
            const nAll = pool._allConnections.length;
            const nFree = pool._freeConnections.length;
            const nUsed = nAll - nFree;
            const poolName = (0, utils_1.getPoolName)(pool);
            thisPlugin._connectionsUsage.add(-nUsed, {
              state: "used",
              name: poolName
            });
            thisPlugin._connectionsUsage.add(-nFree, {
              state: "idle",
              name: poolName
            });
            originalPoolEnd.apply(pool, arguments);
          };
        };
      }
      // global export function
      _patchCreatePoolCluster() {
        return (originalCreatePoolCluster) => {
          const thisPlugin = this;
          return function createPool(_config) {
            const cluster = originalCreatePoolCluster(...arguments);
            thisPlugin._wrap(cluster, "getConnection", thisPlugin._patchGetConnection(cluster));
            thisPlugin._wrap(cluster, "add", thisPlugin._patchAdd(cluster));
            return cluster;
          };
        };
      }
      _patchAdd(cluster) {
        return (originalAdd) => {
          const thisPlugin = this;
          return function add(id, config) {
            if (!thisPlugin["_enabled"]) {
              thisPlugin._unwrap(cluster, "add");
              return originalAdd.apply(cluster, arguments);
            }
            originalAdd.apply(cluster, arguments);
            const nodes = cluster["_nodes"];
            if (nodes) {
              const nodeId = typeof id === "object" ? "CLUSTER::" + cluster._lastId : String(id);
              const pool = nodes[nodeId].pool;
              thisPlugin._setPoolcallbacks(pool, thisPlugin, id);
            }
          };
        };
      }
      // method on cluster or pool
      _patchGetConnection(pool) {
        return (originalGetConnection) => {
          const thisPlugin = this;
          return function getConnection(arg1, arg2, arg3) {
            if (!thisPlugin["_enabled"]) {
              thisPlugin._unwrap(pool, "getConnection");
              return originalGetConnection.apply(pool, arguments);
            }
            if (arguments.length === 1 && typeof arg1 === "function") {
              const patchFn = thisPlugin._getConnectionCallbackPatchFn(arg1);
              return originalGetConnection.call(pool, patchFn);
            }
            if (arguments.length === 2 && typeof arg2 === "function") {
              const patchFn = thisPlugin._getConnectionCallbackPatchFn(arg2);
              return originalGetConnection.call(pool, arg1, patchFn);
            }
            if (arguments.length === 3 && typeof arg3 === "function") {
              const patchFn = thisPlugin._getConnectionCallbackPatchFn(arg3);
              return originalGetConnection.call(pool, arg1, arg2, patchFn);
            }
            return originalGetConnection.apply(pool, arguments);
          };
        };
      }
      _getConnectionCallbackPatchFn(cb) {
        const thisPlugin = this;
        const activeContext = api_1.context.active();
        return function(err, connection) {
          if (connection) {
            if (!(0, instrumentation_1.isWrapped)(connection.query)) {
              thisPlugin._wrap(connection, "query", thisPlugin._patchQuery(connection));
            }
          }
          if (typeof cb === "function") {
            api_1.context.with(activeContext, cb, this, err, connection);
          }
        };
      }
      _patchQuery(connection) {
        return (originalQuery) => {
          const thisPlugin = this;
          return function query(query, _valuesOrCallback, _callback) {
            if (!thisPlugin["_enabled"]) {
              thisPlugin._unwrap(connection, "query");
              return originalQuery.apply(connection, arguments);
            }
            const span = thisPlugin.tracer.startSpan((0, utils_1.getSpanName)(query), {
              kind: api_1.SpanKind.CLIENT,
              attributes: Object.assign(Object.assign({}, _MySQLInstrumentation.COMMON_ATTRIBUTES), (0, utils_1.getConnectionAttributes)(connection.config))
            });
            span.setAttribute(semantic_conventions_1.SEMATTRS_DB_STATEMENT, (0, utils_1.getDbStatement)(query));
            const instrumentationConfig = thisPlugin.getConfig();
            if (instrumentationConfig.enhancedDatabaseReporting) {
              let values;
              if (Array.isArray(_valuesOrCallback)) {
                values = _valuesOrCallback;
              } else if (arguments[2]) {
                values = [_valuesOrCallback];
              }
              span.setAttribute(AttributeNames_1.AttributeNames.MYSQL_VALUES, (0, utils_1.getDbValues)(query, values));
            }
            const cbIndex = Array.from(arguments).findIndex((arg) => typeof arg === "function");
            const parentContext = api_1.context.active();
            if (cbIndex === -1) {
              const streamableQuery = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
                return originalQuery.apply(connection, arguments);
              });
              api_1.context.bind(parentContext, streamableQuery);
              return streamableQuery.on("error", (err) => span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: err.message
              })).on("end", () => {
                span.end();
              });
            } else {
              thisPlugin._wrap(arguments, cbIndex, thisPlugin._patchCallbackQuery(span, parentContext));
              return api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
                return originalQuery.apply(connection, arguments);
              });
            }
          };
        };
      }
      _patchCallbackQuery(span, parentContext) {
        return (originalCallback) => {
          return function(err, results, fields3) {
            if (err) {
              span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: err.message
              });
            }
            span.end();
            return api_1.context.with(parentContext, () => originalCallback(...arguments));
          };
        };
      }
      _setPoolcallbacks(pool, thisPlugin, id) {
        const poolName = id || (0, utils_1.getPoolName)(pool);
        pool.on("connection", (connection) => {
          thisPlugin._connectionsUsage.add(1, {
            state: "idle",
            name: poolName
          });
        });
        pool.on("acquire", (connection) => {
          thisPlugin._connectionsUsage.add(-1, {
            state: "idle",
            name: poolName
          });
          thisPlugin._connectionsUsage.add(1, {
            state: "used",
            name: poolName
          });
        });
        pool.on("release", (connection) => {
          thisPlugin._connectionsUsage.add(-1, {
            state: "used",
            name: poolName
          });
          thisPlugin._connectionsUsage.add(1, {
            state: "idle",
            name: poolName
          });
        });
      }
    };
    exports.MySQLInstrumentation = MySQLInstrumentation2;
    MySQLInstrumentation2.COMMON_ATTRIBUTES = {
      [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MYSQL
    };
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mysql/build/src/types.js
var require_types7 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mysql/build/src/types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mysql/build/src/index.js
var require_src8 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mysql/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_instrumentation5(), exports);
    __exportStar(require_types7(), exports);
  }
});

// ../../node_modules/@opentelemetry/sql-common/build/src/index.js
var require_src9 = __commonJS({
  "../../node_modules/@opentelemetry/sql-common/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addSqlCommenterComment = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = (init_esm3(), __toCommonJS(esm_exports3));
    function hasValidSqlComment(query) {
      const indexOpeningDashDashComment = query.indexOf("--");
      if (indexOpeningDashDashComment >= 0) {
        return true;
      }
      const indexOpeningSlashComment = query.indexOf("/*");
      if (indexOpeningSlashComment < 0) {
        return false;
      }
      const indexClosingSlashComment = query.indexOf("*/");
      return indexOpeningDashDashComment < indexClosingSlashComment;
    }
    function fixedEncodeURIComponent(str) {
      return encodeURIComponent(str).replace(/[!'()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
    }
    function addSqlCommenterComment(span, query) {
      if (typeof query !== "string" || query.length === 0) {
        return query;
      }
      if (hasValidSqlComment(query)) {
        return query;
      }
      const propagator = new core_1.W3CTraceContextPropagator();
      const headers = {};
      propagator.inject(api_1.trace.setSpan(api_1.ROOT_CONTEXT, span), headers, api_1.defaultTextMapSetter);
      const sortedKeys = Object.keys(headers).sort();
      if (sortedKeys.length === 0) {
        return query;
      }
      const commentString = sortedKeys.map((key) => {
        const encodedValue = fixedEncodeURIComponent(headers[key]);
        return `${key}='${encodedValue}'`;
      }).join(",");
      return `${query} /*${commentString}*/`;
    }
    exports.addSqlCommenterComment = addSqlCommenterComment;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/utils.js
var require_utils7 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.once = exports.getSpanName = exports.getDbStatement = exports.getConnectionAttributes = void 0;
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    function getConnectionAttributes(config) {
      const { host, port, database, user } = getConfig(config);
      const portNumber = parseInt(port, 10);
      if (!isNaN(portNumber)) {
        return {
          [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
          [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: portNumber,
          [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
          [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
          [semantic_conventions_1.SEMATTRS_DB_USER]: user
        };
      }
      return {
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getJDBCString(host, port, database),
        [semantic_conventions_1.SEMATTRS_DB_NAME]: database,
        [semantic_conventions_1.SEMATTRS_DB_USER]: user
      };
    }
    exports.getConnectionAttributes = getConnectionAttributes;
    function getConfig(config) {
      const { host, port, database, user } = config && config.connectionConfig || config || {};
      return { host, port, database, user };
    }
    function getJDBCString(host, port, database) {
      let jdbcString = `jdbc:mysql://${host || "localhost"}`;
      if (typeof port === "number") {
        jdbcString += `:${port}`;
      }
      if (typeof database === "string") {
        jdbcString += `/${database}`;
      }
      return jdbcString;
    }
    function getDbStatement(query, format2, values) {
      if (typeof query === "string") {
        return values ? format2(query, values) : query;
      } else {
        return values || query.values ? format2(query.sql, values || query.values) : query.sql;
      }
    }
    exports.getDbStatement = getDbStatement;
    function getSpanName(query) {
      var _a2;
      const rawQuery = typeof query === "object" ? query.sql : query;
      return (_a2 = rawQuery === null || rawQuery === void 0 ? void 0 : rawQuery.split(" ")) === null || _a2 === void 0 ? void 0 : _a2[0];
    }
    exports.getSpanName = getSpanName;
    var once = (fn) => {
      let called = false;
      return (...args) => {
        if (called)
          return;
        called = true;
        return fn(...args);
      };
    };
    exports.once = once;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/version.js
var require_version8 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.40.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-mysql2";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/instrumentation.js
var require_instrumentation6 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/instrumentation.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MySQL2Instrumentation = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var sql_common_1 = require_src9();
    var utils_1 = require_utils7();
    var version_1 = require_version8();
    var MySQL2Instrumentation2 = class _MySQL2Instrumentation extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("mysql2", [">=1.4.2 <4"], (moduleExports) => {
            const ConnectionPrototype = moduleExports.Connection.prototype;
            if ((0, instrumentation_1.isWrapped)(ConnectionPrototype.query)) {
              this._unwrap(ConnectionPrototype, "query");
            }
            this._wrap(ConnectionPrototype, "query", this._patchQuery(moduleExports.format, false));
            if ((0, instrumentation_1.isWrapped)(ConnectionPrototype.execute)) {
              this._unwrap(ConnectionPrototype, "execute");
            }
            this._wrap(ConnectionPrototype, "execute", this._patchQuery(moduleExports.format, true));
            return moduleExports;
          }, (moduleExports) => {
            if (moduleExports === void 0)
              return;
            const ConnectionPrototype = moduleExports.Connection.prototype;
            this._unwrap(ConnectionPrototype, "query");
            this._unwrap(ConnectionPrototype, "execute");
          })
        ];
      }
      _patchQuery(format2, isPrepared) {
        return (originalQuery) => {
          const thisPlugin = this;
          return function query(query, _valuesOrCallback, _callback) {
            const thisPluginConfig = thisPlugin._config;
            let values;
            if (Array.isArray(_valuesOrCallback)) {
              values = _valuesOrCallback;
            } else if (arguments[2]) {
              values = [_valuesOrCallback];
            }
            const span = thisPlugin.tracer.startSpan((0, utils_1.getSpanName)(query), {
              kind: api.SpanKind.CLIENT,
              attributes: Object.assign(Object.assign(Object.assign({}, _MySQL2Instrumentation.COMMON_ATTRIBUTES), (0, utils_1.getConnectionAttributes)(this.config)), { [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: (0, utils_1.getDbStatement)(query, format2, values) })
            });
            if (!isPrepared && thisPluginConfig.addSqlCommenterCommentToQueries) {
              arguments[0] = query = typeof query === "string" ? (0, sql_common_1.addSqlCommenterComment)(span, query) : Object.assign(query, {
                sql: (0, sql_common_1.addSqlCommenterComment)(span, query.sql)
              });
            }
            const endSpan = (0, utils_1.once)((err, results) => {
              if (err) {
                span.setStatus({
                  code: api.SpanStatusCode.ERROR,
                  message: err.message
                });
              } else {
                if (typeof thisPluginConfig.responseHook === "function") {
                  (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
                    thisPluginConfig.responseHook(span, {
                      queryResults: results
                    });
                  }, (err2) => {
                    if (err2) {
                      thisPlugin._diag.warn("Failed executing responseHook", err2);
                    }
                  }, true);
                }
              }
              span.end();
            });
            if (arguments.length === 1) {
              if (typeof query.onResult === "function") {
                thisPlugin._wrap(query, "onResult", thisPlugin._patchCallbackQuery(endSpan));
              }
              const streamableQuery = originalQuery.apply(this, arguments);
              streamableQuery.once("error", (err) => {
                endSpan(err);
              }).once("result", (results) => {
                endSpan(void 0, results);
              });
              return streamableQuery;
            }
            if (typeof arguments[1] === "function") {
              thisPlugin._wrap(arguments, 1, thisPlugin._patchCallbackQuery(endSpan));
            } else if (typeof arguments[2] === "function") {
              thisPlugin._wrap(arguments, 2, thisPlugin._patchCallbackQuery(endSpan));
            }
            return originalQuery.apply(this, arguments);
          };
        };
      }
      _patchCallbackQuery(endSpan) {
        return (originalCallback) => {
          return function(err, results, fields3) {
            endSpan(err, results);
            return originalCallback(...arguments);
          };
        };
      }
    };
    exports.MySQL2Instrumentation = MySQL2Instrumentation2;
    MySQL2Instrumentation2.COMMON_ATTRIBUTES = {
      [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_MYSQL
    };
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/types.js
var require_types8 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/index.js
var require_src10 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-mysql2/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_instrumentation6(), exports);
    __exportStar(require_types8(), exports);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/utils.js
var require_utils8 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.endSpan = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var endSpan = (span, err) => {
      if (err) {
        span.recordException(err);
        span.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: err.message
        });
      }
      span.end();
    };
    exports.endSpan = endSpan;
  }
});

// ../../node_modules/@opentelemetry/redis-common/build/src/index.js
var require_src11 = __commonJS({
  "../../node_modules/@opentelemetry/redis-common/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultDbStatementSerializer = void 0;
    var serializationSubsets = [
      {
        regex: /^ECHO/i,
        args: 0
      },
      {
        regex: /^(LPUSH|MSET|PFA|PUBLISH|RPUSH|SADD|SET|SPUBLISH|XADD|ZADD)/i,
        args: 1
      },
      {
        regex: /^(HSET|HMSET|LSET|LINSERT)/i,
        args: 2
      },
      {
        regex: /^(ACL|BIT|B[LRZ]|CLIENT|CLUSTER|CONFIG|COMMAND|DECR|DEL|EVAL|EX|FUNCTION|GEO|GET|HINCR|HMGET|HSCAN|INCR|L[TRLM]|MEMORY|P[EFISTU]|RPOP|S[CDIMORSU]|XACK|X[CDGILPRT]|Z[CDILMPRS])/i,
        args: -1
      }
    ];
    var defaultDbStatementSerializer = (cmdName, cmdArgs) => {
      var _a2, _b;
      if (Array.isArray(cmdArgs) && cmdArgs.length) {
        const nArgsToSerialize = (_b = (_a2 = serializationSubsets.find(({ regex }) => {
          return regex.test(cmdName);
        })) === null || _a2 === void 0 ? void 0 : _a2.args) !== null && _b !== void 0 ? _b : 0;
        const argsToSerialize = nArgsToSerialize >= 0 ? cmdArgs.slice(0, nArgsToSerialize) : cmdArgs;
        if (cmdArgs.length > argsToSerialize.length) {
          argsToSerialize.push(`[${cmdArgs.length - nArgsToSerialize} other arguments]`);
        }
        return `${cmdName} ${argsToSerialize.join(" ")}`;
      }
      return cmdName;
    };
    exports.defaultDbStatementSerializer = defaultDbStatementSerializer;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/version.js
var require_version9 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.42.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-ioredis";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/instrumentation.js
var require_instrumentation7 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/instrumentation.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IORedisInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var instrumentation_2 = (init_esm5(), __toCommonJS(esm_exports4));
    var utils_1 = require_utils8();
    var redis_common_1 = require_src11();
    var version_1 = require_version9();
    var DEFAULT_CONFIG = {
      requireParentSpan: true
    };
    var IORedisInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign({}, DEFAULT_CONFIG, config));
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("ioredis", [">=2.0.0 <6"], (module3, moduleVersion) => {
            const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
            if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.sendCommand)) {
              this._unwrap(moduleExports.prototype, "sendCommand");
            }
            this._wrap(moduleExports.prototype, "sendCommand", this._patchSendCommand(moduleVersion));
            if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
              this._unwrap(moduleExports.prototype, "connect");
            }
            this._wrap(moduleExports.prototype, "connect", this._patchConnection());
            return module3;
          }, (module3) => {
            if (module3 === void 0)
              return;
            const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
            this._unwrap(moduleExports.prototype, "sendCommand");
            this._unwrap(moduleExports.prototype, "connect");
          })
        ];
      }
      /**
       * Patch send command internal to trace requests
       */
      _patchSendCommand(moduleVersion) {
        return (original) => {
          return this._traceSendCommand(original, moduleVersion);
        };
      }
      _patchConnection() {
        return (original) => {
          return this._traceConnection(original);
        };
      }
      _traceSendCommand(original, moduleVersion) {
        const instrumentation = this;
        return function(cmd) {
          if (arguments.length < 1 || typeof cmd !== "object") {
            return original.apply(this, arguments);
          }
          const config = instrumentation.getConfig();
          const dbStatementSerializer = (config === null || config === void 0 ? void 0 : config.dbStatementSerializer) || redis_common_1.defaultDbStatementSerializer;
          const hasNoParentSpan = api_1.trace.getSpan(api_1.context.active()) === void 0;
          if ((config === null || config === void 0 ? void 0 : config.requireParentSpan) === true && hasNoParentSpan) {
            return original.apply(this, arguments);
          }
          const span = instrumentation.tracer.startSpan(cmd.name, {
            kind: api_1.SpanKind.CLIENT,
            attributes: {
              [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_REDIS,
              [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: dbStatementSerializer(cmd.name, cmd.args)
            }
          });
          if (config === null || config === void 0 ? void 0 : config.requestHook) {
            (0, instrumentation_2.safeExecuteInTheMiddle)(() => config === null || config === void 0 ? void 0 : config.requestHook(span, {
              moduleVersion,
              cmdName: cmd.name,
              cmdArgs: cmd.args
            }), (e) => {
              if (e) {
                api_1.diag.error("ioredis instrumentation: request hook failed", e);
              }
            }, true);
          }
          const { host, port } = this.options;
          span.setAttributes({
            [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
            [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: port,
            [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: `redis://${host}:${port}`
          });
          try {
            const result = original.apply(this, arguments);
            const origResolve = cmd.resolve;
            cmd.resolve = function(result2) {
              (0, instrumentation_2.safeExecuteInTheMiddle)(() => {
                var _a2;
                return (_a2 = config === null || config === void 0 ? void 0 : config.responseHook) === null || _a2 === void 0 ? void 0 : _a2.call(config, span, cmd.name, cmd.args, result2);
              }, (e) => {
                if (e) {
                  api_1.diag.error("ioredis instrumentation: response hook failed", e);
                }
              }, true);
              (0, utils_1.endSpan)(span, null);
              origResolve(result2);
            };
            const origReject = cmd.reject;
            cmd.reject = function(err) {
              (0, utils_1.endSpan)(span, err);
              origReject(err);
            };
            return result;
          } catch (error) {
            (0, utils_1.endSpan)(span, error);
            throw error;
          }
        };
      }
      _traceConnection(original) {
        const instrumentation = this;
        return function() {
          const config = instrumentation.getConfig();
          const hasNoParentSpan = api_1.trace.getSpan(api_1.context.active()) === void 0;
          if ((config === null || config === void 0 ? void 0 : config.requireParentSpan) === true && hasNoParentSpan) {
            return original.apply(this, arguments);
          }
          const span = instrumentation.tracer.startSpan("connect", {
            kind: api_1.SpanKind.CLIENT,
            attributes: {
              [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_REDIS,
              [semantic_conventions_1.SEMATTRS_DB_STATEMENT]: "connect"
            }
          });
          const { host, port } = this.options;
          span.setAttributes({
            [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: host,
            [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: port,
            [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: `redis://${host}:${port}`
          });
          try {
            const client = original.apply(this, arguments);
            (0, utils_1.endSpan)(span, null);
            return client;
          } catch (error) {
            (0, utils_1.endSpan)(span, error);
            throw error;
          }
        };
      }
    };
    exports.IORedisInstrumentation = IORedisInstrumentation2;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/types.js
var require_types9 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/index.js
var require_src12 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-ioredis/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_instrumentation7(), exports);
    __exportStar(require_types9(), exports);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-redis-4/build/src/utils.js
var require_utils9 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-redis-4/build/src/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getClientAttributes = void 0;
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    function getClientAttributes(diag2, options) {
      var _a2, _b;
      return {
        [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_REDIS,
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: (_a2 = options === null || options === void 0 ? void 0 : options.socket) === null || _a2 === void 0 ? void 0 : _a2.host,
        [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: (_b = options === null || options === void 0 ? void 0 : options.socket) === null || _b === void 0 ? void 0 : _b.port,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: removeCredentialsFromDBConnectionStringAttribute(diag2, options === null || options === void 0 ? void 0 : options.url)
      };
    }
    exports.getClientAttributes = getClientAttributes;
    function removeCredentialsFromDBConnectionStringAttribute(diag2, url) {
      if (typeof url !== "string") {
        return;
      }
      try {
        const u = new URL(url);
        u.searchParams.delete("user_pwd");
        u.username = "";
        u.password = "";
        return u.href;
      } catch (err) {
        diag2.error("failed to sanitize redis connection url", err);
      }
      return;
    }
  }
});

// ../../node_modules/@opentelemetry/instrumentation-redis-4/build/src/version.js
var require_version10 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-redis-4/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.41.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-redis-4";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-redis-4/build/src/instrumentation.js
var require_instrumentation8 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-redis-4/build/src/instrumentation.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RedisInstrumentation = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var utils_1 = require_utils9();
    var redis_common_1 = require_src11();
    var version_1 = require_version10();
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var OTEL_OPEN_SPANS = Symbol("opentelemetry.instrumentation.redis.open_spans");
    var MULTI_COMMAND_OPTIONS = Symbol("opentelemetry.instrumentation.redis.multi_command_options");
    var DEFAULT_CONFIG = {
      requireParentSpan: false
    };
    var RedisInstrumentation2 = class _RedisInstrumentation extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      }
      setConfig(config = {}) {
        this._config = Object.assign({}, DEFAULT_CONFIG, config);
      }
      init() {
        return [
          this._getInstrumentationNodeModuleDefinition("@redis/client"),
          this._getInstrumentationNodeModuleDefinition("@node-redis/client")
        ];
      }
      _getInstrumentationNodeModuleDefinition(basePackageName) {
        const commanderModuleFile = new instrumentation_1.InstrumentationNodeModuleFile(`${basePackageName}/dist/lib/commander.js`, ["^1.0.0"], (moduleExports, moduleVersion) => {
          const transformCommandArguments = moduleExports.transformCommandArguments;
          if (!transformCommandArguments) {
            this._diag.error("internal instrumentation error, missing transformCommandArguments function");
            return moduleExports;
          }
          const functionToPatch = (moduleVersion === null || moduleVersion === void 0 ? void 0 : moduleVersion.startsWith("1.0.")) ? "extendWithCommands" : "attachCommands";
          if ((0, instrumentation_1.isWrapped)(moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports[functionToPatch])) {
            this._unwrap(moduleExports, functionToPatch);
          }
          this._wrap(moduleExports, functionToPatch, this._getPatchExtendWithCommands(transformCommandArguments));
          return moduleExports;
        }, (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.extendWithCommands)) {
            this._unwrap(moduleExports, "extendWithCommands");
          }
          if ((0, instrumentation_1.isWrapped)(moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.attachCommands)) {
            this._unwrap(moduleExports, "attachCommands");
          }
        });
        const multiCommanderModule = new instrumentation_1.InstrumentationNodeModuleFile(`${basePackageName}/dist/lib/client/multi-command.js`, ["^1.0.0"], (moduleExports) => {
          var _a2;
          const redisClientMultiCommandPrototype = (_a2 = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.default) === null || _a2 === void 0 ? void 0 : _a2.prototype;
          if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype === null || redisClientMultiCommandPrototype === void 0 ? void 0 : redisClientMultiCommandPrototype.exec)) {
            this._unwrap(redisClientMultiCommandPrototype, "exec");
          }
          this._wrap(redisClientMultiCommandPrototype, "exec", this._getPatchMultiCommandsExec());
          if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype === null || redisClientMultiCommandPrototype === void 0 ? void 0 : redisClientMultiCommandPrototype.addCommand)) {
            this._unwrap(redisClientMultiCommandPrototype, "addCommand");
          }
          this._wrap(redisClientMultiCommandPrototype, "addCommand", this._getPatchMultiCommandsAddCommand());
          return moduleExports;
        }, (moduleExports) => {
          var _a2;
          const redisClientMultiCommandPrototype = (_a2 = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.default) === null || _a2 === void 0 ? void 0 : _a2.prototype;
          if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype === null || redisClientMultiCommandPrototype === void 0 ? void 0 : redisClientMultiCommandPrototype.exec)) {
            this._unwrap(redisClientMultiCommandPrototype, "exec");
          }
          if ((0, instrumentation_1.isWrapped)(redisClientMultiCommandPrototype === null || redisClientMultiCommandPrototype === void 0 ? void 0 : redisClientMultiCommandPrototype.addCommand)) {
            this._unwrap(redisClientMultiCommandPrototype, "addCommand");
          }
        });
        const clientIndexModule = new instrumentation_1.InstrumentationNodeModuleFile(`${basePackageName}/dist/lib/client/index.js`, ["^1.0.0"], (moduleExports) => {
          var _a2;
          const redisClientPrototype = (_a2 = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.default) === null || _a2 === void 0 ? void 0 : _a2.prototype;
          if (redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.multi) {
            if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.multi)) {
              this._unwrap(redisClientPrototype, "multi");
            }
            this._wrap(redisClientPrototype, "multi", this._getPatchRedisClientMulti());
          }
          if (redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.MULTI) {
            if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.MULTI)) {
              this._unwrap(redisClientPrototype, "MULTI");
            }
            this._wrap(redisClientPrototype, "MULTI", this._getPatchRedisClientMulti());
          }
          if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.sendCommand)) {
            this._unwrap(redisClientPrototype, "sendCommand");
          }
          this._wrap(redisClientPrototype, "sendCommand", this._getPatchRedisClientSendCommand());
          this._wrap(redisClientPrototype, "connect", this._getPatchedClientConnect());
          return moduleExports;
        }, (moduleExports) => {
          var _a2;
          const redisClientPrototype = (_a2 = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.default) === null || _a2 === void 0 ? void 0 : _a2.prototype;
          if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.multi)) {
            this._unwrap(redisClientPrototype, "multi");
          }
          if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.MULTI)) {
            this._unwrap(redisClientPrototype, "MULTI");
          }
          if ((0, instrumentation_1.isWrapped)(redisClientPrototype === null || redisClientPrototype === void 0 ? void 0 : redisClientPrototype.sendCommand)) {
            this._unwrap(redisClientPrototype, "sendCommand");
          }
        });
        return new instrumentation_1.InstrumentationNodeModuleDefinition(basePackageName, ["^1.0.0"], (moduleExports) => {
          return moduleExports;
        }, () => {
        }, [commanderModuleFile, multiCommanderModule, clientIndexModule]);
      }
      // serves both for redis 4.0.x where function name is extendWithCommands
      // and redis ^4.1.0 where function name is attachCommands
      _getPatchExtendWithCommands(transformCommandArguments) {
        const plugin = this;
        return function extendWithCommandsPatchWrapper(original) {
          return function extendWithCommandsPatch(config) {
            var _a2;
            if (((_a2 = config === null || config === void 0 ? void 0 : config.BaseClass) === null || _a2 === void 0 ? void 0 : _a2.name) !== "RedisClient") {
              return original.apply(this, arguments);
            }
            const origExecutor = config.executor;
            config.executor = function(command, args) {
              const redisCommandArguments = transformCommandArguments(command, args).args;
              return plugin._traceClientCommand(origExecutor, this, arguments, redisCommandArguments);
            };
            return original.apply(this, arguments);
          };
        };
      }
      _getPatchMultiCommandsExec() {
        const plugin = this;
        return function execPatchWrapper(original) {
          return function execPatch() {
            const execRes = original.apply(this, arguments);
            if (typeof (execRes === null || execRes === void 0 ? void 0 : execRes.then) !== "function") {
              plugin._diag.error("got non promise result when patching RedisClientMultiCommand.exec");
              return execRes;
            }
            return execRes.then((redisRes) => {
              const openSpans = this[OTEL_OPEN_SPANS];
              plugin._endSpansWithRedisReplies(openSpans, redisRes);
              return redisRes;
            }).catch((err) => {
              const openSpans = this[OTEL_OPEN_SPANS];
              if (!openSpans) {
                plugin._diag.error("cannot find open spans to end for redis multi command");
              } else {
                const replies = err.constructor.name === "MultiErrorReply" ? err.replies : new Array(openSpans.length).fill(err);
                plugin._endSpansWithRedisReplies(openSpans, replies);
              }
              return Promise.reject(err);
            });
          };
        };
      }
      _getPatchMultiCommandsAddCommand() {
        const plugin = this;
        return function addCommandWrapper(original) {
          return function addCommandPatch(args) {
            return plugin._traceClientCommand(original, this, arguments, args);
          };
        };
      }
      _getPatchRedisClientMulti() {
        return function multiPatchWrapper(original) {
          return function multiPatch() {
            const multiRes = original.apply(this, arguments);
            multiRes[MULTI_COMMAND_OPTIONS] = this.options;
            return multiRes;
          };
        };
      }
      _getPatchRedisClientSendCommand() {
        const plugin = this;
        return function sendCommandWrapper(original) {
          return function sendCommandPatch(args) {
            return plugin._traceClientCommand(original, this, arguments, args);
          };
        };
      }
      _getPatchedClientConnect() {
        const plugin = this;
        return function connectWrapper(original) {
          return function patchedConnect() {
            const options = this.options;
            const attributes = (0, utils_1.getClientAttributes)(this._diag, options);
            const span = plugin.tracer.startSpan(`${_RedisInstrumentation.COMPONENT}-connect`, {
              kind: api_1.SpanKind.CLIENT,
              attributes
            });
            const res = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
              return original.apply(this);
            });
            return res.then((result) => {
              span.end();
              return result;
            }).catch((error) => {
              span.recordException(error);
              span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: error.message
              });
              span.end();
              return Promise.reject(error);
            });
          };
        };
      }
      _traceClientCommand(origFunction, origThis, origArguments, redisCommandArguments) {
        var _a2, _b;
        const hasNoParentSpan = api_1.trace.getSpan(api_1.context.active()) === void 0;
        if (hasNoParentSpan && ((_a2 = this._config) === null || _a2 === void 0 ? void 0 : _a2.requireParentSpan)) {
          return origFunction.apply(origThis, origArguments);
        }
        const clientOptions = origThis.options || origThis[MULTI_COMMAND_OPTIONS];
        const commandName = redisCommandArguments[0];
        const commandArgs = redisCommandArguments.slice(1);
        const dbStatementSerializer = ((_b = this._config) === null || _b === void 0 ? void 0 : _b.dbStatementSerializer) || redis_common_1.defaultDbStatementSerializer;
        const attributes = (0, utils_1.getClientAttributes)(this._diag, clientOptions);
        try {
          const dbStatement = dbStatementSerializer(commandName, commandArgs);
          if (dbStatement != null) {
            attributes[semantic_conventions_1.SEMATTRS_DB_STATEMENT] = dbStatement;
          }
        } catch (e) {
          this._diag.error("dbStatementSerializer throw an exception", e, {
            commandName
          });
        }
        const span = this.tracer.startSpan(`${_RedisInstrumentation.COMPONENT}-${commandName}`, {
          kind: api_1.SpanKind.CLIENT,
          attributes
        });
        const res = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
          return origFunction.apply(origThis, origArguments);
        });
        if (typeof (res === null || res === void 0 ? void 0 : res.then) === "function") {
          res.then((redisRes) => {
            this._endSpanWithResponse(span, commandName, commandArgs, redisRes, void 0);
          }, (err) => {
            this._endSpanWithResponse(span, commandName, commandArgs, null, err);
          });
        } else {
          const redisClientMultiCommand = res;
          redisClientMultiCommand[OTEL_OPEN_SPANS] = redisClientMultiCommand[OTEL_OPEN_SPANS] || [];
          redisClientMultiCommand[OTEL_OPEN_SPANS].push({
            span,
            commandName,
            commandArgs
          });
        }
        return res;
      }
      _endSpansWithRedisReplies(openSpans, replies) {
        if (!openSpans) {
          return this._diag.error("cannot find open spans to end for redis multi command");
        }
        if (replies.length !== openSpans.length) {
          return this._diag.error("number of multi command spans does not match response from redis");
        }
        for (let i = 0; i < openSpans.length; i++) {
          const { span, commandName, commandArgs } = openSpans[i];
          const currCommandRes = replies[i];
          const [res, err] = currCommandRes instanceof Error ? [null, currCommandRes] : [currCommandRes, void 0];
          this._endSpanWithResponse(span, commandName, commandArgs, res, err);
        }
      }
      _endSpanWithResponse(span, commandName, commandArgs, response, error) {
        if (!error && this._config.responseHook) {
          try {
            this._config.responseHook(span, commandName, commandArgs, response);
          } catch (err) {
            this._diag.error("responseHook throw an exception", err);
          }
        }
        if (error) {
          span.recordException(error);
          span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: error === null || error === void 0 ? void 0 : error.message });
        }
        span.end();
      }
    };
    exports.RedisInstrumentation = RedisInstrumentation2;
    RedisInstrumentation2.COMPONENT = "redis";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-redis-4/build/src/types.js
var require_types10 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-redis-4/build/src/types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@opentelemetry/instrumentation-redis-4/build/src/index.js
var require_src13 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-redis-4/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_instrumentation8(), exports);
    __exportStar(require_types10(), exports);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/version.js
var require_version11 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.39.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-nestjs-core";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/enums/AttributeNames.js
var require_AttributeNames6 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/enums/AttributeNames.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeNames = void 0;
    var AttributeNames;
    (function(AttributeNames2) {
      AttributeNames2["VERSION"] = "nestjs.version";
      AttributeNames2["TYPE"] = "nestjs.type";
      AttributeNames2["MODULE"] = "nestjs.module";
      AttributeNames2["CONTROLLER"] = "nestjs.controller";
      AttributeNames2["CALLBACK"] = "nestjs.callback";
      AttributeNames2["PIPES"] = "nestjs.pipes";
      AttributeNames2["INTERCEPTORS"] = "nestjs.interceptors";
      AttributeNames2["GUARDS"] = "nestjs.guards";
    })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/enums/NestType.js
var require_NestType = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/enums/NestType.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NestType = void 0;
    var NestType;
    (function(NestType2) {
      NestType2["APP_CREATION"] = "app_creation";
      NestType2["REQUEST_CONTEXT"] = "request_context";
      NestType2["REQUEST_HANDLER"] = "handler";
    })(NestType = exports.NestType || (exports.NestType = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/enums/index.js
var require_enums = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/enums/index.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NestType = exports.AttributeNames = void 0;
    var AttributeNames_1 = require_AttributeNames6();
    Object.defineProperty(exports, "AttributeNames", { enumerable: true, get: function() {
      return AttributeNames_1.AttributeNames;
    } });
    var NestType_1 = require_NestType();
    Object.defineProperty(exports, "NestType", { enumerable: true, get: function() {
      return NestType_1.NestType;
    } });
  }
});

// ../../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/instrumentation.js
var require_instrumentation9 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/instrumentation.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NestInstrumentation = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var version_1 = require_version11();
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var enums_1 = require_enums();
    var supportedVersions = [">=4.0.0 <11"];
    var NestInstrumentation2 = class _NestInstrumentation extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      }
      init() {
        const module3 = new instrumentation_1.InstrumentationNodeModuleDefinition(_NestInstrumentation.COMPONENT, supportedVersions);
        module3.files.push(this.getNestFactoryFileInstrumentation(supportedVersions), this.getRouterExecutionContextFileInstrumentation(supportedVersions));
        return module3;
      }
      getNestFactoryFileInstrumentation(versions) {
        return new instrumentation_1.InstrumentationNodeModuleFile("@nestjs/core/nest-factory.js", versions, (NestFactoryStatic, moduleVersion) => {
          this.ensureWrapped(NestFactoryStatic.NestFactoryStatic.prototype, "create", createWrapNestFactoryCreate(this.tracer, moduleVersion));
          return NestFactoryStatic;
        }, (NestFactoryStatic) => {
          this._unwrap(NestFactoryStatic.NestFactoryStatic.prototype, "create");
        });
      }
      getRouterExecutionContextFileInstrumentation(versions) {
        return new instrumentation_1.InstrumentationNodeModuleFile("@nestjs/core/router/router-execution-context.js", versions, (RouterExecutionContext, moduleVersion) => {
          this.ensureWrapped(RouterExecutionContext.RouterExecutionContext.prototype, "create", createWrapCreateHandler(this.tracer, moduleVersion));
          return RouterExecutionContext;
        }, (RouterExecutionContext) => {
          this._unwrap(RouterExecutionContext.RouterExecutionContext.prototype, "create");
        });
      }
      ensureWrapped(obj, methodName, wrapper) {
        if ((0, instrumentation_1.isWrapped)(obj[methodName])) {
          this._unwrap(obj, methodName);
        }
        this._wrap(obj, methodName, wrapper);
      }
    };
    exports.NestInstrumentation = NestInstrumentation2;
    NestInstrumentation2.COMPONENT = "@nestjs/core";
    NestInstrumentation2.COMMON_ATTRIBUTES = {
      component: NestInstrumentation2.COMPONENT
    };
    function createWrapNestFactoryCreate(tracer, moduleVersion) {
      return function wrapCreate(original) {
        return function createWithTrace(nestModule) {
          const span = tracer.startSpan("Create Nest App", {
            attributes: Object.assign(Object.assign({}, NestInstrumentation2.COMMON_ATTRIBUTES), { [enums_1.AttributeNames.TYPE]: enums_1.NestType.APP_CREATION, [enums_1.AttributeNames.VERSION]: moduleVersion, [enums_1.AttributeNames.MODULE]: nestModule.name })
          });
          const spanContext = api.trace.setSpan(api.context.active(), span);
          return api.context.with(spanContext, async () => {
            try {
              return await original.apply(this, arguments);
            } catch (e) {
              throw addError(span, e);
            } finally {
              span.end();
            }
          });
        };
      };
    }
    function createWrapCreateHandler(tracer, moduleVersion) {
      return function wrapCreateHandler(original) {
        return function createHandlerWithTrace(instance, callback) {
          arguments[1] = createWrapHandler(tracer, moduleVersion, callback);
          const handler = original.apply(this, arguments);
          const callbackName = callback.name;
          const instanceName = instance.constructor && instance.constructor.name ? instance.constructor.name : "UnnamedInstance";
          const spanName = callbackName ? `${instanceName}.${callbackName}` : instanceName;
          return function(req, res, next) {
            var _a2, _b;
            const span = tracer.startSpan(spanName, {
              attributes: Object.assign(Object.assign({}, NestInstrumentation2.COMMON_ATTRIBUTES), { [enums_1.AttributeNames.VERSION]: moduleVersion, [enums_1.AttributeNames.TYPE]: enums_1.NestType.REQUEST_CONTEXT, [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: req.method, [semantic_conventions_1.SEMATTRS_HTTP_URL]: req.originalUrl || req.url, [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: ((_a2 = req.route) === null || _a2 === void 0 ? void 0 : _a2.path) || ((_b = req.routeOptions) === null || _b === void 0 ? void 0 : _b.url) || req.routerPath, [enums_1.AttributeNames.CONTROLLER]: instanceName, [enums_1.AttributeNames.CALLBACK]: callbackName })
            });
            const spanContext = api.trace.setSpan(api.context.active(), span);
            return api.context.with(spanContext, async () => {
              try {
                return await handler.apply(this, arguments);
              } catch (e) {
                throw addError(span, e);
              } finally {
                span.end();
              }
            });
          };
        };
      };
    }
    function createWrapHandler(tracer, moduleVersion, handler) {
      const spanName = handler.name || "anonymous nest handler";
      const options = {
        attributes: Object.assign(Object.assign({}, NestInstrumentation2.COMMON_ATTRIBUTES), { [enums_1.AttributeNames.VERSION]: moduleVersion, [enums_1.AttributeNames.TYPE]: enums_1.NestType.REQUEST_HANDLER, [enums_1.AttributeNames.CALLBACK]: handler.name })
      };
      const wrappedHandler = function() {
        const span = tracer.startSpan(spanName, options);
        const spanContext = api.trace.setSpan(api.context.active(), span);
        return api.context.with(spanContext, async () => {
          try {
            return await handler.apply(this, arguments);
          } catch (e) {
            throw addError(span, e);
          } finally {
            span.end();
          }
        });
      };
      if (handler.name) {
        Object.defineProperty(wrappedHandler, "name", { value: handler.name });
      }
      Reflect.getMetadataKeys(handler).forEach((metadataKey) => {
        Reflect.defineMetadata(metadataKey, Reflect.getMetadata(metadataKey, handler), wrappedHandler);
      });
      return wrappedHandler;
    }
    var addError = (span, error) => {
      span.recordException(error);
      span.setStatus({ code: api.SpanStatusCode.ERROR, message: error.message });
      return error;
    };
  }
});

// ../../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/index.js
var require_src14 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-nestjs-core/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_instrumentation9(), exports);
    __exportStar(require_AttributeNames6(), exports);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/enums/AttributeNames.js
var require_AttributeNames7 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-pg/build/src/enums/AttributeNames.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeNames = void 0;
    var AttributeNames;
    (function(AttributeNames2) {
      AttributeNames2["PG_VALUES"] = "db.postgresql.values";
      AttributeNames2["PG_PLAN"] = "db.postgresql.plan";
      AttributeNames2["IDLE_TIMEOUT_MILLIS"] = "db.postgresql.idle.timeout.millis";
      AttributeNames2["MAX_CLIENT"] = "db.postgresql.max.client";
    })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/enums/SpanNames.js
var require_SpanNames = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-pg/build/src/enums/SpanNames.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpanNames = void 0;
    var SpanNames;
    (function(SpanNames2) {
      SpanNames2["QUERY_PREFIX"] = "pg.query";
      SpanNames2["CONNECT"] = "pg.connect";
      SpanNames2["POOL_CONNECT"] = "pg-pool.connect";
    })(SpanNames = exports.SpanNames || (exports.SpanNames = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/utils.js
var require_utils10 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-pg/build/src/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isObjectWithTextString = exports.getErrorMessage = exports.patchClientConnectCallback = exports.patchCallbackPGPool = exports.patchCallback = exports.handleExecutionResult = exports.handleConfigQuery = exports.shouldSkipInstrumentation = exports.getSemanticAttributesFromPool = exports.getSemanticAttributesFromConnection = exports.getConnectionString = exports.getQuerySpanName = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AttributeNames_1 = require_AttributeNames7();
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var SpanNames_1 = require_SpanNames();
    function getQuerySpanName(dbName, queryConfig) {
      if (!queryConfig)
        return SpanNames_1.SpanNames.QUERY_PREFIX;
      const command = typeof queryConfig.name === "string" && queryConfig.name ? queryConfig.name : parseNormalizedOperationName(queryConfig.text);
      return `${SpanNames_1.SpanNames.QUERY_PREFIX}:${command}${dbName ? ` ${dbName}` : ""}`;
    }
    exports.getQuerySpanName = getQuerySpanName;
    function parseNormalizedOperationName(queryText) {
      const indexOfFirstSpace = queryText.indexOf(" ");
      let sqlCommand = indexOfFirstSpace === -1 ? queryText : queryText.slice(0, indexOfFirstSpace);
      sqlCommand = sqlCommand.toUpperCase();
      return sqlCommand.endsWith(";") ? sqlCommand.slice(0, -1) : sqlCommand;
    }
    function getConnectionString(params) {
      const host = params.host || "localhost";
      const port = params.port || 5432;
      const database = params.database || "";
      return `postgresql://${host}:${port}/${database}`;
    }
    exports.getConnectionString = getConnectionString;
    function getPort(port) {
      if (Number.isInteger(port)) {
        return port;
      }
      return void 0;
    }
    function getSemanticAttributesFromConnection(params) {
      return {
        [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_POSTGRESQL,
        [semantic_conventions_1.SEMATTRS_DB_NAME]: params.database,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getConnectionString(params),
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: params.host,
        [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: getPort(params.port),
        [semantic_conventions_1.SEMATTRS_DB_USER]: params.user
      };
    }
    exports.getSemanticAttributesFromConnection = getSemanticAttributesFromConnection;
    function getSemanticAttributesFromPool(params) {
      return {
        [semantic_conventions_1.SEMATTRS_DB_SYSTEM]: semantic_conventions_1.DBSYSTEMVALUES_POSTGRESQL,
        [semantic_conventions_1.SEMATTRS_DB_NAME]: params.database,
        [semantic_conventions_1.SEMATTRS_DB_CONNECTION_STRING]: getConnectionString(params),
        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: params.host,
        [semantic_conventions_1.SEMATTRS_NET_PEER_PORT]: getPort(params.port),
        [semantic_conventions_1.SEMATTRS_DB_USER]: params.user,
        [AttributeNames_1.AttributeNames.IDLE_TIMEOUT_MILLIS]: params.idleTimeoutMillis,
        [AttributeNames_1.AttributeNames.MAX_CLIENT]: params.maxClient
      };
    }
    exports.getSemanticAttributesFromPool = getSemanticAttributesFromPool;
    function shouldSkipInstrumentation(instrumentationConfig) {
      return instrumentationConfig.requireParentSpan === true && api_1.trace.getSpan(api_1.context.active()) === void 0;
    }
    exports.shouldSkipInstrumentation = shouldSkipInstrumentation;
    function handleConfigQuery(tracer, instrumentationConfig, queryConfig) {
      const { connectionParameters } = this;
      const dbName = connectionParameters.database;
      const spanName = getQuerySpanName(dbName, queryConfig);
      const span = tracer.startSpan(spanName, {
        kind: api_1.SpanKind.CLIENT,
        attributes: getSemanticAttributesFromConnection(connectionParameters)
      });
      if (!queryConfig) {
        return span;
      }
      if (queryConfig.text) {
        span.setAttribute(semantic_conventions_1.SEMATTRS_DB_STATEMENT, queryConfig.text);
      }
      if (instrumentationConfig.enhancedDatabaseReporting && Array.isArray(queryConfig.values)) {
        try {
          const convertedValues = queryConfig.values.map((value) => {
            if (value == null) {
              return "null";
            } else if (value instanceof Buffer) {
              return value.toString();
            } else if (typeof value === "object") {
              if (typeof value.toPostgres === "function") {
                return value.toPostgres();
              }
              return JSON.stringify(value);
            } else {
              return value.toString();
            }
          });
          span.setAttribute(AttributeNames_1.AttributeNames.PG_VALUES, convertedValues);
        } catch (e) {
          api_1.diag.error("failed to stringify ", queryConfig.values, e);
        }
      }
      if (typeof queryConfig.name === "string") {
        span.setAttribute(AttributeNames_1.AttributeNames.PG_PLAN, queryConfig.name);
      }
      return span;
    }
    exports.handleConfigQuery = handleConfigQuery;
    function handleExecutionResult(config, span, pgResult) {
      if (typeof config.responseHook === "function") {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
          config.responseHook(span, {
            data: pgResult
          });
        }, (err) => {
          if (err) {
            api_1.diag.error("Error running response hook", err);
          }
        }, true);
      }
    }
    exports.handleExecutionResult = handleExecutionResult;
    function patchCallback(instrumentationConfig, span, cb) {
      return function patchedCallback(err, res) {
        if (err) {
          span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: err.message
          });
        } else {
          handleExecutionResult(instrumentationConfig, span, res);
        }
        span.end();
        cb.call(this, err, res);
      };
    }
    exports.patchCallback = patchCallback;
    function patchCallbackPGPool(span, cb) {
      return function patchedCallback(err, res, done) {
        if (err) {
          span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: err.message
          });
        }
        span.end();
        cb.call(this, err, res, done);
      };
    }
    exports.patchCallbackPGPool = patchCallbackPGPool;
    function patchClientConnectCallback(span, cb) {
      return function patchedClientConnectCallback(err) {
        if (err) {
          span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: err.message
          });
        }
        span.end();
        cb.apply(this, arguments);
      };
    }
    exports.patchClientConnectCallback = patchClientConnectCallback;
    function getErrorMessage(e) {
      return typeof e === "object" && e !== null && "message" in e ? String(e.message) : void 0;
    }
    exports.getErrorMessage = getErrorMessage;
    function isObjectWithTextString(it) {
      var _a2;
      return typeof it === "object" && typeof ((_a2 = it) === null || _a2 === void 0 ? void 0 : _a2.text) === "string";
    }
    exports.isObjectWithTextString = isObjectWithTextString;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/version.js
var require_version12 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-pg/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.43.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-pg";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/instrumentation.js
var require_instrumentation10 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-pg/build/src/instrumentation.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PgInstrumentation = void 0;
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var utils = require_utils10();
    var sql_common_1 = require_src9();
    var version_1 = require_version12();
    var SpanNames_1 = require_SpanNames();
    var PgInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      }
      init() {
        const modulePG = new instrumentation_1.InstrumentationNodeModuleDefinition("pg", [">=8.0.0 <9"], (module3) => {
          const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
          if ((0, instrumentation_1.isWrapped)(moduleExports.Client.prototype.query)) {
            this._unwrap(moduleExports.Client.prototype, "query");
          }
          if ((0, instrumentation_1.isWrapped)(moduleExports.Client.prototype.connect)) {
            this._unwrap(moduleExports.Client.prototype, "connect");
          }
          this._wrap(moduleExports.Client.prototype, "query", this._getClientQueryPatch());
          this._wrap(moduleExports.Client.prototype, "connect", this._getClientConnectPatch());
          return module3;
        }, (module3) => {
          const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
          if ((0, instrumentation_1.isWrapped)(moduleExports.Client.prototype.query)) {
            this._unwrap(moduleExports.Client.prototype, "query");
          }
        });
        const modulePGPool = new instrumentation_1.InstrumentationNodeModuleDefinition("pg-pool", [">=2.0.0 <4"], (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
            this._unwrap(moduleExports.prototype, "connect");
          }
          this._wrap(moduleExports.prototype, "connect", this._getPoolConnectPatch());
          return moduleExports;
        }, (moduleExports) => {
          if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.connect)) {
            this._unwrap(moduleExports.prototype, "connect");
          }
        });
        return [modulePG, modulePGPool];
      }
      setConfig(config = {}) {
        this._config = Object.assign({}, config);
      }
      getConfig() {
        return this._config;
      }
      _getClientConnectPatch() {
        const plugin = this;
        return (original) => {
          return function connect3(callback) {
            if (utils.shouldSkipInstrumentation(plugin.getConfig())) {
              return original.call(this, callback);
            }
            const span = plugin.tracer.startSpan(SpanNames_1.SpanNames.CONNECT, {
              kind: api_1.SpanKind.CLIENT,
              attributes: utils.getSemanticAttributesFromConnection(this)
            });
            if (callback) {
              const parentSpan = api_1.trace.getSpan(api_1.context.active());
              callback = utils.patchClientConnectCallback(span, callback);
              if (parentSpan) {
                callback = api_1.context.bind(api_1.context.active(), callback);
              }
            }
            const connectResult = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
              return original.call(this, callback);
            });
            return handleConnectResult(span, connectResult);
          };
        };
      }
      _getClientQueryPatch() {
        const plugin = this;
        return (original) => {
          this._diag.debug("Patching pg.Client.prototype.query");
          return function query(...args) {
            if (utils.shouldSkipInstrumentation(plugin.getConfig())) {
              return original.apply(this, args);
            }
            const arg0 = args[0];
            const firstArgIsString = typeof arg0 === "string";
            const firstArgIsQueryObjectWithText = utils.isObjectWithTextString(arg0);
            const queryConfig = firstArgIsString ? {
              text: arg0,
              values: Array.isArray(args[1]) ? args[1] : void 0
            } : firstArgIsQueryObjectWithText ? arg0 : void 0;
            const instrumentationConfig = plugin.getConfig();
            const span = utils.handleConfigQuery.call(this, plugin.tracer, instrumentationConfig, queryConfig);
            if (instrumentationConfig.addSqlCommenterCommentToQueries) {
              args[0] = firstArgIsString ? (0, sql_common_1.addSqlCommenterComment)(span, arg0) : firstArgIsQueryObjectWithText ? Object.assign(Object.assign({}, arg0), { text: (0, sql_common_1.addSqlCommenterComment)(span, arg0.text) }) : args[0];
            }
            if (args.length > 0) {
              const parentSpan = api_1.trace.getSpan(api_1.context.active());
              if (typeof args[args.length - 1] === "function") {
                args[args.length - 1] = utils.patchCallback(
                  instrumentationConfig,
                  span,
                  args[args.length - 1]
                  // nb: not type safe.
                );
                if (parentSpan) {
                  args[args.length - 1] = api_1.context.bind(api_1.context.active(), args[args.length - 1]);
                }
              } else if (typeof (queryConfig === null || queryConfig === void 0 ? void 0 : queryConfig.callback) === "function") {
                let callback = utils.patchCallback(
                  plugin.getConfig(),
                  span,
                  queryConfig.callback
                  // nb: not type safe.
                );
                if (parentSpan) {
                  callback = api_1.context.bind(api_1.context.active(), callback);
                }
                args[0].callback = callback;
              }
            }
            if (typeof instrumentationConfig.requestHook === "function" && queryConfig) {
              (0, instrumentation_1.safeExecuteInTheMiddle)(() => {
                const { database, host, port, user } = this.connectionParameters;
                const connection = { database, host, port, user };
                instrumentationConfig.requestHook(span, {
                  connection,
                  query: {
                    text: queryConfig.text,
                    // nb: if `client.query` is called with illegal arguments
                    // (e.g., if `queryConfig.values` is passed explicitly, but a
                    // non-array is given), then the type casts will be wrong. But
                    // we leave it up to the queryHook to handle that, and we
                    // catch and swallow any errors it throws. The other options
                    // are all worse. E.g., we could leave `queryConfig.values`
                    // and `queryConfig.name` as `unknown`, but then the hook body
                    // would be forced to validate (or cast) them before using
                    // them, which seems incredibly cumbersome given that these
                    // casts will be correct 99.9% of the time -- and pg.query
                    // will immediately throw during development in the other .1%
                    // of cases. Alternatively, we could simply skip calling the
                    // hook when `values` or `name` don't have the expected type,
                    // but that would add unnecessary validation overhead to every
                    // hook invocation and possibly be even more confusing/unexpected.
                    values: queryConfig.values,
                    name: queryConfig.name
                  }
                });
              }, (err) => {
                if (err) {
                  plugin._diag.error("Error running query hook", err);
                }
              }, true);
            }
            let result;
            try {
              result = original.apply(this, args);
            } catch (e) {
              span.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: utils.getErrorMessage(e)
              });
              span.end();
              throw e;
            }
            if (result instanceof Promise) {
              return result.then((result2) => {
                return new Promise((resolve) => {
                  utils.handleExecutionResult(plugin.getConfig(), span, result2);
                  span.end();
                  resolve(result2);
                });
              }).catch((error) => {
                return new Promise((_, reject) => {
                  span.setStatus({
                    code: api_1.SpanStatusCode.ERROR,
                    message: error.message
                  });
                  span.end();
                  reject(error);
                });
              });
            }
            return result;
          };
        };
      }
      _getPoolConnectPatch() {
        const plugin = this;
        return (originalConnect) => {
          return function connect3(callback) {
            if (utils.shouldSkipInstrumentation(plugin.getConfig())) {
              return originalConnect.call(this, callback);
            }
            const span = plugin.tracer.startSpan(SpanNames_1.SpanNames.POOL_CONNECT, {
              kind: api_1.SpanKind.CLIENT,
              attributes: utils.getSemanticAttributesFromPool(this.options)
            });
            if (callback) {
              const parentSpan = api_1.trace.getSpan(api_1.context.active());
              callback = utils.patchCallbackPGPool(span, callback);
              if (parentSpan) {
                callback = api_1.context.bind(api_1.context.active(), callback);
              }
            }
            const connectResult = api_1.context.with(api_1.trace.setSpan(api_1.context.active(), span), () => {
              return originalConnect.call(this, callback);
            });
            return handleConnectResult(span, connectResult);
          };
        };
      }
    };
    exports.PgInstrumentation = PgInstrumentation2;
    function handleConnectResult(span, connectResult) {
      if (!(connectResult instanceof Promise)) {
        return connectResult;
      }
      const connectResultPromise = connectResult;
      return api_1.context.bind(api_1.context.active(), connectResultPromise.then((result) => {
        span.end();
        return result;
      }).catch((error) => {
        span.setStatus({
          code: api_1.SpanStatusCode.ERROR,
          message: utils.getErrorMessage(error)
        });
        span.end();
        return Promise.reject(error);
      }));
    }
  }
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/types.js
var require_types11 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-pg/build/src/types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@opentelemetry/instrumentation-pg/build/src/index.js
var require_src15 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-pg/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_instrumentation10(), exports);
    __exportStar(require_types11(), exports);
    __exportStar(require_AttributeNames7(), exports);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-hapi/build/src/version.js
var require_version13 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-hapi/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.40.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-hapi";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-hapi/build/src/internal-types.js
var require_internal_types4 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-hapi/build/src/internal-types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HapiLifecycleMethodNames = exports.HapiLayerType = exports.handlerPatched = exports.HapiComponentName = void 0;
    exports.HapiComponentName = "@hapi/hapi";
    exports.handlerPatched = Symbol("hapi-handler-patched");
    exports.HapiLayerType = {
      ROUTER: "router",
      PLUGIN: "plugin",
      EXT: "server.ext"
    };
    exports.HapiLifecycleMethodNames = /* @__PURE__ */ new Set([
      "onPreAuth",
      "onCredentials",
      "onPostAuth",
      "onPreHandler",
      "onPostHandler",
      "onPreResponse",
      "onRequest"
    ]);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-hapi/build/src/enums/AttributeNames.js
var require_AttributeNames8 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-hapi/build/src/enums/AttributeNames.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeNames = void 0;
    var AttributeNames;
    (function(AttributeNames2) {
      AttributeNames2["HAPI_TYPE"] = "hapi.type";
      AttributeNames2["PLUGIN_NAME"] = "hapi.plugin.name";
      AttributeNames2["EXT_TYPE"] = "server.ext.type";
    })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-hapi/build/src/utils.js
var require_utils11 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-hapi/build/src/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPluginFromInput = exports.getExtMetadata = exports.getRouteMetadata = exports.isPatchableExtMethod = exports.isDirectExtInput = exports.isLifecycleExtEventObj = exports.isLifecycleExtType = exports.getPluginName = void 0;
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var internal_types_1 = require_internal_types4();
    var AttributeNames_1 = require_AttributeNames8();
    function getPluginName(plugin) {
      if (plugin.name) {
        return plugin.name;
      } else {
        return plugin.pkg.name;
      }
    }
    exports.getPluginName = getPluginName;
    var isLifecycleExtType = (variableToCheck) => {
      return typeof variableToCheck === "string" && internal_types_1.HapiLifecycleMethodNames.has(variableToCheck);
    };
    exports.isLifecycleExtType = isLifecycleExtType;
    var isLifecycleExtEventObj = (variableToCheck) => {
      var _a2;
      const event = (_a2 = variableToCheck) === null || _a2 === void 0 ? void 0 : _a2.type;
      return event !== void 0 && (0, exports.isLifecycleExtType)(event);
    };
    exports.isLifecycleExtEventObj = isLifecycleExtEventObj;
    var isDirectExtInput = (variableToCheck) => {
      return Array.isArray(variableToCheck) && variableToCheck.length <= 3 && (0, exports.isLifecycleExtType)(variableToCheck[0]) && typeof variableToCheck[1] === "function";
    };
    exports.isDirectExtInput = isDirectExtInput;
    var isPatchableExtMethod = (variableToCheck) => {
      return !Array.isArray(variableToCheck);
    };
    exports.isPatchableExtMethod = isPatchableExtMethod;
    var getRouteMetadata = (route, pluginName) => {
      if (pluginName) {
        return {
          attributes: {
            [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: route.path,
            [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: route.method,
            [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.PLUGIN,
            [AttributeNames_1.AttributeNames.PLUGIN_NAME]: pluginName
          },
          name: `${pluginName}: route - ${route.path}`
        };
      }
      return {
        attributes: {
          [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: route.path,
          [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: route.method,
          [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.ROUTER
        },
        name: `route - ${route.path}`
      };
    };
    exports.getRouteMetadata = getRouteMetadata;
    var getExtMetadata = (extPoint, pluginName) => {
      if (pluginName) {
        return {
          attributes: {
            [AttributeNames_1.AttributeNames.EXT_TYPE]: extPoint,
            [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.EXT,
            [AttributeNames_1.AttributeNames.PLUGIN_NAME]: pluginName
          },
          name: `${pluginName}: ext - ${extPoint}`
        };
      }
      return {
        attributes: {
          [AttributeNames_1.AttributeNames.EXT_TYPE]: extPoint,
          [AttributeNames_1.AttributeNames.HAPI_TYPE]: internal_types_1.HapiLayerType.EXT
        },
        name: `ext - ${extPoint}`
      };
    };
    exports.getExtMetadata = getExtMetadata;
    var getPluginFromInput = (pluginObj) => {
      if ("plugin" in pluginObj) {
        if ("plugin" in pluginObj.plugin) {
          return pluginObj.plugin.plugin;
        }
        return pluginObj.plugin;
      }
      return pluginObj;
    };
    exports.getPluginFromInput = getPluginFromInput;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-hapi/build/src/instrumentation.js
var require_instrumentation11 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-hapi/build/src/instrumentation.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HapiInstrumentation = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var version_1 = require_version13();
    var internal_types_1 = require_internal_types4();
    var utils_1 = require_utils11();
    var HapiInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      }
      init() {
        return new instrumentation_1.InstrumentationNodeModuleDefinition(internal_types_1.HapiComponentName, [">=17.0.0 <22"], (module3) => {
          const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
          if (!(0, instrumentation_1.isWrapped)(moduleExports.server)) {
            this._wrap(moduleExports, "server", this._getServerPatch.bind(this));
          }
          if (!(0, instrumentation_1.isWrapped)(moduleExports.Server)) {
            this._wrap(moduleExports, "Server", this._getServerPatch.bind(this));
          }
          return moduleExports;
        }, (module3) => {
          const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
          this._massUnwrap([moduleExports], ["server", "Server"]);
        });
      }
      /**
       * Patches the Hapi.server and Hapi.Server functions in order to instrument
       * the server.route, server.ext, and server.register functions via calls to the
       * @function _getServerRoutePatch, @function _getServerExtPatch, and
       * @function _getServerRegisterPatch functions
       * @param original - the original Hapi Server creation function
       */
      _getServerPatch(original) {
        const instrumentation = this;
        const self = this;
        return function server(opts) {
          const newServer = original.apply(this, [opts]);
          self._wrap(newServer, "route", (originalRouter) => {
            return instrumentation._getServerRoutePatch.bind(instrumentation)(originalRouter);
          });
          self._wrap(newServer, "ext", (originalExtHandler) => {
            return instrumentation._getServerExtPatch.bind(instrumentation)(
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              originalExtHandler
            );
          });
          self._wrap(
            newServer,
            "register",
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            instrumentation._getServerRegisterPatch.bind(instrumentation)
          );
          return newServer;
        };
      }
      /**
       * Patches the plugin register function used by the Hapi Server. This function
       * goes through each plugin that is being registered and adds instrumentation
       * via a call to the @function _wrapRegisterHandler function.
       * @param {RegisterFunction<T>} original - the original register function which
       * registers each plugin on the server
       */
      _getServerRegisterPatch(original) {
        const instrumentation = this;
        return function register(pluginInput, options) {
          if (Array.isArray(pluginInput)) {
            for (const pluginObj of pluginInput) {
              const plugin = (0, utils_1.getPluginFromInput)(pluginObj);
              instrumentation._wrapRegisterHandler(plugin);
            }
          } else {
            const plugin = (0, utils_1.getPluginFromInput)(pluginInput);
            instrumentation._wrapRegisterHandler(plugin);
          }
          return original.apply(this, [pluginInput, options]);
        };
      }
      /**
       * Patches the Server.ext function which adds extension methods to the specified
       * point along the request lifecycle. This function accepts the full range of
       * accepted input into the standard Hapi `server.ext` function. For each extension,
       * it adds instrumentation to the handler via a call to the @function _wrapExtMethods
       * function.
       * @param original - the original ext function which adds the extension method to the server
       * @param {string} [pluginName] - if present, represents the name of the plugin responsible
       * for adding this server extension. Else, signifies that the extension was added directly
       */
      _getServerExtPatch(original, pluginName) {
        const instrumentation = this;
        return function ext(...args) {
          if (Array.isArray(args[0])) {
            const eventsList = args[0];
            for (let i = 0; i < eventsList.length; i++) {
              const eventObj = eventsList[i];
              if ((0, utils_1.isLifecycleExtType)(eventObj.type)) {
                const lifecycleEventObj = eventObj;
                const handler = instrumentation._wrapExtMethods(lifecycleEventObj.method, eventObj.type, pluginName);
                lifecycleEventObj.method = handler;
                eventsList[i] = lifecycleEventObj;
              }
            }
            return original.apply(this, args);
          } else if ((0, utils_1.isDirectExtInput)(args)) {
            const extInput = args;
            const method = extInput[1];
            const handler = instrumentation._wrapExtMethods(method, extInput[0], pluginName);
            return original.apply(this, [extInput[0], handler, extInput[2]]);
          } else if ((0, utils_1.isLifecycleExtEventObj)(args[0])) {
            const lifecycleEventObj = args[0];
            const handler = instrumentation._wrapExtMethods(lifecycleEventObj.method, lifecycleEventObj.type, pluginName);
            lifecycleEventObj.method = handler;
            return original.call(this, lifecycleEventObj);
          }
          return original.apply(this, args);
        };
      }
      /**
       * Patches the Server.route function. This function accepts either one or an array
       * of Hapi.ServerRoute objects and adds instrumentation on each route via a call to
       * the @function _wrapRouteHandler function.
       * @param {HapiServerRouteInputMethod} original - the original route function which adds
       * the route to the server
       * @param {string} [pluginName] - if present, represents the name of the plugin responsible
       * for adding this server route. Else, signifies that the route was added directly
       */
      _getServerRoutePatch(original, pluginName) {
        const instrumentation = this;
        return function route(route) {
          if (Array.isArray(route)) {
            for (let i = 0; i < route.length; i++) {
              const newRoute = instrumentation._wrapRouteHandler.call(instrumentation, route[i], pluginName);
              route[i] = newRoute;
            }
          } else {
            route = instrumentation._wrapRouteHandler.call(instrumentation, route, pluginName);
          }
          return original.apply(this, [route]);
        };
      }
      /**
       * Wraps newly registered plugins to add instrumentation to the plugin's clone of
       * the original server. Specifically, wraps the server.route and server.ext functions
       * via calls to @function _getServerRoutePatch and @function _getServerExtPatch
       * @param {Hapi.Plugin<T>} plugin - the new plugin which is being instrumented
       */
      _wrapRegisterHandler(plugin) {
        const instrumentation = this;
        const pluginName = (0, utils_1.getPluginName)(plugin);
        const oldHandler = plugin.register;
        const self = this;
        const newRegisterHandler = function(server, options) {
          self._wrap(server, "route", (original) => {
            return instrumentation._getServerRoutePatch.bind(instrumentation)(original, pluginName);
          });
          self._wrap(server, "ext", (originalExtHandler) => {
            return instrumentation._getServerExtPatch.bind(instrumentation)(
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              originalExtHandler,
              pluginName
            );
          });
          return oldHandler(server, options);
        };
        plugin.register = newRegisterHandler;
      }
      /**
       * Wraps request extension methods to add instrumentation to each new extension handler.
       * Patches each individual extension in order to create the
       * span and propagate context. It does not create spans when there is no parent span.
       * @param {PatchableExtMethod | PatchableExtMethod[]} method - the request extension
       * handler which is being instrumented
       * @param {Hapi.ServerRequestExtType} extPoint - the point in the Hapi request lifecycle
       * which this extension targets
       * @param {string} [pluginName] - if present, represents the name of the plugin responsible
       * for adding this server route. Else, signifies that the route was added directly
       */
      _wrapExtMethods(method, extPoint, pluginName) {
        const instrumentation = this;
        if (method instanceof Array) {
          for (let i = 0; i < method.length; i++) {
            method[i] = instrumentation._wrapExtMethods(method[i], extPoint);
          }
          return method;
        } else if ((0, utils_1.isPatchableExtMethod)(method)) {
          if (method[internal_types_1.handlerPatched] === true)
            return method;
          method[internal_types_1.handlerPatched] = true;
          const newHandler = async function(...params) {
            if (api.trace.getSpan(api.context.active()) === void 0) {
              return await method.apply(this, params);
            }
            const metadata = (0, utils_1.getExtMetadata)(extPoint, pluginName);
            const span = instrumentation.tracer.startSpan(metadata.name, {
              attributes: metadata.attributes
            });
            try {
              return await api.context.with(api.trace.setSpan(api.context.active(), span), method, void 0, ...params);
            } catch (err) {
              span.recordException(err);
              span.setStatus({
                code: api.SpanStatusCode.ERROR,
                message: err.message
              });
              throw err;
            } finally {
              span.end();
            }
          };
          return newHandler;
        }
        return method;
      }
      /**
       * Patches each individual route handler method in order to create the
       * span and propagate context. It does not create spans when there is no parent span.
       * @param {PatchableServerRoute} route - the route handler which is being instrumented
       * @param {string} [pluginName] - if present, represents the name of the plugin responsible
       * for adding this server route. Else, signifies that the route was added directly
       */
      _wrapRouteHandler(route, pluginName) {
        var _a2;
        const instrumentation = this;
        if (route[internal_types_1.handlerPatched] === true)
          return route;
        route[internal_types_1.handlerPatched] = true;
        const wrapHandler = (oldHandler) => {
          return async function(...params) {
            if (api.trace.getSpan(api.context.active()) === void 0) {
              return await oldHandler.call(this, ...params);
            }
            const rpcMetadata = (0, core_1.getRPCMetadata)(api.context.active());
            if ((rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP) {
              rpcMetadata.route = route.path;
            }
            const metadata = (0, utils_1.getRouteMetadata)(route, pluginName);
            const span = instrumentation.tracer.startSpan(metadata.name, {
              attributes: metadata.attributes
            });
            try {
              return await api.context.with(api.trace.setSpan(api.context.active(), span), () => oldHandler.call(this, ...params));
            } catch (err) {
              span.recordException(err);
              span.setStatus({
                code: api.SpanStatusCode.ERROR,
                message: err.message
              });
              throw err;
            } finally {
              span.end();
            }
          };
        };
        if (typeof route.handler === "function") {
          route.handler = wrapHandler(route.handler);
        } else if (typeof route.options === "function") {
          const oldOptions = route.options;
          route.options = function(server) {
            const options = oldOptions(server);
            if (typeof options.handler === "function") {
              options.handler = wrapHandler(options.handler);
            }
            return options;
          };
        } else if (typeof ((_a2 = route.options) === null || _a2 === void 0 ? void 0 : _a2.handler) === "function") {
          route.options.handler = wrapHandler(route.options.handler);
        }
        return route;
      }
    };
    exports.HapiInstrumentation = HapiInstrumentation2;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-hapi/build/src/index.js
var require_src16 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-hapi/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_instrumentation11(), exports);
    __exportStar(require_AttributeNames8(), exports);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/types.js
var require_types12 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-koa/build/src/types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KoaLayerType = void 0;
    var KoaLayerType;
    (function(KoaLayerType2) {
      KoaLayerType2["ROUTER"] = "router";
      KoaLayerType2["MIDDLEWARE"] = "middleware";
    })(KoaLayerType = exports.KoaLayerType || (exports.KoaLayerType = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/version.js
var require_version14 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-koa/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.42.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-koa";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/enums/AttributeNames.js
var require_AttributeNames9 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-koa/build/src/enums/AttributeNames.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeNames = void 0;
    var AttributeNames;
    (function(AttributeNames2) {
      AttributeNames2["KOA_TYPE"] = "koa.type";
      AttributeNames2["KOA_NAME"] = "koa.name";
    })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/utils.js
var require_utils12 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-koa/build/src/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isLayerIgnored = exports.getMiddlewareMetadata = void 0;
    var types_1 = require_types12();
    var AttributeNames_1 = require_AttributeNames9();
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var getMiddlewareMetadata = (context2, layer, isRouter, layerPath) => {
      var _a2;
      if (isRouter) {
        return {
          attributes: {
            [AttributeNames_1.AttributeNames.KOA_NAME]: layerPath === null || layerPath === void 0 ? void 0 : layerPath.toString(),
            [AttributeNames_1.AttributeNames.KOA_TYPE]: types_1.KoaLayerType.ROUTER,
            [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: layerPath === null || layerPath === void 0 ? void 0 : layerPath.toString()
          },
          name: context2._matchedRouteName || `router - ${layerPath}`
        };
      } else {
        return {
          attributes: {
            [AttributeNames_1.AttributeNames.KOA_NAME]: (_a2 = layer.name) !== null && _a2 !== void 0 ? _a2 : "middleware",
            [AttributeNames_1.AttributeNames.KOA_TYPE]: types_1.KoaLayerType.MIDDLEWARE
          },
          name: `middleware - ${layer.name}`
        };
      }
    };
    exports.getMiddlewareMetadata = getMiddlewareMetadata;
    var isLayerIgnored = (type, config) => {
      var _a2;
      return !!(Array.isArray(config === null || config === void 0 ? void 0 : config.ignoreLayersType) && ((_a2 = config === null || config === void 0 ? void 0 : config.ignoreLayersType) === null || _a2 === void 0 ? void 0 : _a2.includes(type)));
    };
    exports.isLayerIgnored = isLayerIgnored;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/internal-types.js
var require_internal_types5 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-koa/build/src/internal-types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.kLayerPatched = void 0;
    exports.kLayerPatched = Symbol("koa-layer-patched");
  }
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/instrumentation.js
var require_instrumentation12 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-koa/build/src/instrumentation.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KoaInstrumentation = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var types_1 = require_types12();
    var version_1 = require_version14();
    var utils_1 = require_utils12();
    var core_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var internal_types_1 = require_internal_types5();
    var KoaInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      }
      setConfig(config = {}) {
        this._config = Object.assign({}, config);
      }
      getConfig() {
        return this._config;
      }
      init() {
        return new instrumentation_1.InstrumentationNodeModuleDefinition("koa", [">=2.0.0 <3"], (module3) => {
          const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
          if (moduleExports == null) {
            return moduleExports;
          }
          if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.use)) {
            this._unwrap(moduleExports.prototype, "use");
          }
          this._wrap(moduleExports.prototype, "use", this._getKoaUsePatch.bind(this));
          return module3;
        }, (module3) => {
          const moduleExports = module3[Symbol.toStringTag] === "Module" ? module3.default : module3;
          if ((0, instrumentation_1.isWrapped)(moduleExports.prototype.use)) {
            this._unwrap(moduleExports.prototype, "use");
          }
        });
      }
      /**
       * Patches the Koa.use function in order to instrument each original
       * middleware layer which is introduced
       * @param {KoaMiddleware} middleware - the original middleware function
       */
      _getKoaUsePatch(original) {
        const plugin = this;
        return function use(middlewareFunction) {
          let patchedFunction;
          if (middlewareFunction.router) {
            patchedFunction = plugin._patchRouterDispatch(middlewareFunction);
          } else {
            patchedFunction = plugin._patchLayer(middlewareFunction, false);
          }
          return original.apply(this, [patchedFunction]);
        };
      }
      /**
       * Patches the dispatch function used by @koa/router. This function
       * goes through each routed middleware and adds instrumentation via a call
       * to the @function _patchLayer function.
       * @param {KoaMiddleware} dispatchLayer - the original dispatch function which dispatches
       * routed middleware
       */
      _patchRouterDispatch(dispatchLayer) {
        var _a2;
        api.diag.debug("Patching @koa/router dispatch");
        const router = dispatchLayer.router;
        const routesStack = (_a2 = router === null || router === void 0 ? void 0 : router.stack) !== null && _a2 !== void 0 ? _a2 : [];
        for (const pathLayer of routesStack) {
          const path3 = pathLayer.path;
          const pathStack = pathLayer.stack;
          for (let j = 0; j < pathStack.length; j++) {
            const routedMiddleware = pathStack[j];
            pathStack[j] = this._patchLayer(routedMiddleware, true, path3);
          }
        }
        return dispatchLayer;
      }
      /**
       * Patches each individual @param middlewareLayer function in order to create the
       * span and propagate context. It does not create spans when there is no parent span.
       * @param {KoaMiddleware} middlewareLayer - the original middleware function.
       * @param {boolean} isRouter - tracks whether the original middleware function
       * was dispatched by the router originally
       * @param {string?} layerPath - if present, provides additional data from the
       * router about the routed path which the middleware is attached to
       */
      _patchLayer(middlewareLayer, isRouter, layerPath) {
        const layerType = isRouter ? types_1.KoaLayerType.ROUTER : types_1.KoaLayerType.MIDDLEWARE;
        if (middlewareLayer[internal_types_1.kLayerPatched] === true || (0, utils_1.isLayerIgnored)(layerType, this.getConfig()))
          return middlewareLayer;
        if (middlewareLayer.constructor.name === "GeneratorFunction" || middlewareLayer.constructor.name === "AsyncGeneratorFunction") {
          api.diag.debug("ignoring generator-based Koa middleware layer");
          return middlewareLayer;
        }
        middlewareLayer[internal_types_1.kLayerPatched] = true;
        api.diag.debug("patching Koa middleware layer");
        return async (context2, next) => {
          const parent = api.trace.getSpan(api.context.active());
          if (parent === void 0) {
            return middlewareLayer(context2, next);
          }
          const metadata = (0, utils_1.getMiddlewareMetadata)(context2, middlewareLayer, isRouter, layerPath);
          const span = this.tracer.startSpan(metadata.name, {
            attributes: metadata.attributes
          });
          const rpcMetadata = (0, core_1.getRPCMetadata)(api.context.active());
          if ((rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP && context2._matchedRoute) {
            rpcMetadata.route = context2._matchedRoute.toString();
          }
          if (this.getConfig().requestHook) {
            (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().requestHook(span, {
              context: context2,
              middlewareLayer,
              layerType
            }), (e) => {
              if (e) {
                api.diag.error("koa instrumentation: request hook failed", e);
              }
            }, true);
          }
          const newContext = api.trace.setSpan(api.context.active(), span);
          return api.context.with(newContext, async () => {
            try {
              return await middlewareLayer(context2, next);
            } catch (err) {
              span.recordException(err);
              throw err;
            } finally {
              span.end();
            }
          });
        };
      }
    };
    exports.KoaInstrumentation = KoaInstrumentation2;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-koa/build/src/index.js
var require_src17 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-koa/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_instrumentation12(), exports);
    __exportStar(require_types12(), exports);
    __exportStar(require_AttributeNames9(), exports);
  }
});

// ../../node_modules/@opentelemetry/instrumentation-connect/build/src/enums/AttributeNames.js
var require_AttributeNames10 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-connect/build/src/enums/AttributeNames.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectNames = exports.ConnectTypes = exports.AttributeNames = void 0;
    var AttributeNames;
    (function(AttributeNames2) {
      AttributeNames2["CONNECT_TYPE"] = "connect.type";
      AttributeNames2["CONNECT_NAME"] = "connect.name";
    })(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));
    var ConnectTypes;
    (function(ConnectTypes2) {
      ConnectTypes2["MIDDLEWARE"] = "middleware";
      ConnectTypes2["REQUEST_HANDLER"] = "request_handler";
    })(ConnectTypes = exports.ConnectTypes || (exports.ConnectTypes = {}));
    var ConnectNames;
    (function(ConnectNames2) {
      ConnectNames2["MIDDLEWARE"] = "middleware";
      ConnectNames2["REQUEST_HANDLER"] = "request handler";
    })(ConnectNames = exports.ConnectNames || (exports.ConnectNames = {}));
  }
});

// ../../node_modules/@opentelemetry/instrumentation-connect/build/src/version.js
var require_version15 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-connect/build/src/version.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;
    exports.PACKAGE_VERSION = "0.38.0";
    exports.PACKAGE_NAME = "@opentelemetry/instrumentation-connect";
  }
});

// ../../node_modules/@opentelemetry/instrumentation-connect/build/src/internal-types.js
var require_internal_types6 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-connect/build/src/internal-types.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._LAYERS_STORE_PROPERTY = void 0;
    exports._LAYERS_STORE_PROPERTY = Symbol("opentelemetry.instrumentation-connect.request-route-stack");
  }
});

// ../../node_modules/@opentelemetry/instrumentation-connect/build/src/utils.js
var require_utils13 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-connect/build/src/utils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateRoute = exports.replaceCurrentStackRoute = exports.addNewStackLayer = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var internal_types_1 = require_internal_types6();
    var addNewStackLayer = (request) => {
      if (Array.isArray(request[internal_types_1._LAYERS_STORE_PROPERTY]) === false) {
        Object.defineProperty(request, internal_types_1._LAYERS_STORE_PROPERTY, {
          enumerable: false,
          value: []
        });
      }
      request[internal_types_1._LAYERS_STORE_PROPERTY].push("/");
      const stackLength = request[internal_types_1._LAYERS_STORE_PROPERTY].length;
      return () => {
        if (stackLength === request[internal_types_1._LAYERS_STORE_PROPERTY].length) {
          request[internal_types_1._LAYERS_STORE_PROPERTY].pop();
        } else {
          api_1.diag.warn("Connect: Trying to pop the stack multiple time");
        }
      };
    };
    exports.addNewStackLayer = addNewStackLayer;
    var replaceCurrentStackRoute = (request, newRoute) => {
      if (newRoute) {
        request[internal_types_1._LAYERS_STORE_PROPERTY].splice(-1, 1, newRoute);
      }
    };
    exports.replaceCurrentStackRoute = replaceCurrentStackRoute;
    var generateRoute = (request) => {
      return request[internal_types_1._LAYERS_STORE_PROPERTY].reduce((acc, sub) => acc.replace(/\/+$/, "") + sub);
    };
    exports.generateRoute = generateRoute;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-connect/build/src/instrumentation.js
var require_instrumentation13 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-connect/build/src/instrumentation.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectInstrumentation = exports.ANONYMOUS_NAME = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var AttributeNames_1 = require_AttributeNames10();
    var version_1 = require_version15();
    var instrumentation_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var utils_1 = require_utils13();
    exports.ANONYMOUS_NAME = "anonymous";
    var ConnectInstrumentation2 = class extends instrumentation_1.InstrumentationBase {
      constructor(config = {}) {
        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);
      }
      init() {
        return [
          new instrumentation_1.InstrumentationNodeModuleDefinition("connect", [">=3.0.0 <4"], (moduleExports) => {
            return this._patchConstructor(moduleExports);
          })
        ];
      }
      _patchApp(patchedApp) {
        if (!(0, instrumentation_1.isWrapped)(patchedApp.use)) {
          this._wrap(patchedApp, "use", this._patchUse.bind(this));
        }
        if (!(0, instrumentation_1.isWrapped)(patchedApp.handle)) {
          this._wrap(patchedApp, "handle", this._patchHandle.bind(this));
        }
      }
      _patchConstructor(original) {
        const instrumentation = this;
        return function(...args) {
          const app = original.apply(this, args);
          instrumentation._patchApp(app);
          return app;
        };
      }
      _patchNext(next, finishSpan) {
        return function nextFunction(err) {
          const result = next.apply(this, [err]);
          finishSpan();
          return result;
        };
      }
      _startSpan(routeName, middleWare) {
        let connectType;
        let connectName;
        let connectTypeName;
        if (routeName) {
          connectType = AttributeNames_1.ConnectTypes.REQUEST_HANDLER;
          connectTypeName = AttributeNames_1.ConnectNames.REQUEST_HANDLER;
          connectName = routeName;
        } else {
          connectType = AttributeNames_1.ConnectTypes.MIDDLEWARE;
          connectTypeName = AttributeNames_1.ConnectNames.MIDDLEWARE;
          connectName = middleWare.name || exports.ANONYMOUS_NAME;
        }
        const spanName = `${connectTypeName} - ${connectName}`;
        const options = {
          attributes: {
            [semantic_conventions_1.SEMATTRS_HTTP_ROUTE]: routeName.length > 0 ? routeName : "/",
            [AttributeNames_1.AttributeNames.CONNECT_TYPE]: connectType,
            [AttributeNames_1.AttributeNames.CONNECT_NAME]: connectName
          }
        };
        return this.tracer.startSpan(spanName, options);
      }
      _patchMiddleware(routeName, middleWare) {
        const instrumentation = this;
        const isErrorMiddleware = middleWare.length === 4;
        function patchedMiddleware() {
          if (!instrumentation.isEnabled()) {
            return middleWare.apply(this, arguments);
          }
          const [reqArgIdx, resArgIdx, nextArgIdx] = isErrorMiddleware ? [1, 2, 3] : [0, 1, 2];
          const req = arguments[reqArgIdx];
          const res = arguments[resArgIdx];
          const next = arguments[nextArgIdx];
          (0, utils_1.replaceCurrentStackRoute)(req, routeName);
          const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());
          if (routeName && (rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP) {
            rpcMetadata.route = (0, utils_1.generateRoute)(req);
          }
          let spanName = "";
          if (routeName) {
            spanName = `request handler - ${routeName}`;
          } else {
            spanName = `middleware - ${middleWare.name || exports.ANONYMOUS_NAME}`;
          }
          const span = instrumentation._startSpan(routeName, middleWare);
          instrumentation._diag.debug("start span", spanName);
          let spanFinished = false;
          function finishSpan() {
            if (!spanFinished) {
              spanFinished = true;
              instrumentation._diag.debug(`finishing span ${span.name}`);
              span.end();
            } else {
              instrumentation._diag.debug(`span ${span.name} - already finished`);
            }
            res.removeListener("close", finishSpan);
          }
          res.addListener("close", finishSpan);
          arguments[nextArgIdx] = instrumentation._patchNext(next, finishSpan);
          return middleWare.apply(this, arguments);
        }
        Object.defineProperty(patchedMiddleware, "length", {
          value: middleWare.length,
          writable: false,
          configurable: true
        });
        return patchedMiddleware;
      }
      _patchUse(original) {
        const instrumentation = this;
        return function(...args) {
          const middleWare = args[args.length - 1];
          const routeName = args[args.length - 2] || "";
          args[args.length - 1] = instrumentation._patchMiddleware(routeName, middleWare);
          return original.apply(this, args);
        };
      }
      _patchHandle(original) {
        const instrumentation = this;
        return function() {
          const [reqIdx, outIdx] = [0, 2];
          const req = arguments[reqIdx];
          const out = arguments[outIdx];
          const completeStack = (0, utils_1.addNewStackLayer)(req);
          if (typeof out === "function") {
            arguments[outIdx] = instrumentation._patchOut(out, completeStack);
          }
          return original.apply(this, arguments);
        };
      }
      _patchOut(out, completeStack) {
        return function nextFunction(...args) {
          completeStack();
          return Reflect.apply(out, this, args);
        };
      }
    };
    exports.ConnectInstrumentation = ConnectInstrumentation2;
  }
});

// ../../node_modules/@opentelemetry/instrumentation-connect/build/src/index.js
var require_src18 = __commonJS({
  "../../node_modules/@opentelemetry/instrumentation-connect/build/src/index.js"(exports) {
    "use strict";
    init_esm_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_AttributeNames10(), exports);
    __exportStar(require_instrumentation13(), exports);
  }
});

// ../cli-telemetry-react/src/useBi.tsx
init_esm_shims();
var import_react = __toESM(require_react(), 1);
var BiContext = (0, import_react.createContext)(null);
var BiProvider = function({
  children,
  value: biLogger
}) {
  return /* @__PURE__ */ import_react.default.createElement(BiContext.Provider, { value: biLogger }, children);
};
var useBiLogger = () => {
  const context2 = (0, import_react.useContext)(BiContext);
  if (context2 == null) {
    throw new Error("useBiLogger() cannot be used without an <BiProvider>");
  }
  return context2;
};

// ../cli-telemetry-react/src/index.ts
init_esm_shims();

// ../cli-debug-log/src/index.tsx
init_esm_shims();
var import_react2 = __toESM(require_react(), 1);
var import_verror2 = __toESM(require_verror(), 1);
import { dirname as dirname2 } from "node:path";
import { appendFileSync, mkdirSync } from "node:fs";

// ../cli-http-client/src/extract-error.ts
init_esm_shims();
var import_http_client = __toESM(require_index_node(), 1);
var import_verror = __toESM(require_verror(), 1);
function extractHttpError(error) {
  if (import_http_client.HttpClient.isHttpError(error)) {
    return error;
  }
  const nestedError = error instanceof Error ? import_verror.default.cause(error) : null;
  return nestedError ? extractHttpError(nestedError) : null;
}

// ../cli-http-client/src/error-info.ts
init_esm_shims();
function getHttpErrorInfo(httpError) {
  return {
    request: {
      baseURL: httpError.config.baseURL,
      url: httpError.config.url,
      method: httpError.config.method,
      headers: httpError.config.headers,
      data: httpError.config.data
    },
    response: {
      code: httpError.code,
      message: httpError.message,
      status: httpError.response?.status,
      headers: httpError.response?.headers,
      data: httpError.response?.data
    }
  };
}

// ../cli-debug-log/src/index.tsx
function writeCrashReport(reportPath, error) {
  try {
    let content = `----- CLI crash report at ${(/* @__PURE__ */ new Date()).toISOString()}
`;
    if (error instanceof Error) {
      content += `Error Trace
`;
      content += `${import_verror2.default.fullStack(error)}
`;
      content += `Error Info
`;
      content += `${JSON.stringify(import_verror2.default.info(error), null, 2)}
`;
      const httpError = extractHttpError(error);
      if (httpError) {
        content += `Request Info
`;
        content += `${JSON.stringify(getHttpErrorInfo(httpError), null, 2)}
`;
      }
    }
    mkdirSync(dirname2(reportPath), { recursive: true });
    appendFileSync(reportPath, content);
  } catch {
  }
}
var DebugLogContext = (0, import_react2.createContext)(null);
var DebugLogProvider = ({ filePath, children }) => {
  const writeToDebugLog = (0, import_react2.useCallback)(
    (error) => writeCrashReport(filePath, error),
    [filePath]
  );
  return /* @__PURE__ */ import_react2.default.createElement(DebugLogContext.Provider, { value: writeToDebugLog }, children);
};
var useDebugLog = () => {
  const context2 = (0, import_react2.useContext)(DebugLogContext);
  if (context2 == null) {
    throw new Error(
      "useDebugLog() cannot be used without an <DebugLogProvider>"
    );
  }
  return context2;
};

// ../cli-error-reporting/src/components/OutdatedVersionMessage.tsx
init_esm_shims();
var import_react3 = __toESM(require_react(), 1);

// ../cli-error-reporting/src/messages.json
var messages_default = {
  "user_feedback.title": "Your experience matters to us. Would you like to submit feedback regarding this incident?",
  "user_feedback.subtitle": "We may contact you by email in case we need more details.",
  "user_feedback.consent.label": "Submit feedback?",
  "user_feedback.comments.label": "Feedback (optional)",
  "user_feedback.submitted": "Thank you for your cooperation in helping us resolve this issue promptly.",
  "user_feedback.declined": "Thank you for your feedback.",
  "user_feedback.contact_us": "Reach us in Discord in case you have more questions: <0 />",
  "version_notifier.deprecated.message": "Your version of the Wix CLI (<0>{currentVersion}</0>) is <1>deprecated</1>",
  "version_notifier.update.message": "Update available <0>{currentVersion}</0> -> <1>{latestVersion}</1>",
  "version_notifier.update.instructions": "Run <0>{packages}</0> to update"
};

// ../cli-error-reporting/src/components/OutdatedVersionMessage.tsx
var OutdatedVersionMessage = ({
  currentVersion,
  latestVersion,
  deprecated,
  hasCliAppInstalled
}) => {
  return /* @__PURE__ */ import_react3.default.createElement(I18nProvider, { messages: messages_default }, /* @__PURE__ */ import_react3.default.createElement(Notification, null, deprecated && /* @__PURE__ */ import_react3.default.createElement(
    Trans,
    {
      i18nKey: "version_notifier.deprecated.message",
      components: [/* @__PURE__ */ import_react3.default.createElement(Text, { skin: "secondary" }), /* @__PURE__ */ import_react3.default.createElement(Text, { bold: true })],
      values: {
        currentVersion
      }
    }
  ), /* @__PURE__ */ import_react3.default.createElement(
    Trans,
    {
      i18nKey: "version_notifier.update.message",
      components: [/* @__PURE__ */ import_react3.default.createElement(Text, { skin: "secondary" }), /* @__PURE__ */ import_react3.default.createElement(Text, { skin: "success" })],
      values: {
        currentVersion,
        latestVersion
      }
    }
  ), /* @__PURE__ */ import_react3.default.createElement(
    Trans,
    {
      i18nKey: "version_notifier.update.instructions",
      components: [/* @__PURE__ */ import_react3.default.createElement(Text, { skin: "info" })],
      values: {
        packages: hasCliAppInstalled ? "npm i @wix/cli@latest @wix/cli-app@latest" : "npm i -g @wix/cli@latest"
      }
    }
  )));
};

// ../cli-error-reporting/src/components/ErrorViewer.ts
init_esm_shims();
var import_react7 = __toESM(require_react(), 1);

// ../cli-error-reporting/src/get-error-component.tsx
init_esm_shims();
var import_react6 = __toESM(require_react(), 1);
var import_variant = __toESM(require_lib(), 1);

// ../../node_modules/outdent/lib-module/index.js
init_esm_shims();
function noop() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
}
function createWeakMap() {
  if (typeof WeakMap !== "undefined") {
    return /* @__PURE__ */ new WeakMap();
  } else {
    return fakeSetOrMap();
  }
}
function fakeSetOrMap() {
  return {
    add: noop,
    delete: noop,
    get: noop,
    set: noop,
    has: function(k) {
      return false;
    }
  };
}
var hop = Object.prototype.hasOwnProperty;
var has = function(obj, prop) {
  return hop.call(obj, prop);
};
function extend(target, source) {
  for (var prop in source) {
    if (has(source, prop)) {
      target[prop] = source[prop];
    }
  }
  return target;
}
var reLeadingNewline = /^[ \t]*(?:\r\n|\r|\n)/;
var reTrailingNewline = /(?:\r\n|\r|\n)[ \t]*$/;
var reStartsWithNewlineOrIsEmpty = /^(?:[\r\n]|$)/;
var reDetectIndentation = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/;
var reOnlyWhitespaceWithAtLeastOneNewline = /^[ \t]*[\r\n][ \t\r\n]*$/;
function _outdentArray(strings, firstInterpolatedValueSetsIndentationLevel, options) {
  var indentationLevel = 0;
  var match2 = strings[0].match(reDetectIndentation);
  if (match2) {
    indentationLevel = match2[1].length;
  }
  var reSource = "(\\r\\n|\\r|\\n).{0," + indentationLevel + "}";
  var reMatchIndent = new RegExp(reSource, "g");
  if (firstInterpolatedValueSetsIndentationLevel) {
    strings = strings.slice(1);
  }
  var newline = options.newline, trimLeadingNewline = options.trimLeadingNewline, trimTrailingNewline = options.trimTrailingNewline;
  var normalizeNewlines = typeof newline === "string";
  var l = strings.length;
  var outdentedStrings = strings.map(function(v, i) {
    v = v.replace(reMatchIndent, "$1");
    if (i === 0 && trimLeadingNewline) {
      v = v.replace(reLeadingNewline, "");
    }
    if (i === l - 1 && trimTrailingNewline) {
      v = v.replace(reTrailingNewline, "");
    }
    if (normalizeNewlines) {
      v = v.replace(/\r\n|\n|\r/g, function(_) {
        return newline;
      });
    }
    return v;
  });
  return outdentedStrings;
}
function concatStringsAndValues(strings, values) {
  var ret = "";
  for (var i = 0, l = strings.length; i < l; i++) {
    ret += strings[i];
    if (i < l - 1) {
      ret += values[i];
    }
  }
  return ret;
}
function isTemplateStringsArray(v) {
  return has(v, "raw") && has(v, "length");
}
function createInstance(options) {
  var arrayAutoIndentCache = createWeakMap();
  var arrayFirstInterpSetsIndentCache = createWeakMap();
  function outdent(stringsOrOptions) {
    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      values[_i - 1] = arguments[_i];
    }
    if (isTemplateStringsArray(stringsOrOptions)) {
      var strings = stringsOrOptions;
      var firstInterpolatedValueSetsIndentationLevel = (values[0] === outdent || values[0] === defaultOutdent) && reOnlyWhitespaceWithAtLeastOneNewline.test(strings[0]) && reStartsWithNewlineOrIsEmpty.test(strings[1]);
      var cache = firstInterpolatedValueSetsIndentationLevel ? arrayFirstInterpSetsIndentCache : arrayAutoIndentCache;
      var renderedArray = cache.get(strings);
      if (!renderedArray) {
        renderedArray = _outdentArray(strings, firstInterpolatedValueSetsIndentationLevel, options);
        cache.set(strings, renderedArray);
      }
      if (values.length === 0) {
        return renderedArray[0];
      }
      var rendered = concatStringsAndValues(renderedArray, firstInterpolatedValueSetsIndentationLevel ? values.slice(1) : values);
      return rendered;
    } else {
      return createInstance(extend(extend({}, options), stringsOrOptions || {}));
    }
  }
  var fullOutdent = extend(outdent, {
    string: function(str) {
      return _outdentArray([str], false, options)[0];
    }
  });
  return fullOutdent;
}
var defaultOutdent = createInstance({
  trimLeadingNewline: true,
  trimTrailingNewline: true
});
if (typeof module !== "undefined") {
  try {
    module.exports = defaultOutdent;
    Object.defineProperty(defaultOutdent, "__esModule", { value: true });
    defaultOutdent.default = defaultOutdent;
    defaultOutdent.outdent = defaultOutdent;
  } catch (e) {
  }
}

// ../cli-error-reporting/src/components/ErrorMessage.tsx
init_esm_shims();
var import_react4 = __toESM(require_react(), 1);
function getOriginalCause(error) {
  if (isCliError(error)) {
    return getOriginalCause(error.cause());
  }
  return error;
}
var ErrorMessage = ({ message, cause, explanation, hint }) => {
  const originalCause = getOriginalCause(cause);
  return /* @__PURE__ */ import_react4.default.createElement(
    ErrorDetails,
    {
      message: originalCause ? /* @__PURE__ */ import_react4.default.createElement(import_react4.default.Fragment, null, message, " Cause: ", originalCause.message) : message,
      hint,
      explanation
    }
  );
};
var SystemErrorMessage = ({ message, explanation, hint }) => /* @__PURE__ */ import_react4.default.createElement(
  ErrorDetails,
  {
    message,
    explanation,
    hint: hint ?? "This is probably a temporary system error and has been logged. Try again shortly."
  }
);

// ../cli-error-reporting/src/components/ServeDeprecationMessage.tsx
init_esm_shims();
var import_react5 = __toESM(require_react(), 1);
var ServeDeprecationMessage = ({
  packageManagerRunCmd
}) => {
  return /* @__PURE__ */ import_react5.default.createElement(Box_default, { rowGap: 1, paddingBottom: 1, flexDirection: "column" }, /* @__PURE__ */ import_react5.default.createElement(Alert, { type: "error" }, "Deprecation Notice"), /* @__PURE__ */ import_react5.default.createElement(Text, null, /* @__PURE__ */ import_react5.default.createElement(Text, { skin: "info" }, "serve"), " command is being replaced by", " ", /* @__PURE__ */ import_react5.default.createElement(Text, { skin: "info" }, "preview"), " command."), /* @__PURE__ */ import_react5.default.createElement(Text, null, "Please run", " ", /* @__PURE__ */ import_react5.default.createElement(Text, { skin: "info" }, packageManagerRunCmd ? `${packageManagerRunCmd} wix app preview` : "wix app preview"), " ", "instead."));
};

// ../cli-error-reporting/src/get-error-component.tsx
function getErrorComponent(code, cause) {
  return (0, import_variant.match)(code, {
    UnknownFailure: ({ error }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, /* @__PURE__ */ import_react6.default.createElement(Text, { skin: "error" }, "Oh no, seems like the CLI encountered an unexpected error:"), error instanceof Error ? /* @__PURE__ */ import_react6.default.createElement(Text, { skin: "error" }, error.message) : /* @__PURE__ */ import_react6.default.createElement(Text, null, JSON.stringify(error)));
    },
    FailedToGetDeviceCode: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "An error occurred while logging in: Failed to issue a login device code" });
    },
    FailedToGetAuthToken: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "An error occurred while logging in: Failed to issue refresh token" });
    },
    FailedToRefreshTokenForSite: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "An error occurred while logging in: Failed to issue refresh token for site" });
    },
    FailedToRenewAuthToken: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to renew access token." });
    },
    FailedToRenewAuthTokenSiteNotFound: ({ siteId }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Authenticate failed, your configured development site (${siteId}) could not be accessed`,
          hint: "Make sure the site exists and you still have access to it"
        }
      );
    },
    FailedToRenewAuthTokenRefreshTokenRevoked: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: "Failed to renew access token: refresh token has been revoked",
          hint: "Please login again to get a new refresh token"
        }
      );
    },
    FailedToRevokeRefreshToken: ({ email }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        SystemErrorMessage,
        {
          message: "An error occurred while trying to logout: Failed to revoke refresh token!",
          explanation: `Wix CLI is still logged in to account ${email}`
        }
      );
    },
    FailedToFetchPackageJson: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to fetch package data." });
    },
    FailedToCreateProjectFolder: ({ packageFolder }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: `Failed to create project folder: ${packageFolder}.`
        }
      );
    },
    LatestVersionOfCreateAppRequired: ({
      currentVersion,
      latestVersion,
      updateCommand
    }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, "Generating a Wix App is only supported using the latest version (", latestVersion, ") of ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "@wix/create-app"), " (current:", " ", currentVersion, ")"),
          hint: /* @__PURE__ */ import_react6.default.createElement(Text, null, "Make sure you are using the following command:", /* @__PURE__ */ import_react6.default.createElement(Newline, null), /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, updateCommand), /* @__PURE__ */ import_react6.default.createElement(Newline, null), "If the problem persists, try clearing your package manager's cache")
        }
      );
    },
    EmptyDirectoryRequiredAppGeneration: ({ folder }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, "Generating a Wix App requires an empty directory but", " ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, folder), " already exists and isn't empty"),
          hint: /* @__PURE__ */ import_react6.default.createElement(Text, null, "Choose a different project name or delete the existing", " ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, folder), " folder")
        }
      );
    },
    InvalidNewPackageName: ({ packageName, validations }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, "Generating a Wix App requires a valid npm package name for the generated ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "package.json"), " ", /* @__PURE__ */ import_react6.default.createElement(Newline, null), "The name ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, packageName), " failed the following validations:", /* @__PURE__ */ import_react6.default.createElement(Newline, null), validations.map((validation, id) => /* @__PURE__ */ import_react6.default.createElement(Text, { key: id }, /* @__PURE__ */ import_react6.default.createElement(Newline, null), "- ", validation))),
          hint: `Choose a different project name that follows the validations above`
        }
      );
    },
    SiteSelectorTimedout: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Waiting for application installation timed out.`
        }
      );
    },
    TypeErrorInvalidUrl: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: `Invalid assets URL.` });
    },
    UnsupportedPackageManager: ({ packageManagerName }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Unsupported package manager detected. Please use a supported one.`,
          hint: `Expected Yarn or NPM but ${packageManagerName ? `got ${packageManagerName}` : `failed to detect a package manager`}`
        }
      );
    },
    UnsupportedPackageManagerWorkspaces: ({ packageManagerName }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Generating a Wix App inside ${packageManagerName} workspaces is not supported`
        }
      );
    },
    FailedToGetDeveloperApps: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to get the list of your applications" });
    },
    FailedToCreateDevCenterApp: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to register your application in Wix" });
    },
    FailedToCreateDevCenterOAuthApp: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to register your oauth application in Wix" });
    },
    FailedToUpdateDevCenterOAuthApp: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to update your oauth application in Wix" });
    },
    FailedToAddPermission: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to add permission" });
    },
    FailedToGetPlacements: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to get placements" });
    },
    FailedToCreateTunnel: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to create tunnel" });
    },
    FailedToDeleteTunnel: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to delete tunnel" });
    },
    FailedToGetBlocksExtensionsData: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to get blocks extensions data" });
    },
    FailedToGetBlocksStructure: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to get blocks structure" });
    },
    FailedToUpdateBlocksAfterSync: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed updating blocks service after changes occoured" });
    },
    SitePermissionDenied: ({ siteId }) => {
      return () => {
        return /* @__PURE__ */ import_react6.default.createElement(
          ErrorMessage,
          {
            message: `You don't have permissions to site ${siteId}`
          }
        );
      };
    },
    AppPermissionDenied: ({ appId }) => {
      return () => {
        return /* @__PURE__ */ import_react6.default.createElement(
          ErrorMessage,
          {
            message: `You don't have permissions to application ${appId}`
          }
        );
      };
    },
    FailedToUpdateTelemetryConfig: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to change telemetry preferences" });
    },
    FailedToInstallPackage: ({ packageName }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: `Failed to install npm package ${packageName}.`
        }
      );
    },
    FailedToResolveNpmDependencies: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to resolve npm dependencies" });
    },
    FailedToInstallPackages: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { cause, message: "Failed to install npm packages." });
    },
    FailedMigrationToAnyNpm: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: "Could not start the migration process",
          explanation: "Make sure your `package.json` does not contain any packages under `dependencies`, as the migration cannot proceed if any are present.",
          hint: "If you need to keep any of these packages, move them to `devDependencies` before proceeding."
        }
      );
    },
    FailedToUninstallPackage: ({ packageName }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: `Failed to uninstall npm package ${packageName}.`
        }
      );
    },
    FailedToSyncToRevision: ({ revision }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Failed to sync the local project to revision ${revision}`
        }
      );
    },
    FailedToReadCache: ({ path: path3 }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: `Failed to read cache file at ${path3}.` });
    },
    FailedToWriteCache: ({ path: path3 }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: `Failed to write cache file at ${path3}.` });
    },
    UploadApplicationFailed: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to upload the application" });
    },
    BuiltProjectNeeded: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Can not find build output, please execute `wix app build` to build your app before proceeding" });
    },
    WixUninstallMissingPackageName: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Please specify a package name" });
    },
    FailedToReadJson: ({ filePath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { cause, message: `Failed to read ${filePath}.` });
    },
    FailedToReadFile: ({ filePath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { cause, message: `Failed to read ${filePath}.` });
    },
    InvalidJsonFile: ({ filePath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: `Invalid JSON file located at ${filePath}.`
        }
      );
    },
    FailedToWriteWixLock: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: `Failed to write 'wix.lock'` });
    },
    InvalidVeloConfigJson: ({ configFilename }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: `Invalid ${configFilename}, make sure it's configured correctly.`
        }
      );
    },
    DashboardPageConfigNotFound: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Dashboard page config not found at ${configPath}`
        }
      );
    },
    EmbeddedScriptConfigNotFound: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Embedded script config not found at ${configPath}`
        }
      );
    },
    CustomElementConfigNotFound: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Site widget config not found at ${configPath}`
        }
      );
    },
    SitePluginConfigNotFound: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Site plugin config not found at ${configPath}`
        }
      );
    },
    BlocksWidgetApiNotFound: ({ folderPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Blocks widget api file not found at ${folderPath}`
        }
      );
    },
    BlocksWidgetConfigNotFound: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Blocks widget config not found at ${configPath}`
        }
      );
    },
    BlocksWidgetPanelConfigNotFound: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Blocks widget panel config not found at ${configPath}`
        }
      );
    },
    NoExtensionsFound: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: "Your project doesn't seem to have any extensions.",
          explanation: "Extensions are the building blocks of your app.",
          hint: "Make sure it is configured properly, or read our documentation (\u200Bhttps://wix.to/b7o4Ml0) to start developing your first extension."
        }
      );
    },
    NoPagesDirectoryFound: ({ srcDir }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, "No ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "pages"), " directory was found under", " ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, srcDir), "."),
          hint: /* @__PURE__ */ import_react6.default.createElement(Text, null, "Consider re-cloning the project repository or creating a", " ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "pages"), " directory under ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, srcDir), ".")
        }
      );
    },
    DashboardPluginConfigNotFound: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Dashboard plugin config not found at ${configPath}`
        }
      );
    },
    DashboardMenuPluginConfigNotFound: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Dashboard menu plugin config not found at ${configPath}`
        }
      );
    },
    ServicePluginConfigNotFound: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Service plugin config not found at ${configPath}`
        }
      );
    },
    DashboardModalConfigNotFound: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Dashboard modal config not found at ${configPath}`
        }
      );
    },
    TSConfigNotFound: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `TypeScript config not found at \`${configPath}\``
        }
      );
    },
    InvalidTSConfigError: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: defaultOutdent`
            Invalid TypeScript configuration found at \`${configPath}\``
        }
      );
    },
    InvalidConfigSchemaError: ({ configPath, zodError }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: defaultOutdent`
            Invalid configuration found at \`${configPath}\`:
            The following errors were found:
            ${zodError.errors.map(formatZodIssue).join("\n")}`,
          hint: "Fix the errors above for your configurations to be applied successfully."
        }
      );
    },
    InvalidParamsOverrideSchemaError: ({ paramsOverridePath, zodError }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: defaultOutdent`
            Invalid params override found at \`${paramsOverridePath}\`:
            The following errors were found:
            ${zodError.errors.map(formatZodIssue).join("\n")}`,
          hint: "Fix the errors above for your params override to be applied successfully."
        }
      );
    },
    InvalidDependenciesJsonSchemaError: ({ path: path3, zodError }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: defaultOutdent`
            Invalid configuration found at \`${path3}\`:
            The following errors were found:
            ${zodError.errors.map(formatZodIssue).join("\n")}`,
          hint: /* @__PURE__ */ import_react6.default.createElement(Text, null, "Try to re-install ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "@wix/cli-app"), " dependency")
        }
      );
    },
    PermissionDenied: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Forbidden operation. Missing permissions" });
    },
    FailedToReadProjectFiles: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to read source files: make sure you have an 'src' folder and that it's readable."
        }
      );
    },
    GridAppFilesMaxLengthExceeded: ({ maxSizeViolationsData, filePaths }) => {
      let errorMessage = "Found one or more project files that are bigger than the allowed limit";
      if (maxSizeViolationsData?.files.length) {
        errorMessage += ` (${maxSizeViolationsData.expectedSize}KB): ${maxSizeViolationsData.files.map((f) => `${filePaths[f.fileIndex]} (${f.receivedSize}KB)`).join(", ")}`;
      }
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: errorMessage });
    },
    GridAppFailedToUpdateFiles: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: defaultOutdent`
            Failed to update files.
            Failed to sync changes from local files to the Dev Editor
            Still watching local files and will continue to sync changes...
          `
        }
      );
    },
    FailedToWatchFiles: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { cause, message: "Failed to watch files." });
    },
    FailedToCreateGridApp: ({ error }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: "Failed to create an isolated environment.",
          explanation: error
        }
      );
    },
    DeviceCodeTimedOut: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "The device code has not been approved in the time allocated, please start the login process again." });
    },
    DuplicateComponentIdsError: ({ issues }) => {
      const Issue = ({ issue }) => {
        const typeToName = (type) => (0, import_variant.match)(type, {
          page: () => "page",
          plugin: () => "plugin",
          "menu-plugin": () => "menu plugin",
          "sidebar-category": () => "sidebar category",
          "embedded-script": () => "embedded script",
          "custom-element": () => "custom element",
          "blocks-widget": () => "blocks widget",
          "blocks-widget-panel": () => "blocks widget panel",
          modal: () => "modal",
          topology: () => "topology",
          "site-plugin": () => "site plugin",
          monitoring: () => "monitoring",
          "site-component": () => "site component",
          "site-component-panel": () => "site component panel"
        });
        return /* @__PURE__ */ import_react6.default.createElement(Box_default, { flexDirection: "column" }, /* @__PURE__ */ import_react6.default.createElement(Text, null, /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "Duplicate ID: "), issue.id), /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "Extensions:"), issue.components.map(({ name, path: path3, type }) => /* @__PURE__ */ import_react6.default.createElement(Text, { key: path3 }, "[", typeToName(type), "] ", name, " (", path3, ")")), /* @__PURE__ */ import_react6.default.createElement(Text, null, /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "Possible GUID: "), issue.suggestedId));
      };
      return () => /* @__PURE__ */ import_react6.default.createElement(Box_default, { flexDirection: "column", rowGap: 1 }, /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: "Found multiple extensions with the same id, this might happen if you copy paste folders.",
          hint: "You can use the provided suggested GUIDs as the ID of the newly created extension."
        }
      ), issues.map((issue) => /* @__PURE__ */ import_react6.default.createElement(Issue, { issue, key: issue.id })));
    },
    InvalidResponseData: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Got unexpected response from server." });
    },
    InvalidCreateAppResponse: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "`createApp` returned an invalid response." });
    },
    InvalidDeployAppResponse: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Got unexpected response from server. Make sure you are running a supported version of the Velo CLI." });
    },
    InvalidGetDeploymentResponse: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Got unexpected response from server. Please try again later.." });
    },
    InvalidGetDeploymentPipelineDescriptionResponse: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Got unexpected response from server" });
    },
    FailedToGetPagesDiff: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to request pages diff." });
    },
    InvalidViteBuildOutput: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Invalid vite build output" });
    },
    ViteModuleBundleNotFound: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Could not find module bundle in vite build output" });
    },
    ViteFileNotFoundInOutput: ({ fileName }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Could not find ${fileName} in vite build output`
        }
      );
    },
    FailedToCreateBackendDeployment: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to create backend deployment" });
    },
    FailedToUpdateBackendDeployment: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to update backend deployment" });
    },
    FailedToGetBackendDeployment: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to get backend deployment" });
    },
    FailedToDeployBackend: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to deploy backend" });
    },
    FailedToGetUserInfo: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to get user information." });
    },
    FailedToGetMyAccount: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to get account information." });
    },
    FailedToCreateDevelopmentSite: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to create a Development Site" });
    },
    FailedToCreateMetaSiteFromTemplate: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to create a metasite from template" });
    },
    FailedToGetDevelopmentSites: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to request development sites." });
    },
    FailedToGetDevelopmentSitesLimit: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to request development sites limit." });
    },
    FailedToGetRequiredApps: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to get app requirement info." });
    },
    FailedToGetMarketListing: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to get market listing." });
    },
    FailedToAddRequiredApp: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to add required app." });
    },
    FailedToQuerySites: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to request sites list." });
    },
    FailedToGetSite: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to get information about your configured Development Site" });
    },
    FailedToDeploySite: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to deploy site." });
    },
    FailedToDeploySitePreview: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to deploy site preview." });
    },
    FailedToPublishDeployment: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to publish site." });
    },
    FailedToSaveDevelopmentSite: ({ path: path3 }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: "Failed to save the current development site.",
          hint: `Make sure the \`${path3}\` file has proper permissions and is accessible`
        }
      );
    },
    FailedToBuildApp: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, "Failed to build the application.", /* @__PURE__ */ import_react6.default.createElement(Newline, null), cause?.message),
          hint: "Please check the build output for more information"
        }
      );
    },
    FailedToGetAppInstallationDetails: ({ appId }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        SystemErrorMessage,
        {
          message: `Failed to fetch site installation details for app ${appId}`
        }
      );
    },
    FailedToInitializeGitRepo: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { cause, message: "Failed to initialize git repo." });
    },
    FailedToInstallDependencies: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { cause, message: "Failed to install dependencies." });
    },
    FailedToCommitChanges: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { cause, message: "Failed to commit changes." });
    },
    FailedToDeleteAuthData: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { cause, message: "Failed to delete auth data." });
    },
    FailedToDeleteLegacyAuthData: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to delete legacy auth data."
        }
      );
    },
    FailedToSaveAuthData: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { cause, message: "Failed to save auth data." });
    },
    FailedToSaveApiKeyAuthData: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to save api key auth data."
        }
      );
    },
    FailedToWriteJson: ({ filePath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: `Failed to write JSON at path: ${filePath}.`
        }
      );
    },
    FailedToWriteFile: ({ filePath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: `Failed to write file at path: ${filePath}.`
        }
      );
    },
    FailedToCreateDir: ({ dirPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: `Failed to create a directory at path: ${dirPath}.`
        }
      );
    },
    TemplatePathNotFound: ({ templatePath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        SystemErrorMessage,
        {
          message: `Template path not found: ${templatePath}`
        }
      );
    },
    LocalTemplatePathNotFound: ({ path: path3 }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: `Local template path not found: ${path3}` });
    },
    FailedToCloneRepo: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to clone repo.",
          hint: "Make sure the Git URL is correct and that your local Git is configured properly to access the remote repository"
        }
      );
    },
    InvalidGitUrl: ({ url }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: `Invalid Git URL: ${url}` });
    },
    AuthenticationRequired: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "You have to already be logged in to run this command." });
    },
    InvalidApiKey: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "You used invalid API key to log in." });
    },
    SiteConfiguredRequired: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "You must provide a `--site` in the command options." });
    },
    FailedAddingPackageToWorkspace: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: "Could not add package to the workspaces configuration. Please add it as instructed by your package manager.",
          hint: /* @__PURE__ */ import_react6.default.createElement(Text, null, "Full error can be found in ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "wix-error.log"))
        }
      );
    },
    FailedToGenerateSelfSignedCertificate: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to generate a self-signed certificate for development." });
    },
    NonInteractiveTerminal: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "This command is not supported in non-interactive terminals. Please run the command in an interactive terminal (TTY)." });
    },
    FailedToResolveViteOrigin: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Failed to resolve the base url for CSS asset urls" });
    },
    FailedToCreateAppRelease: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to create an app configuration." });
    },
    FailedToParseHttpErrorResponse: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Unexpected response from server." });
    },
    FailedToReleaseHeadlessProject: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed releasing a headless site and app" });
    },
    AppReleaseConfigViolations: ({ violations }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: "App configuration upload failed because of violations.",
          explanation: defaultOutdent`
            Violations:
            ${violations.map(formatFieldViolations).join("\n")}
          `,
          hint: /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, /* @__PURE__ */ import_react6.default.createElement(Text, null, "It may be temporary error, try again shortly. If it fails again, reach us on Discord:", " ", /* @__PURE__ */ import_react6.default.createElement(Link, { url: "https://discord.gg/devs-on-wix" })))
        }
      );
    },
    FailedToUpdateAppRelease: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to update an app configuration." });
    },
    FailedToCreateComponents: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to create components" });
    },
    FailedToFetchPackageDetails: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to fetch cli package details." });
    },
    FailedToGetResolveNpmDependenciesResult: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: `Failed to resolve "wix.lock" file.` });
    },
    CliAppVersionMismatch: ({ cliVersion, cliAppVersion }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: /* @__PURE__ */ import_react6.default.createElement(Text, null, "The versions of ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "@wix/cli"), " (", cliVersion, ") and", " ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "@wix/cli-app"), " (", cliAppVersion, ") dependencies do not match"),
          hint: /* @__PURE__ */ import_react6.default.createElement(Text, null, "Align their versions in your ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "package.json"), " and re-install dependencies")
        }
      );
    },
    InvalidDashboardPageRoute: ({ route, errorMessage }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Invalid dashboard page route: ${route}`,
          hint: errorMessage
        }
      );
    },
    InvalidEmbeddedScriptFolder: ({ path: path3, errorMessage }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Invalid embedded script folder: ${path3}`,
          hint: errorMessage
        }
      );
    },
    InvalidEmbeddedScriptTemplate: ({ templateFilename, errorMessage }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Invalid embedded script template in ${templateFilename}`,
          hint: errorMessage
        }
      );
    },
    InvalidCustomElementTagName: ({ tagName, errorMessage }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: /* @__PURE__ */ import_react6.default.createElement(Text, null, "We use name of folder as tagName for your custom element. Unfortunately, ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, tagName), " is invalid tagName. Reason: ", errorMessage),
          hint: /* @__PURE__ */ import_react6.default.createElement(Text, null, "You can find rules for tagName here:", " ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define#valid_custom_element_names"))
        }
      );
    },
    InvalidSiteFrontendPackageVersion: ({ packageName, versionRange }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: /* @__PURE__ */ import_react6.default.createElement(Text, null, "Package ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, packageName), " has an invalid version range ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, versionRange), " in your", " ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "package.json"), " file."),
          hint: /* @__PURE__ */ import_react6.default.createElement(Text, null, "The version range must follow", " ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, "semantic versioning"), " rules, and it must contain a major version.", /* @__PURE__ */ import_react6.default.createElement(Newline, null), "Read more about it here:", " ", /* @__PURE__ */ import_react6.default.createElement(Link, { url: "https://docs.npmjs.com/about-semantic-versioning" }))
        }
      );
    },
    FailedToCreateSiteOverride: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to create site override configuration" });
    },
    FailedToGetDeploymentPipelineDescription: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to get deployment pipeline details" });
    },
    FailedToGetDeploymentStatus: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to get deployment status" });
    },
    NetworkError: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Network error occurred.",
          hint: `Make sure you have an active internet connection and try again shortly.`
        }
      );
    },
    FailedToGenerateAppMarketQueryParam: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to get generate appMarket query parameter" });
    },
    FailedToParseLog: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to parse log from the server" });
    },
    AppForVersionNotFound: ({ version }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Could not find app configuration for the provided version: "${version}"`,
          hint: `Make sure that there is an app for this version.`
        }
      );
    },
    FailedToFetchAppForVersion: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: `Failed to fetch app configuration` });
    },
    FailedToGetAppSecret: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        SystemErrorMessage,
        {
          message: `Failed to fetch app keys and configuration`
        }
      );
    },
    FailedToConnectToLogsService: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: `Failed to connect to logs service.` });
    },
    FailedToGetLogsTopology: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Failed to fetch logs configuration for the given version.`,
          hint: `Try to use a different version.`
        }
      );
    },
    FailedInstallCloudflareNoAccess: ({ path: path3 }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Failed to install required binary in "${path3}"`,
          hint: `Check that you have required permissions.`
        }
      );
    },
    LogsConnectionTimeout: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: `Log session has been closed due to timeout.` });
    },
    InvalidServicePluginImplementation: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Your service plugin implementation is incorrect.`
        }
      );
    },
    UnknownServicePlugin: ({ name }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Unknown service plugin with the name of \`${name}\``
        }
      );
    },
    InvalidServicePluginFolder: ({ relativePath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Invalid folder for service plugin in \`${relativePath}\``
        }
      );
    },
    InvalidSiteOverrideID: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Failed to read devSiteOverrideId from local app configurations.`,
          hint: `Restart the dev environment and make sure that the .wix/app.config.json file exists.`
        }
      );
    },
    FailedToFindEsbuildOutputFile: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Failed to find file in ESBuild output`,
          hint: `Restart the dev environment and try again.`
        }
      );
    },
    FailedOptimizingWithEsbuild: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: `Failed to optimize dependency with ESBuild.`,
          explanation: `Restart the dev environment and try again.`
        }
      );
    },
    FailedReadingEsbuildOutputFile: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Failed to read ESBuild's output file`,
          hint: `Restart the dev environment and try again.`
        }
      );
    },
    CliAppTemplateNotFound: ({ id }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, "Template with ID ", /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, id), " not found."),
          hint: "Make sure you are using the correct template ID"
        }
      );
    },
    FailedToQueryCliAppTemplates: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        SystemErrorMessage,
        {
          message: "Failed to fetch available app templates"
        }
      );
    },
    FailedToCreateDevCenterAppFromTemplate: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to register your application in Wix" });
    },
    FailedToQueryApps: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to query apps" });
    },
    FailedToGetSiteInstalledApps: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to get site installed apps" });
    },
    FailedToGetSiteInstalledAppInstanceId: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to get site installed app instance id" });
    },
    FailedToGetClientSpecMap: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to get site client spec map" });
    },
    DeniedPermissionToGetAppSecret: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: "Insufficient permissions",
          hint: "Please log in with an account that has the required permissions to access this application"
        }
      );
    },
    FailedToCreateVeloApp: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to create an isolated environment." });
    },
    FailedToUpdateVeloAppFiles: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to update files in the isolated environment" });
    },
    FailedToGetFilesFromVelo: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to get initial project files" });
    },
    FailedToOpenBrowser: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to open browser.",
          hint: "Please make sure you have a browser installed, and it's appropriately configured"
        }
      );
    },
    DeprecatedVersion: ({
      currentVersion,
      latestVersion,
      deprecated,
      hasCliAppInstalled
    }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        OutdatedVersionMessage,
        {
          currentVersion,
          latestVersion,
          deprecated,
          hasCliAppInstalled
        }
      );
    },
    FailedToSyncPagesTypes: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to sync pages types" });
    },
    FailedToInitializeSiteFsManager: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to initialize site file system manager."
        }
      );
    },
    FailedToGetSiteFsManagerCode: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to parse site code in local file system."
        }
      );
    },
    FailedToGetSiteFsManagerDocument: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to parse site document in local file system."
        }
      );
    },
    FailedToApplySiteFsManagerFsUpdates: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to apply site local file system updates."
        }
      );
    },
    FailedToApplySiteFsManagerExternalUpdates: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to apply site external updates."
        }
      );
    },
    FailedToSyncVeloCLIServerDocumentUpdate: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to sync local file system document updates with the Editor."
        }
      );
    },
    ServeDeprecated: ({ packageManagerRunCmd }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ServeDeprecationMessage, { packageManagerRunCmd });
    },
    CannotFindConfigReferencedAsset: ({ asset, configPath, field }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Failed to load asset ${asset}`,
          hint: `Make sure the asset is correctly configured in \`${configPath}\` under the field \`${field}\``
        }
      );
    },
    CannotReleaseLockedApplication: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: "A new version of the app can not be released at this point.",
          explanation: "We\u2019re reviewing this app. You can\u2019t update new changes while it\u2019s in review."
        }
      );
    },
    FailedToCreateIntellisenseAdapter: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to create intellisense adapter."
        }
      );
    },
    FailedToInitIntellisenseAdapterTypes: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to initialize site types."
        }
      );
    },
    FailedToUpdateIntellisenseAdapterTypes: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { cause, message: "Failed to update site types." });
    },
    WebMethodOutsideOfProjectDirectory: ({ relativeId }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: `Web method "${relativeId}" is outside of the project directory.`
        }
      );
    },
    FailedToCreateDraftVersion: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to retrieve release options available for your application." });
    },
    FailedToReleaseDraftVersion: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to release a new version of your application." });
    },
    WaitForEditorInstallationStateFailure: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        SystemErrorMessage,
        {
          message: `Waiting for the Editor to finish installation timed out`
        }
      );
    },
    EditorPendingInstallationCheckTimedout: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        SystemErrorMessage,
        {
          message: `Editor installation details check timed out`
        }
      );
    },
    FailedToGetSdkSlotData: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        SystemErrorMessage,
        {
          message: `Unable to retrieve slot details to extend`
        }
      );
    },
    FailedToListComponentByComponentType: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        SystemErrorMessage,
        {
          message: `Unable to retrieve the list of available extensions for your application`
        }
      );
    },
    FailedToParseBackofficeExtensionContainer: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        SystemErrorMessage,
        {
          message: `Failed to parse backoffice extension containers data`
        }
      );
    },
    FailedToParseBackofficePages: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: `Failed to parse backoffice pages data` });
    },
    FailedToCleanDistFolder: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to clean the dist folder."
        }
      );
    },
    FailedToDeployDocument: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to deploy site document." });
    },
    FailedToEvalBackendExtension: ({ filename, errorMessage }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Failed to process file "${filename}", error details below:
${errorMessage}`
        }
      );
    },
    FailedToGetMonitoringLoaderScript: ({ dsn }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        SystemErrorMessage,
        {
          message: `Failed to get a monitoring loader script for DSN "${dsn}".`
        }
      );
    },
    InsufficientNonInterractiveReleaseParameters: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Release command in non-interactive mode requires following parameter: --version-type`
        }
      );
    },
    DeploymentPipelineFailed: ({ tasksDescriptions }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Errors in your site\u2019s code were found while trying to build your custom code. See output below:`
        }
      ), /* @__PURE__ */ import_react6.default.createElement(Box_default, { paddingLeft: 1, paddingTop: 1, flexDirection: "column" }, tasksDescriptions.map((task, index) => /* @__PURE__ */ import_react6.default.createElement(import_react6.Fragment, { key: index }, /* @__PURE__ */ import_react6.default.createElement(Alert, { type: task.status === "SUCCESS" ? "success" : "error" }, "[", index + 1, "/", tasksDescriptions.length, "] ", task.taskName, "..."), Object.entries(task.description).map(([path3, content]) => /* @__PURE__ */ import_react6.default.createElement(
        Box_default,
        {
          key: path3,
          paddingLeft: 2,
          paddingBottom: 1,
          flexDirection: "column"
        },
        /* @__PURE__ */ import_react6.default.createElement(Text, { bold: true }, path3),
        /* @__PURE__ */ import_react6.default.createElement(Text, null, content.trim())
      ))))));
    },
    FailedToParseLatestVersion: ({ version }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        SystemErrorMessage,
        {
          message: `The version "${version}" produced by the system does not conform to the expected semantic versioning format and could not be parsed.`
        }
      );
    },
    FailedToFetchWixLockFile: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: `Failed to fetch "wix.lock" file.` });
    },
    AppNameArgumentIsInvalid: ({ errorMessage }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: errorMessage,
          hint: "Failed to create a new application with the specified parameters. Please modify the parameters or switch to interactive mode."
        }
      );
    },
    CannotReleaseMinorInNoninteractive: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Minor version release is not allowed.`,
          hint: `Please release major version.`
        }
      );
    },
    SiteComponentConfigNotFound: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Site component config not found at ${configPath}`
        }
      );
    },
    SiteComponentPanelConfigNotFound: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Site component panel config not found at ${configPath}`
        }
      );
    },
    SiteComponentPanelDoNotExists: ({ panelName }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: `Site component panel with name ${panelName} do not exist`
        }
      );
    },
    FailedToImportCliApp: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { cause, message: "Failed to load `@wix/cli-app`." });
    },
    FailedToIdentifyProgramFlow: ({ reason }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: reason,
          hint: "Ensure that you are executing the command from inside a project directory."
        }
      );
    },
    FailedToPullEnvironment: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to pull environment variables." });
    },
    FailedToSetEnvironmentVariable: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to set/update environment variable." });
    },
    FailedToRemoveEnvironmentVariable: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to remove environment variable." });
    },
    FailedToUploadStaticFiles: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "Failed to upload static files." });
    },
    FailedCreatingAppProject: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "An error occoured while creating an app project." });
    },
    FailedCreatingAppDeployment: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "An error occoured while creating an app deployment." });
    },
    FailedFinalizingAppDeployment: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(SystemErrorMessage, { message: "An error occoured while completing app deployment." });
    },
    BuildOutputMissing: ({ reason }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          message: "Project build output is missing",
          explanation: reason,
          hint: "Build the project before proceeding."
        }
      );
    },
    FailedToCreateMonitoringVitePlugin: ({ configPath }) => {
      return () => /* @__PURE__ */ import_react6.default.createElement(
        ErrorMessage,
        {
          cause,
          message: "Failed to setup monitoring vite plugin.",
          hint: `Make sure you have the correct \`monitoring\` configuration in \`${configPath}\`.`
        }
      );
    },
    FailedToFindAstroConfig: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "No valid configuration file found. Please ensure that an astro.config.{js,cjs,mjs,ts} file exists in your project directory." });
    },
    ProjectIsAlreadyLinked: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "This project is already connected to Wix, so no changes were made." });
    },
    ProjectIsNotLinkable: () => {
      return () => /* @__PURE__ */ import_react6.default.createElement(ErrorMessage, { message: "Only Astro projects can be linked to Wix. The current project is missing an Astro configuration file." });
    }
  });
}
function formatZodIssue(issue) {
  const path3 = issue.path.join(".");
  if (!path3) {
    return `- ${issue.message}`;
  }
  return `- \`${path3}\`: ${issue.message}`;
}
function formatFieldViolations(violation) {
  return `- \`${violation.field}\`: ${violation.description}`;
}

// ../cli-error-reporting/src/components/ErrorViewer.ts
var ErrorViewer = ({
  error: originalError,
  systemErrorOverride
}) => {
  return (0, import_react7.useMemo)(() => {
    const error = normalizeError(originalError);
    return isCliSystemError(error) && systemErrorOverride ? systemErrorOverride : (0, import_react7.createElement)(getErrorComponent(error.cliCode, error.cause()));
  }, [originalError, systemErrorOverride]);
};

// ../cli-error-reporting/src/create-error-handler.tsx
init_esm_shims();
var import_react12 = __toESM(require_react(), 1);
import process2 from "node:process";

// ../cli-error-reporting/src/error-reporter.ts
init_esm_shims();
var import_variant2 = __toESM(require_lib(), 1);

// ../../node_modules/@sentry/node/build/esm/index.js
init_esm_shims();

// ../../node_modules/@sentry/node/build/esm/integrations/http.js
init_esm_shims();
var import_instrumentation_http = __toESM(require_src2(), 1);

// ../../node_modules/@sentry/opentelemetry/build/esm/index.js
init_esm_shims();
init_esm();
init_esm3();
init_esm5();
var SENTRY_TRACE_STATE_DSC = "sentry.dsc";
var SENTRY_TRACE_STATE_PARENT_SPAN_ID = "sentry.parent_span_id";
var SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = "sentry.sampled_not_recording";
var SENTRY_SCOPES_CONTEXT_KEY = createContextKey("sentry_scopes");
var SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = createContextKey("sentry_fork_isolation_scope");
var SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = createContextKey("sentry_fork_set_scope");
var SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = createContextKey("sentry_fork_set_isolation_scope");
function getScopesFromContext(context2) {
  return context2.getValue(SENTRY_SCOPES_CONTEXT_KEY);
}
function makeTraceState({
  parentSpanId,
  dsc,
  sampled
}) {
  const dscString = dsc ? dynamicSamplingContextToSentryBaggageHeader(dsc) : void 0;
  const traceStateBase = new TraceState().set(SENTRY_TRACE_STATE_PARENT_SPAN_ID, parentSpanId || "");
  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;
  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, "1") : traceStateWithDsc;
}
function generateSpanContextForPropagationContext(propagationContext) {
  const traceState = makeTraceState({
    parentSpanId: propagationContext.parentSpanId,
    dsc: propagationContext.dsc,
    sampled: propagationContext.sampled
  });
  const spanContext = {
    traceId: propagationContext.traceId,
    spanId: propagationContext.parentSpanId || "",
    isRemote: true,
    traceFlags: propagationContext.sampled ? TraceFlags.SAMPLED : TraceFlags.NONE,
    traceState
  };
  return spanContext;
}
function _optionalChain$7(ops) {
  let lastAccessLHS = void 0;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return void 0;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = void 0;
    }
  }
  return value;
}
function getSamplingDecision(spanContext) {
  const { traceFlags, traceState } = spanContext;
  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === "1" : false;
  if (traceFlags === TraceFlags.SAMPLED) {
    return true;
  }
  if (sampledNotRecording) {
    return false;
  }
  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : void 0;
  const dsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : void 0;
  if (_optionalChain$7([dsc, "optionalAccess", (_) => _.sampled]) === "true") {
    return true;
  }
  if (_optionalChain$7([dsc, "optionalAccess", (_2) => _2.sampled]) === "false") {
    return false;
  }
  return void 0;
}
function getPropagationContextFromSpan(span) {
  const spanContext = span.spanContext();
  const { traceId, spanId, traceState } = spanContext;
  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : void 0;
  const traceStateDsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : void 0;
  const parentSpanId = traceState ? traceState.get(SENTRY_TRACE_STATE_PARENT_SPAN_ID) || void 0 : void 0;
  const sampled = getSamplingDecision(spanContext);
  const dsc = traceStateDsc || getDynamicSamplingContextFromSpan(getRootSpan(span));
  return {
    traceId,
    spanId,
    sampled,
    parentSpanId,
    dsc
  };
}
function addOpenTelemetryInstrumentation(...instrumentations) {
  registerInstrumentations({
    instrumentations
  });
}

// ../../node_modules/@sentry/node/build/esm/sdk/scope.js
init_esm_shims();
init_esm();
function setIsolationScope(isolationScope) {
  const scopes = getScopesFromContext(context.active());
  if (scopes) {
    scopes.isolationScope = isolationScope;
  }
}

// ../../node_modules/@sentry/node/build/esm/utils/addOriginToSpan.js
init_esm_shims();
function addOriginToSpan(span, origin) {
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, origin);
}

// ../../node_modules/@sentry/node/build/esm/utils/getRequestUrl.js
init_esm_shims();
function getRequestUrl(requestOptions) {
  const protocol = requestOptions.protocol || "";
  const hostname2 = requestOptions.hostname || requestOptions.host || "";
  const port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 || /^(.*):(\d+)$/.test(hostname2) ? "" : `:${requestOptions.port}`;
  const path3 = requestOptions.path ? requestOptions.path : "/";
  return `${protocol}//${hostname2}${port}${path3}`;
}

// ../../node_modules/@sentry/node/build/esm/integrations/http.js
var INTEGRATION_NAME = "Http";
var _httpOptions = {};
var _httpInstrumentation;
var instrumentHttp = Object.assign(
  function() {
    if (_httpInstrumentation) {
      return;
    }
    const _InstrumentationClass = _httpOptions._instrumentation || import_instrumentation_http.HttpInstrumentation;
    _httpInstrumentation = new _InstrumentationClass({
      ..._optionalChain([_httpOptions, "access", (_) => _.instrumentation, "optionalAccess", (_2) => _2._experimentalConfig]),
      ignoreOutgoingRequestHook: (request) => {
        const url = getRequestUrl(request);
        if (!url) {
          return false;
        }
        if (isSentryRequestUrl(url, getClient())) {
          return true;
        }
        const _ignoreOutgoingRequests = _httpOptions.ignoreOutgoingRequests;
        if (_ignoreOutgoingRequests && _ignoreOutgoingRequests(url, request)) {
          return true;
        }
        return false;
      },
      ignoreIncomingRequestHook: (request) => {
        const urlPath = request.url;
        const method = _optionalChain([request, "access", (_3) => _3.method, "optionalAccess", (_4) => _4.toUpperCase, "call", (_5) => _5()]);
        if (method === "OPTIONS" || method === "HEAD") {
          return true;
        }
        const _ignoreIncomingRequests = _httpOptions.ignoreIncomingRequests;
        if (urlPath && _ignoreIncomingRequests && _ignoreIncomingRequests(urlPath, request)) {
          return true;
        }
        return false;
      },
      requireParentforOutgoingSpans: false,
      requireParentforIncomingSpans: false,
      requestHook: (span, req) => {
        addOriginToSpan(span, "auto.http.otel.http");
        if (_isClientRequest(req)) {
          _optionalChain([_httpOptions, "access", (_6) => _6.instrumentation, "optionalAccess", (_7) => _7.requestHook, "optionalCall", (_8) => _8(span, req)]);
          return;
        }
        const scopes = getCapturedScopesOnSpan(span);
        const isolationScope = (scopes.isolationScope || getIsolationScope()).clone();
        const scope = scopes.scope || getCurrentScope();
        isolationScope.setSDKProcessingMetadata({ request: req });
        const client = getClient();
        if (client && client.getOptions().autoSessionTracking) {
          isolationScope.setRequestSession({ status: "ok" });
        }
        setIsolationScope(isolationScope);
        setCapturedScopesOnSpan(span, scope, isolationScope);
        const httpMethod = (req.method || "GET").toUpperCase();
        const httpTarget = stripUrlQueryAndFragment(req.url || "/");
        const bestEffortTransactionName = `${httpMethod} ${httpTarget}`;
        isolationScope.setTransactionName(bestEffortTransactionName);
        _optionalChain([_httpOptions, "access", (_9) => _9.instrumentation, "optionalAccess", (_10) => _10.requestHook, "optionalCall", (_11) => _11(span, req)]);
      },
      responseHook: (span, res) => {
        const client = getClient();
        if (client && client.getOptions().autoSessionTracking) {
          setImmediate(() => {
            client["_captureRequestSession"]();
          });
        }
        _optionalChain([_httpOptions, "access", (_12) => _12.instrumentation, "optionalAccess", (_13) => _13.responseHook, "optionalCall", (_14) => _14(span, res)]);
      },
      applyCustomAttributesOnSpan: (span, request, response) => {
        const _breadcrumbs = typeof _httpOptions.breadcrumbs === "undefined" ? true : _httpOptions.breadcrumbs;
        if (_breadcrumbs) {
          _addRequestBreadcrumb(request, response);
        }
        _optionalChain([_httpOptions, "access", (_15) => _15.instrumentation, "optionalAccess", (_16) => _16.applyCustomAttributesOnSpan, "optionalCall", (_17) => _17(span, request, response)]);
      }
    });
    addOpenTelemetryInstrumentation(_httpInstrumentation);
  },
  {
    id: INTEGRATION_NAME
  }
);
var _httpIntegration = (options = {}) => {
  return {
    name: INTEGRATION_NAME,
    setupOnce() {
      _httpOptions = options;
      instrumentHttp();
    }
  };
};
var httpIntegration = defineIntegration(_httpIntegration);
function _addRequestBreadcrumb(request, response) {
  if (!_isClientRequest(request)) {
    return;
  }
  const data = getBreadcrumbData(request);
  addBreadcrumb(
    {
      category: "http",
      data: {
        status_code: response.statusCode,
        ...data
      },
      type: "http"
    },
    {
      event: "response",
      request,
      response
    }
  );
}
function getBreadcrumbData(request) {
  try {
    const host = request.getHeader("host") || request.host;
    const url = new URL(request.path, `${request.protocol}//${host}`);
    const parsedUrl = parseUrl(url.toString());
    const data = {
      url: getSanitizedUrlString(parsedUrl),
      "http.method": request.method || "GET"
    };
    if (parsedUrl.search) {
      data["http.query"] = parsedUrl.search;
    }
    if (parsedUrl.hash) {
      data["http.fragment"] = parsedUrl.hash;
    }
    return data;
  } catch (e) {
    return {};
  }
}
function _isClientRequest(req) {
  return "outputData" in req && "outputSize" in req && !("client" in req) && !("statusCode" in req);
}

// ../../node_modules/@sentry/node/build/esm/integrations/node-fetch.js
init_esm_shims();
init_esm();

// ../../node_modules/@sentry/node/build/esm/debug-build.js
init_esm_shims();
var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../../node_modules/@sentry/node/build/esm/nodeVersion.js
init_esm_shims();
var NODE_VERSION = parseSemver(process.versions.node);
var NODE_MAJOR = NODE_VERSION.major;

// ../../node_modules/@sentry/node/build/esm/integrations/node-fetch.js
var _nativeNodeFetchIntegration = (options = {}) => {
  const _breadcrumbs = typeof options.breadcrumbs === "undefined" ? true : options.breadcrumbs;
  const _ignoreOutgoingRequests = options.ignoreOutgoingRequests;
  async function getInstrumentation() {
    if (NODE_MAJOR < 18) {
      DEBUG_BUILD && logger.log("NodeFetch is not supported on Node < 18, skipping instrumentation...");
      return;
    }
    try {
      const pkg = await import("./build-6IMWAXMA.js");
      const { FetchInstrumentation } = pkg;
      class SentryNodeFetchInstrumentation extends FetchInstrumentation {
        // We extend this method so we have access to request _and_ response for the breadcrumb
        onHeaders({ request, response }) {
          if (_breadcrumbs) {
            _addRequestBreadcrumb2(request, response);
          }
          return super.onHeaders({ request, response });
        }
      }
      return new SentryNodeFetchInstrumentation({
        ignoreRequestHook: (request) => {
          const url = getAbsoluteUrl(request.origin, request.path);
          const tracingDisabled = !hasTracingEnabled();
          const shouldIgnore = _ignoreOutgoingRequests && url && _ignoreOutgoingRequests(url);
          if (shouldIgnore) {
            return true;
          }
          if (tracingDisabled) {
            const ctx = context.active();
            const addedHeaders = {};
            const activeSpan = trace.getSpan(ctx);
            const propagationContext = activeSpan ? getPropagationContextFromSpan(activeSpan) : getCurrentScope().getPropagationContext();
            const spanContext = generateSpanContextForPropagationContext(propagationContext);
            spanContext.traceState = _optionalChain([spanContext, "access", (_) => _.traceState, "optionalAccess", (_2) => _2.set, "call", (_3) => _3("sentry.url", url)]);
            const ctxWithUrlTraceState = trace.setSpanContext(ctx, spanContext);
            propagation.inject(ctxWithUrlTraceState, addedHeaders);
            const requestHeaders = request.headers;
            if (Array.isArray(requestHeaders)) {
              Object.entries(addedHeaders).forEach((headers) => requestHeaders.push(...headers));
            } else {
              request.headers += Object.entries(addedHeaders).map(([k, v]) => `${k}: ${v}\r
`).join("");
            }
            return true;
          }
          return false;
        },
        onRequest: ({ span }) => {
          _updateSpan(span);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      });
    } catch (error) {
      DEBUG_BUILD && logger.log("Error while loading NodeFetch instrumentation: \n", error);
    }
  }
  return {
    name: "NodeFetch",
    setupOnce() {
      getInstrumentation().then((instrumentation) => {
        if (instrumentation) {
          addOpenTelemetryInstrumentation(instrumentation);
        }
      });
    }
  };
};
var nativeNodeFetchIntegration = defineIntegration(_nativeNodeFetchIntegration);
function _updateSpan(span) {
  addOriginToSpan(span, "auto.http.otel.node_fetch");
}
function _addRequestBreadcrumb2(request, response) {
  const data = getBreadcrumbData2(request);
  addBreadcrumb(
    {
      category: "http",
      data: {
        status_code: response.statusCode,
        ...data
      },
      type: "http"
    },
    {
      event: "response",
      request,
      response
    }
  );
}
function getBreadcrumbData2(request) {
  try {
    const url = new URL(request.path, request.origin);
    const parsedUrl = parseUrl(url.toString());
    const data = {
      url: getSanitizedUrlString(parsedUrl),
      "http.method": request.method || "GET"
    };
    if (parsedUrl.search) {
      data["http.query"] = parsedUrl.search;
    }
    if (parsedUrl.hash) {
      data["http.fragment"] = parsedUrl.hash;
    }
    return data;
  } catch (e) {
    return {};
  }
}
function getAbsoluteUrl(origin, path3 = "/") {
  const url = `${origin}`;
  if (origin.endsWith("/") && path3.startsWith("/")) {
    return `${url}${path3.slice(1)}`;
  }
  if (!origin.endsWith("/") && !path3.startsWith("/")) {
    return `${url}/${path3.slice(1)}`;
  }
  return `${url}${path3}`;
}

// ../../node_modules/@sentry/node/build/esm/integrations/console.js
init_esm_shims();
import * as util from "node:util";
var INTEGRATION_NAME2 = "Console";
var _consoleIntegration = () => {
  return {
    name: INTEGRATION_NAME2,
    setup(client) {
      addConsoleInstrumentationHandler(({ args, level }) => {
        if (getClient() !== client) {
          return;
        }
        addBreadcrumb(
          {
            category: "console",
            level: severityLevelFromString(level),
            message: util.format.apply(void 0, args)
          },
          {
            input: [...args],
            level
          }
        );
      });
    }
  };
};
var consoleIntegration = defineIntegration(_consoleIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/context.js
init_esm_shims();
import { execFile } from "node:child_process";
import { readFile, readdir } from "node:fs";
import * as os from "node:os";
import { join as join2 } from "node:path";
import { promisify } from "node:util";
var readFileAsync = promisify(readFile);
var readDirAsync = promisify(readdir);
var INTEGRATION_NAME3 = "Context";
var _nodeContextIntegration = (options = {}) => {
  let cachedContext;
  const _options = {
    app: true,
    os: true,
    device: true,
    culture: true,
    cloudResource: true,
    ...options
  };
  async function addContext(event) {
    if (cachedContext === void 0) {
      cachedContext = _getContexts();
    }
    const updatedContext = _updateContext(await cachedContext);
    event.contexts = {
      ...event.contexts,
      app: { ...updatedContext.app, ..._optionalChain([event, "access", (_) => _.contexts, "optionalAccess", (_2) => _2.app]) },
      os: { ...updatedContext.os, ..._optionalChain([event, "access", (_3) => _3.contexts, "optionalAccess", (_4) => _4.os]) },
      device: { ...updatedContext.device, ..._optionalChain([event, "access", (_5) => _5.contexts, "optionalAccess", (_6) => _6.device]) },
      culture: { ...updatedContext.culture, ..._optionalChain([event, "access", (_7) => _7.contexts, "optionalAccess", (_8) => _8.culture]) },
      cloud_resource: { ...updatedContext.cloud_resource, ..._optionalChain([event, "access", (_9) => _9.contexts, "optionalAccess", (_10) => _10.cloud_resource]) }
    };
    return event;
  }
  async function _getContexts() {
    const contexts = {};
    if (_options.os) {
      contexts.os = await getOsContext();
    }
    if (_options.app) {
      contexts.app = getAppContext();
    }
    if (_options.device) {
      contexts.device = getDeviceContext(_options.device);
    }
    if (_options.culture) {
      const culture = getCultureContext();
      if (culture) {
        contexts.culture = culture;
      }
    }
    if (_options.cloudResource) {
      contexts.cloud_resource = getCloudResourceContext();
    }
    return contexts;
  }
  return {
    name: INTEGRATION_NAME3,
    processEvent(event) {
      return addContext(event);
    }
  };
};
var nodeContextIntegration = defineIntegration(_nodeContextIntegration);
function _updateContext(contexts) {
  if (_optionalChain([contexts, "optionalAccess", (_11) => _11.app, "optionalAccess", (_12) => _12.app_memory])) {
    contexts.app.app_memory = process.memoryUsage().rss;
  }
  if (_optionalChain([contexts, "optionalAccess", (_13) => _13.app, "optionalAccess", (_14) => _14.free_memory]) && typeof process.availableMemory === "function") {
    const freeMemory = _optionalChain([process, "access", (_15) => _15.availableMemory, "optionalCall", (_16) => _16()]);
    if (freeMemory != null) {
      contexts.app.free_memory = freeMemory;
    }
  }
  if (_optionalChain([contexts, "optionalAccess", (_17) => _17.device, "optionalAccess", (_18) => _18.free_memory])) {
    contexts.device.free_memory = os.freemem();
  }
  return contexts;
}
async function getOsContext() {
  const platformId = os.platform();
  switch (platformId) {
    case "darwin":
      return getDarwinInfo();
    case "linux":
      return getLinuxInfo();
    default:
      return {
        name: PLATFORM_NAMES[platformId] || platformId,
        version: os.release()
      };
  }
}
function getCultureContext() {
  try {
    if (typeof process.versions.icu !== "string") {
      return;
    }
    const january = /* @__PURE__ */ new Date(9e8);
    const spanish = new Intl.DateTimeFormat("es", { month: "long" });
    if (spanish.format(january) === "enero") {
      const options = Intl.DateTimeFormat().resolvedOptions();
      return {
        locale: options.locale,
        timezone: options.timeZone
      };
    }
  } catch (err) {
  }
  return;
}
function getAppContext() {
  const app_memory = process.memoryUsage().rss;
  const app_start_time = new Date(Date.now() - process.uptime() * 1e3).toISOString();
  const appContext = { app_start_time, app_memory };
  if (typeof process.availableMemory === "function") {
    const freeMemory = _optionalChain([process, "access", (_19) => _19.availableMemory, "optionalCall", (_20) => _20()]);
    if (freeMemory != null) {
      appContext.free_memory = freeMemory;
    }
  }
  return appContext;
}
function getDeviceContext(deviceOpt) {
  const device = {};
  let uptime2;
  try {
    uptime2 = os.uptime && os.uptime();
  } catch (e) {
  }
  if (typeof uptime2 === "number") {
    device.boot_time = new Date(Date.now() - uptime2 * 1e3).toISOString();
  }
  device.arch = os.arch();
  if (deviceOpt === true || deviceOpt.memory) {
    device.memory_size = os.totalmem();
    device.free_memory = os.freemem();
  }
  if (deviceOpt === true || deviceOpt.cpu) {
    const cpuInfo = os.cpus();
    const firstCpu = cpuInfo && cpuInfo[0];
    if (firstCpu) {
      device.processor_count = cpuInfo.length;
      device.cpu_description = firstCpu.model;
      device.processor_frequency = firstCpu.speed;
    }
  }
  return device;
}
var PLATFORM_NAMES = {
  aix: "IBM AIX",
  freebsd: "FreeBSD",
  openbsd: "OpenBSD",
  sunos: "SunOS",
  win32: "Windows"
};
var LINUX_DISTROS = [
  { name: "fedora-release", distros: ["Fedora"] },
  { name: "redhat-release", distros: ["Red Hat Linux", "Centos"] },
  { name: "redhat_version", distros: ["Red Hat Linux"] },
  { name: "SuSE-release", distros: ["SUSE Linux"] },
  { name: "lsb-release", distros: ["Ubuntu Linux", "Arch Linux"] },
  { name: "debian_version", distros: ["Debian"] },
  { name: "debian_release", distros: ["Debian"] },
  { name: "arch-release", distros: ["Arch Linux"] },
  { name: "gentoo-release", distros: ["Gentoo Linux"] },
  { name: "novell-release", distros: ["SUSE Linux"] },
  { name: "alpine-release", distros: ["Alpine Linux"] }
];
var LINUX_VERSIONS = {
  alpine: (content) => content,
  arch: (content) => matchFirst(/distrib_release=(.*)/, content),
  centos: (content) => matchFirst(/release ([^ ]+)/, content),
  debian: (content) => content,
  fedora: (content) => matchFirst(/release (..)/, content),
  mint: (content) => matchFirst(/distrib_release=(.*)/, content),
  red: (content) => matchFirst(/release ([^ ]+)/, content),
  suse: (content) => matchFirst(/VERSION = (.*)\n/, content),
  ubuntu: (content) => matchFirst(/distrib_release=(.*)/, content)
};
function matchFirst(regex, text) {
  const match2 = regex.exec(text);
  return match2 ? match2[1] : void 0;
}
async function getDarwinInfo() {
  const darwinInfo = {
    kernel_version: os.release(),
    name: "Mac OS X",
    version: `10.${Number(os.release().split(".")[0]) - 4}`
  };
  try {
    const output = await new Promise((resolve, reject) => {
      execFile("/usr/bin/sw_vers", (error, stdout) => {
        if (error) {
          reject(error);
          return;
        }
        resolve(stdout);
      });
    });
    darwinInfo.name = matchFirst(/^ProductName:\s+(.*)$/m, output);
    darwinInfo.version = matchFirst(/^ProductVersion:\s+(.*)$/m, output);
    darwinInfo.build = matchFirst(/^BuildVersion:\s+(.*)$/m, output);
  } catch (e) {
  }
  return darwinInfo;
}
function getLinuxDistroId(name) {
  return name.split(" ")[0].toLowerCase();
}
async function getLinuxInfo() {
  const linuxInfo = {
    kernel_version: os.release(),
    name: "Linux"
  };
  try {
    const etcFiles = await readDirAsync("/etc");
    const distroFile = LINUX_DISTROS.find((file) => etcFiles.includes(file.name));
    if (!distroFile) {
      return linuxInfo;
    }
    const distroPath = join2("/etc", distroFile.name);
    const contents = (await readFileAsync(distroPath, { encoding: "utf-8" })).toLowerCase();
    const { distros } = distroFile;
    linuxInfo.name = distros.find((d) => contents.indexOf(getLinuxDistroId(d)) >= 0) || distros[0];
    const id = getLinuxDistroId(linuxInfo.name);
    linuxInfo.version = _optionalChain([LINUX_VERSIONS, "access", (_21) => _21[id], "optionalCall", (_22) => _22(contents)]);
  } catch (e) {
  }
  return linuxInfo;
}
function getCloudResourceContext() {
  if (process.env.VERCEL) {
    return {
      "cloud.provider": "vercel",
      "cloud.region": process.env.VERCEL_REGION
    };
  } else if (process.env.AWS_REGION) {
    return {
      "cloud.provider": "aws",
      "cloud.region": process.env.AWS_REGION,
      "cloud.platform": process.env.AWS_EXECUTION_ENV
    };
  } else if (process.env.GCP_PROJECT) {
    return {
      "cloud.provider": "gcp"
    };
  } else if (process.env.ALIYUN_REGION_ID) {
    return {
      "cloud.provider": "alibaba_cloud",
      "cloud.region": process.env.ALIYUN_REGION_ID
    };
  } else if (process.env.WEBSITE_SITE_NAME && process.env.REGION_NAME) {
    return {
      "cloud.provider": "azure",
      "cloud.region": process.env.REGION_NAME
    };
  } else if (process.env.IBM_CLOUD_REGION) {
    return {
      "cloud.provider": "ibm_cloud",
      "cloud.region": process.env.IBM_CLOUD_REGION
    };
  } else if (process.env.TENCENTCLOUD_REGION) {
    return {
      "cloud.provider": "tencent_cloud",
      "cloud.region": process.env.TENCENTCLOUD_REGION,
      "cloud.account.id": process.env.TENCENTCLOUD_APPID,
      "cloud.availability_zone": process.env.TENCENTCLOUD_ZONE
    };
  } else if (process.env.NETLIFY) {
    return {
      "cloud.provider": "netlify"
    };
  } else if (process.env.FLY_REGION) {
    return {
      "cloud.provider": "fly.io",
      "cloud.region": process.env.FLY_REGION
    };
  } else if (process.env.DYNO) {
    return {
      "cloud.provider": "heroku"
    };
  } else {
    return void 0;
  }
}

// ../../node_modules/@sentry/node/build/esm/integrations/contextlines.js
init_esm_shims();
import { createReadStream } from "node:fs";
import { createInterface } from "node:readline";
var LRU_FILE_CONTENTS_CACHE = new LRUMap(10);
var LRU_FILE_CONTENTS_FS_READ_FAILED = new LRUMap(20);
var DEFAULT_LINES_OF_CONTEXT = 7;
var INTEGRATION_NAME4 = "ContextLines";
var MAX_CONTEXTLINES_COLNO = 1e3;
var MAX_CONTEXTLINES_LINENO = 1e4;
function emplace(map, key, contents) {
  const value = map.get(key);
  if (value === void 0) {
    map.set(key, contents);
    return contents;
  }
  return value;
}
function shouldSkipContextLinesForFile(path3) {
  if (path3.startsWith("node:")) return true;
  if (path3.endsWith(".min.js")) return true;
  if (path3.endsWith(".min.cjs")) return true;
  if (path3.endsWith(".min.mjs")) return true;
  if (path3.startsWith("data:")) return true;
  return false;
}
function shouldSkipContextLinesForFrame(frame) {
  if (frame.lineno !== void 0 && frame.lineno > MAX_CONTEXTLINES_LINENO) return true;
  if (frame.colno !== void 0 && frame.colno > MAX_CONTEXTLINES_COLNO) return true;
  return false;
}
function rangeExistsInContentCache(file, range) {
  const contents = LRU_FILE_CONTENTS_CACHE.get(file);
  if (contents === void 0) return false;
  for (let i = range[0]; i <= range[1]; i++) {
    if (contents[i] === void 0) {
      return false;
    }
  }
  return true;
}
function makeLineReaderRanges(lines, linecontext) {
  if (!lines.length) {
    return [];
  }
  let i = 0;
  const line = lines[0];
  if (typeof line !== "number") {
    return [];
  }
  let current = makeContextRange(line, linecontext);
  const out = [];
  while (true) {
    if (i === lines.length - 1) {
      out.push(current);
      break;
    }
    const next = lines[i + 1];
    if (typeof next !== "number") {
      break;
    }
    if (next <= current[1]) {
      current[1] = next + linecontext;
    } else {
      out.push(current);
      current = makeContextRange(next, linecontext);
    }
    i++;
  }
  return out;
}
function getContextLinesFromFile(path3, ranges, output) {
  return new Promise((resolve, _reject) => {
    const stream = createReadStream(path3);
    const lineReaded = createInterface({
      input: stream
    });
    let lineNumber = 0;
    let currentRangeIndex = 0;
    const range = ranges[currentRangeIndex];
    if (range === void 0) {
      resolve();
      return;
    }
    let rangeStart = range[0];
    let rangeEnd = range[1];
    function onStreamError(e) {
      LRU_FILE_CONTENTS_FS_READ_FAILED.set(path3, 1);
      DEBUG_BUILD && logger.error(`Failed to read file: ${path3}. Error: ${e}`);
      lineReaded.close();
      lineReaded.removeAllListeners();
      resolve();
    }
    stream.on("error", onStreamError);
    lineReaded.on("error", onStreamError);
    lineReaded.on("close", resolve);
    lineReaded.on("line", (line) => {
      lineNumber++;
      if (lineNumber < rangeStart) return;
      output[lineNumber] = snipLine(line, 0);
      if (lineNumber >= rangeEnd) {
        if (currentRangeIndex === ranges.length - 1) {
          lineReaded.close();
          lineReaded.removeAllListeners();
          return;
        }
        currentRangeIndex++;
        const range2 = ranges[currentRangeIndex];
        if (range2 === void 0) {
          lineReaded.close();
          lineReaded.removeAllListeners();
          return;
        }
        rangeStart = range2[0];
        rangeEnd = range2[1];
      }
    });
  });
}
async function addSourceContext(event, contextLines) {
  const filesToLines = {};
  if (contextLines > 0 && _optionalChain([event, "access", (_) => _.exception, "optionalAccess", (_2) => _2.values])) {
    for (const exception of event.exception.values) {
      if (!_optionalChain([exception, "access", (_3) => _3.stacktrace, "optionalAccess", (_4) => _4.frames, "optionalAccess", (_5) => _5.length])) {
        continue;
      }
      for (let i = exception.stacktrace.frames.length - 1; i >= 0; i--) {
        const frame = exception.stacktrace.frames[i];
        const filename = _optionalChain([frame, "optionalAccess", (_6) => _6.filename]);
        if (!frame || typeof filename !== "string" || typeof frame.lineno !== "number" || shouldSkipContextLinesForFile(filename) || shouldSkipContextLinesForFrame(frame)) {
          continue;
        }
        const filesToLinesOutput = filesToLines[filename];
        if (!filesToLinesOutput) filesToLines[filename] = [];
        filesToLines[filename].push(frame.lineno);
      }
    }
  }
  const files = Object.keys(filesToLines);
  if (files.length == 0) {
    return event;
  }
  const readlinePromises = [];
  for (const file of files) {
    if (LRU_FILE_CONTENTS_FS_READ_FAILED.get(file)) {
      continue;
    }
    const filesToLineRanges = filesToLines[file];
    if (!filesToLineRanges) {
      continue;
    }
    filesToLineRanges.sort((a, b) => a - b);
    const ranges = makeLineReaderRanges(filesToLineRanges, contextLines);
    if (ranges.every((r) => rangeExistsInContentCache(file, r))) {
      continue;
    }
    const cache = emplace(LRU_FILE_CONTENTS_CACHE, file, {});
    readlinePromises.push(getContextLinesFromFile(file, ranges, cache));
  }
  await Promise.all(readlinePromises).catch(() => {
    DEBUG_BUILD && logger.log("Failed to read one or more source files and resolve context lines");
  });
  if (contextLines > 0 && _optionalChain([event, "access", (_7) => _7.exception, "optionalAccess", (_8) => _8.values])) {
    for (const exception of event.exception.values) {
      if (exception.stacktrace && exception.stacktrace.frames && exception.stacktrace.frames.length > 0) {
        addSourceContextToFrames(exception.stacktrace.frames, contextLines, LRU_FILE_CONTENTS_CACHE);
      }
    }
  }
  return event;
}
function addSourceContextToFrames(frames, contextLines, cache) {
  for (const frame of frames) {
    if (frame.filename && frame.context_line === void 0 && typeof frame.lineno === "number") {
      const contents = cache.get(frame.filename);
      if (contents === void 0) {
        continue;
      }
      addContextToFrame(frame.lineno, frame, contextLines, contents);
    }
  }
}
function clearLineContext(frame) {
  delete frame.pre_context;
  delete frame.context_line;
  delete frame.post_context;
}
function addContextToFrame(lineno, frame, contextLines, contents) {
  if (frame.lineno === void 0 || contents === void 0) {
    DEBUG_BUILD && logger.error("Cannot resolve context for frame with no lineno or file contents");
    return;
  }
  frame.pre_context = [];
  for (let i = makeRangeStart(lineno, contextLines); i < lineno; i++) {
    const line = contents[i];
    if (line === void 0) {
      clearLineContext(frame);
      DEBUG_BUILD && logger.error(`Could not find line ${i} in file ${frame.filename}`);
      return;
    }
    frame.pre_context.push(line);
  }
  if (contents[lineno] === void 0) {
    clearLineContext(frame);
    DEBUG_BUILD && logger.error(`Could not find line ${lineno} in file ${frame.filename}`);
    return;
  }
  frame.context_line = contents[lineno];
  const end = makeRangeEnd(lineno, contextLines);
  frame.post_context = [];
  for (let i = lineno + 1; i <= end; i++) {
    const line = contents[i];
    if (line === void 0) {
      break;
    }
    frame.post_context.push(line);
  }
}
function makeRangeStart(line, linecontext) {
  return Math.max(1, line - linecontext);
}
function makeRangeEnd(line, linecontext) {
  return line + linecontext;
}
function makeContextRange(line, linecontext) {
  return [makeRangeStart(line, linecontext), makeRangeEnd(line, linecontext)];
}
var _contextLinesIntegration = (options = {}) => {
  const contextLines = options.frameContextLines !== void 0 ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
  return {
    name: INTEGRATION_NAME4,
    processEvent(event) {
      return addSourceContext(event, contextLines);
    }
  };
};
var contextLinesIntegration = defineIntegration(_contextLinesIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/local-variables/index.js
init_esm_shims();

// ../../node_modules/@sentry/node/build/esm/integrations/local-variables/local-variables-async.js
init_esm_shims();
import { Worker } from "node:worker_threads";

// ../../node_modules/@sentry/node/build/esm/integrations/local-variables/common.js
init_esm_shims();
function createRateLimiter(maxPerSecond, enable, disable) {
  let count = 0;
  let retrySeconds = 5;
  let disabledTimeout = 0;
  setInterval(() => {
    if (disabledTimeout === 0) {
      if (count > maxPerSecond) {
        retrySeconds *= 2;
        disable(retrySeconds);
        if (retrySeconds > 86400) {
          retrySeconds = 86400;
        }
        disabledTimeout = retrySeconds;
      }
    } else {
      disabledTimeout -= 1;
      if (disabledTimeout === 0) {
        enable();
      }
    }
    count = 0;
  }, 1e3).unref();
  return () => {
    count += 1;
  };
}
function isAnonymous(name) {
  return name !== void 0 && (name.length === 0 || name === "?" || name === "<anonymous>");
}
function functionNamesMatch(a, b) {
  return a === b || isAnonymous(a) && isAnonymous(b);
}
function hashFrames(frames) {
  if (frames === void 0) {
    return;
  }
  return frames.slice(-10).reduce((acc, frame) => `${acc},${frame.function},${frame.lineno},${frame.colno}`, "");
}
function hashFromStack(stackParser, stack) {
  if (stack === void 0) {
    return void 0;
  }
  return hashFrames(stackParser(stack, 1));
}

// ../../node_modules/@sentry/node/build/esm/integrations/local-variables/local-variables-async.js
var base64WorkerScript = "LyohIEBzZW50cnkvbm9kZSA4LjIwLjAgKGNkZDBhOTIpIHwgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCAqLwppbXBvcnR7U2Vzc2lvbiBhcyBlfWZyb20ibm9kZTppbnNwZWN0b3IvcHJvbWlzZXMiO2ltcG9ydHt3b3JrZXJEYXRhIGFzIG4scGFyZW50UG9ydCBhcyB0fWZyb20ibm9kZTp3b3JrZXJfdGhyZWFkcyI7aW1wb3J0e3Bvc2l4IGFzIG8sc2VwIGFzIHJ9ZnJvbSJub2RlOnBhdGgiO2NvbnN0IGk9NTAscz0iPyIsYz0vXChlcnJvcjogKC4qKVwpLyxhPS9jYXB0dXJlTWVzc2FnZXxjYXB0dXJlRXhjZXB0aW9uLztmdW5jdGlvbiB1KGUpe3JldHVybiBlW2UubGVuZ3RoLTFdfHx7fX1jb25zdCBmPS9eKFxTKzpcXHxcLz8pKFtcc1xTXSo/KSgoPzpcLnsxLDJ9fFteL1xcXSs/fCkoXC5bXi4vXFxdKnwpKSg/OlsvXFxdKikkLztmdW5jdGlvbiBsKGUpe2NvbnN0IG49ZnVuY3Rpb24oZSl7Y29uc3Qgbj1lLmxlbmd0aD4xMDI0P2A8dHJ1bmNhdGVkPiR7ZS5zbGljZSgtMTAyNCl9YDplLHQ9Zi5leGVjKG4pO3JldHVybiB0P3Quc2xpY2UoMSk6W119KGUpLHQ9blswXXx8IiI7bGV0IG89blsxXTtyZXR1cm4gdHx8bz8obyYmKG89by5zbGljZSgwLG8ubGVuZ3RoLTEpKSx0K28pOiIuIn1mdW5jdGlvbiBkKGUsbj0hMSl7cmV0dXJuIShufHxlJiYhZS5zdGFydHNXaXRoKCIvIikmJiFlLm1hdGNoKC9eW0EtWl06LykmJiFlLnN0YXJ0c1dpdGgoIi4iKSYmIWUubWF0Y2goL15bYS16QS1aXShbYS16QS1aMC05LlwtK10pKjpcL1wvLykpJiZ2b2lkIDAhPT1lJiYhZS5pbmNsdWRlcygibm9kZV9tb2R1bGVzLyIpfWZ1bmN0aW9uIHAoZSl7Y29uc3Qgbj0vXlxzKlstXXs0LH0kLyx0PS9hdCAoPzphc3luYyApPyg/OiguKz8pXHMrXCgpPyg/OiguKyk6KFxkKyk6KFxkKyk/fChbXildKykpXCk/LztyZXR1cm4gbz0+e2NvbnN0IHI9by5tYXRjaCh0KTtpZihyKXtsZXQgbix0LG8saSxjO2lmKHJbMV0pe289clsxXTtsZXQgZT1vLmxhc3RJbmRleE9mKCIuIik7aWYoIi4iPT09b1tlLTFdJiZlLS0sZT4wKXtuPW8uc2xpY2UoMCxlKSx0PW8uc2xpY2UoZSsxKTtjb25zdCByPW4uaW5kZXhPZigiLk1vZHVsZSIpO3I+MCYmKG89by5zbGljZShyKzEpLG49bi5zbGljZSgwLHIpKX1pPXZvaWQgMH10JiYoaT1uLGM9dCksIjxhbm9ueW1vdXM+Ij09PXQmJihjPXZvaWQgMCxvPXZvaWQgMCksdm9pZCAwPT09byYmKGM9Y3x8cyxvPWk/YCR7aX0uJHtjfWA6Yyk7bGV0IGE9clsyXSYmclsyXS5zdGFydHNXaXRoKCJmaWxlOi8vIik/clsyXS5zbGljZSg3KTpyWzJdO2NvbnN0IHU9Im5hdGl2ZSI9PT1yWzVdO3JldHVybiBhJiZhLm1hdGNoKC9cL1tBLVpdOi8pJiYoYT1hLnNsaWNlKDEpKSxhfHwhcls1XXx8dXx8KGE9cls1XSkse2ZpbGVuYW1lOmEsbW9kdWxlOmU/ZShhKTp2b2lkIDAsZnVuY3Rpb246byxsaW5lbm86ZyhyWzNdKSxjb2xubzpnKHJbNF0pLGluX2FwcDpkKGF8fCIiLHUpfX1pZihvLm1hdGNoKG4pKXJldHVybntmaWxlbmFtZTpvfX19ZnVuY3Rpb24gZyhlKXtyZXR1cm4gcGFyc2VJbnQoZXx8IiIsMTApfHx2b2lkIDB9ZnVuY3Rpb24gbShlKXtyZXR1cm4gZS5yZXBsYWNlKC9eW0EtWl06LywiIikucmVwbGFjZSgvXFwvZywiLyIpfWNvbnN0IGI9biwkPWZ1bmN0aW9uKC4uLmUpe2NvbnN0IG49ZS5zb3J0KCgoZSxuKT0+ZVswXS1uWzBdKSkubWFwKChlPT5lWzFdKSk7cmV0dXJuKGUsdD0wLG89MCk9Pntjb25zdCByPVtdLGY9ZS5zcGxpdCgiXG4iKTtmb3IobGV0IGU9dDtlPGYubGVuZ3RoO2UrKyl7Y29uc3QgdD1mW2VdO2lmKHQubGVuZ3RoPjEwMjQpY29udGludWU7Y29uc3Qgcz1jLnRlc3QodCk/dC5yZXBsYWNlKGMsIiQxIik6dDtpZighcy5tYXRjaCgvXFMqRXJyb3I6IC8pKXtmb3IoY29uc3QgZSBvZiBuKXtjb25zdCBuPWUocyk7aWYobil7ci5wdXNoKG4pO2JyZWFrfX1pZihyLmxlbmd0aD49aStvKWJyZWFrfX1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIWUubGVuZ3RoKXJldHVybltdO2NvbnN0IG49QXJyYXkuZnJvbShlKTsvc2VudHJ5V3JhcHBlZC8udGVzdCh1KG4pLmZ1bmN0aW9ufHwiIikmJm4ucG9wKCk7bi5yZXZlcnNlKCksYS50ZXN0KHUobikuZnVuY3Rpb258fCIiKSYmKG4ucG9wKCksYS50ZXN0KHUobikuZnVuY3Rpb258fCIiKSYmbi5wb3AoKSk7cmV0dXJuIG4uc2xpY2UoMCxpKS5tYXAoKGU9Pih7Li4uZSxmaWxlbmFtZTplLmZpbGVuYW1lfHx1KG4pLmZpbGVuYW1lLGZ1bmN0aW9uOmUuZnVuY3Rpb258fHN9KSkpfShyLnNsaWNlKG8pKX19KFs5MCxwKGZ1bmN0aW9uKGU9KHByb2Nlc3MuYXJndlsxXT9sKHByb2Nlc3MuYXJndlsxXSk6cHJvY2Vzcy5jd2QoKSksbj0iXFwiPT09cil7Y29uc3QgdD1uP20oZSk6ZTtyZXR1cm4gZT0+e2lmKCFlKXJldHVybjtjb25zdCByPW4/bShlKTplO2xldHtkaXI6aSxiYXNlOnMsZXh0OmN9PW8ucGFyc2Uocik7Ii5qcyIhPT1jJiYiLm1qcyIhPT1jJiYiLmNqcyIhPT1jfHwocz1zLnNsaWNlKDAsLTEqYy5sZW5ndGgpKSxpfHwoaT0iLiIpO2NvbnN0IGE9aS5sYXN0SW5kZXhPZigiL25vZGVfbW9kdWxlcyIpO2lmKGE+LTEpcmV0dXJuYCR7aS5zbGljZShhKzE0KS5yZXBsYWNlKC9cLy9nLCIuIil9OiR7c31gO2lmKGkuc3RhcnRzV2l0aCh0KSl7bGV0IGU9aS5zbGljZSh0Lmxlbmd0aCsxKS5yZXBsYWNlKC9cLy9nLCIuIik7cmV0dXJuIGUmJihlKz0iOiIpLGUrPXMsZX1yZXR1cm4gc319KGIuYmFzZVBhdGgpKV0pO2Z1bmN0aW9uIHYoLi4uZSl7Yi5kZWJ1ZyYmY29uc29sZS5sb2coIltMb2NhbFZhcmlhYmxlcyBXb3JrZXJdIiwuLi5lKX1hc3luYyBmdW5jdGlvbiB3KGUsbix0LG8pe2NvbnN0IHI9YXdhaXQgZS5wb3N0KCJSdW50aW1lLmdldFByb3BlcnRpZXMiLHtvYmplY3RJZDpuLG93blByb3BlcnRpZXM6ITB9KTtvW3RdPXIucmVzdWx0LmZpbHRlcigoZT0+Imxlbmd0aCIhPT1lLm5hbWUmJiFpc05hTihwYXJzZUludChlLm5hbWUsMTApKSkpLnNvcnQoKChlLG4pPT5wYXJzZUludChlLm5hbWUsMTApLXBhcnNlSW50KG4ubmFtZSwxMCkpKS5tYXAoKGU9PmUudmFsdWU/LnZhbHVlKSl9YXN5bmMgZnVuY3Rpb24geShlLG4sdCxvKXtjb25zdCByPWF3YWl0IGUucG9zdCgiUnVudGltZS5nZXRQcm9wZXJ0aWVzIix7b2JqZWN0SWQ6bixvd25Qcm9wZXJ0aWVzOiEwfSk7b1t0XT1yLnJlc3VsdC5tYXAoKGU9PltlLm5hbWUsZS52YWx1ZT8udmFsdWVdKSkucmVkdWNlKCgoZSxbbix0XSk9PihlW25dPXQsZSkpLHt9KX1mdW5jdGlvbiBoKGUsbil7ZS52YWx1ZSYmKCJ2YWx1ZSJpbiBlLnZhbHVlP3ZvaWQgMD09PWUudmFsdWUudmFsdWV8fG51bGw9PT1lLnZhbHVlLnZhbHVlP25bZS5uYW1lXT1gPCR7ZS52YWx1ZS52YWx1ZX0+YDpuW2UubmFtZV09ZS52YWx1ZS52YWx1ZToiZGVzY3JpcHRpb24iaW4gZS52YWx1ZSYmImZ1bmN0aW9uIiE9PWUudmFsdWUudHlwZT9uW2UubmFtZV09YDwke2UudmFsdWUuZGVzY3JpcHRpb259PmA6InVuZGVmaW5lZCI9PT1lLnZhbHVlLnR5cGUmJihuW2UubmFtZV09Ijx1bmRlZmluZWQ+IikpfWFzeW5jIGZ1bmN0aW9uIFAoZSxuKXtjb25zdCB0PWF3YWl0IGUucG9zdCgiUnVudGltZS5nZXRQcm9wZXJ0aWVzIix7b2JqZWN0SWQ6bixvd25Qcm9wZXJ0aWVzOiEwfSksbz17fTtmb3IoY29uc3QgbiBvZiB0LnJlc3VsdClpZihuPy52YWx1ZT8ub2JqZWN0SWQmJiJBcnJheSI9PT1uPy52YWx1ZS5jbGFzc05hbWUpe2NvbnN0IHQ9bi52YWx1ZS5vYmplY3RJZDthd2FpdCB3KGUsdCxuLm5hbWUsbyl9ZWxzZSBpZihuPy52YWx1ZT8ub2JqZWN0SWQmJiJPYmplY3QiPT09bj8udmFsdWU/LmNsYXNzTmFtZSl7Y29uc3QgdD1uLnZhbHVlLm9iamVjdElkO2F3YWl0IHkoZSx0LG4ubmFtZSxvKX1lbHNlIG4/LnZhbHVlJiZoKG4sbyk7cmV0dXJuIG99bGV0IHg7KGFzeW5jIGZ1bmN0aW9uKCl7Y29uc3Qgbj1uZXcgZTtuLmNvbm5lY3RUb01haW5UaHJlYWQoKSx2KCJDb25uZWN0ZWQgdG8gbWFpbiB0aHJlYWQiKTtsZXQgbz0hMTtuLm9uKCJEZWJ1Z2dlci5yZXN1bWVkIiwoKCk9PntvPSExfSkpLG4ub24oIkRlYnVnZ2VyLnBhdXNlZCIsKGU9PntvPSEwLGFzeW5jIGZ1bmN0aW9uKGUsbix7cmVhc29uOm8sZGF0YTpyLGNhbGxGcmFtZXM6aX0pe2lmKCJleGNlcHRpb24iIT09byYmInByb21pc2VSZWplY3Rpb24iIT09bylyZXR1cm47eD8uKCk7Y29uc3Qgcz1mdW5jdGlvbihlLG4pe2lmKHZvaWQgMCE9PW4pcmV0dXJuIGZ1bmN0aW9uKGUpe2lmKHZvaWQgMCE9PWUpcmV0dXJuIGUuc2xpY2UoLTEwKS5yZWR1Y2UoKChlLG4pPT5gJHtlfSwke24uZnVuY3Rpb259LCR7bi5saW5lbm99LCR7bi5jb2xub31gKSwiIil9KGUobiwxKSl9KG4scj8uZGVzY3JpcHRpb24pO2lmKG51bGw9PXMpcmV0dXJuO2NvbnN0IGM9W107Zm9yKGxldCBuPTA7bjxpLmxlbmd0aDtuKyspe2NvbnN0e3Njb3BlQ2hhaW46dCxmdW5jdGlvbk5hbWU6byx0aGlzOnJ9PWlbbl0scz10LmZpbmQoKGU9PiJsb2NhbCI9PT1lLnR5cGUpKSxhPSJnbG9iYWwiIT09ci5jbGFzc05hbWUmJnIuY2xhc3NOYW1lP2Ake3IuY2xhc3NOYW1lfS4ke299YDpvO2lmKHZvaWQgMD09PXM/Lm9iamVjdC5vYmplY3RJZCljW25dPXtmdW5jdGlvbjphfTtlbHNle2NvbnN0IHQ9YXdhaXQgUChlLHMub2JqZWN0Lm9iamVjdElkKTtjW25dPXtmdW5jdGlvbjphLHZhcnM6dH19fXQ/LnBvc3RNZXNzYWdlKHtleGNlcHRpb25IYXNoOnMsZnJhbWVzOmN9KX0obiwkLGUucGFyYW1zKS50aGVuKCgoKT0+bz9uLnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpOlByb21pc2UucmVzb2x2ZSgpKSwoZT0+e30pKX0pKSxhd2FpdCBuLnBvc3QoIkRlYnVnZ2VyLmVuYWJsZSIpO2NvbnN0IHI9ITEhPT1iLmNhcHR1cmVBbGxFeGNlcHRpb25zO2lmKGF3YWl0IG4ucG9zdCgiRGVidWdnZXIuc2V0UGF1c2VPbkV4Y2VwdGlvbnMiLHtzdGF0ZTpyPyJhbGwiOiJ1bmNhdWdodCJ9KSxyKXtjb25zdCBlPWIubWF4RXhjZXB0aW9uc1BlclNlY29uZHx8NTA7eD1mdW5jdGlvbihlLG4sdCl7bGV0IG89MCxyPTUsaT0wO3JldHVybiBzZXRJbnRlcnZhbCgoKCk9PnswPT09aT9vPmUmJihyKj0yLHQocikscj44NjQwMCYmKHI9ODY0MDApLGk9cik6KGktPTEsMD09PWkmJm4oKSksbz0wfSksMWUzKS51bnJlZigpLCgpPT57bys9MX19KGUsKGFzeW5jKCk9Pnt2KCJSYXRlLWxpbWl0IGxpZnRlZC4iKSxhd2FpdCBuLnBvc3QoIkRlYnVnZ2VyLnNldFBhdXNlT25FeGNlcHRpb25zIix7c3RhdGU6ImFsbCJ9KX0pLChhc3luYyBlPT57dihgUmF0ZS1saW1pdCBleGNlZWRlZC4gRGlzYWJsaW5nIGNhcHR1cmluZyBvZiBjYXVnaHQgZXhjZXB0aW9ucyBmb3IgJHtlfSBzZWNvbmRzLmApLGF3YWl0IG4ucG9zdCgiRGVidWdnZXIuc2V0UGF1c2VPbkV4Y2VwdGlvbnMiLHtzdGF0ZToidW5jYXVnaHQifSl9KSl9fSkoKS5jYXRjaCgoZT0+e3YoIkZhaWxlZCB0byBzdGFydCBkZWJ1Z2dlciIsZSl9KSksc2V0SW50ZXJ2YWwoKCgpPT57fSksMWU0KTs=";
function log(...args) {
  logger.log("[LocalVariables]", ...args);
}
var localVariablesAsyncIntegration = defineIntegration((integrationOptions = {}) => {
  const cachedFrames = new LRUMap(20);
  function addLocalVariablesToException(exception) {
    const hash = hashFrames(_optionalChain([exception, "optionalAccess", (_) => _.stacktrace, "optionalAccess", (_2) => _2.frames]));
    if (hash === void 0) {
      return;
    }
    const cachedFrame = cachedFrames.remove(hash);
    if (cachedFrame === void 0) {
      return;
    }
    const frames = (_optionalChain([exception, "access", (_3) => _3.stacktrace, "optionalAccess", (_4) => _4.frames]) || []).filter((frame) => frame.function !== "new Promise");
    for (let i = 0; i < frames.length; i++) {
      const frameIndex = frames.length - i - 1;
      const cachedFrameVariable = cachedFrame[i];
      const frameVariable = frames[frameIndex];
      if (!frameVariable || !cachedFrameVariable) {
        break;
      }
      if (
        // We need to have vars to add
        cachedFrameVariable.vars === void 0 || // We're not interested in frames that are not in_app because the vars are not relevant
        frameVariable.in_app === false || // The function names need to match
        !functionNamesMatch(frameVariable.function, cachedFrameVariable.function)
      ) {
        continue;
      }
      frameVariable.vars = cachedFrameVariable.vars;
    }
  }
  function addLocalVariablesToEvent(event) {
    for (const exception of _optionalChain([event, "access", (_5) => _5.exception, "optionalAccess", (_6) => _6.values]) || []) {
      addLocalVariablesToException(exception);
    }
    return event;
  }
  async function startInspector() {
    const inspector = await import("node:inspector");
    if (!inspector.url()) {
      inspector.open(0);
    }
  }
  function startWorker(options) {
    const worker = new Worker(new URL(`data:application/javascript;base64,${base64WorkerScript}`), {
      workerData: options,
      // We don't want any Node args to be passed to the worker
      execArgv: []
    });
    process.on("exit", () => {
      worker.terminate();
    });
    worker.on("message", ({ exceptionHash, frames }) => {
      cachedFrames.set(exceptionHash, frames);
    });
    worker.once("error", (err) => {
      log("Worker error", err);
    });
    worker.once("exit", (code) => {
      log("Worker exit", code);
    });
    worker.unref();
  }
  return {
    name: "LocalVariablesAsync",
    setup(client) {
      const clientOptions = client.getOptions();
      if (!clientOptions.includeLocalVariables) {
        return;
      }
      const options = {
        ...integrationOptions,
        debug: logger.isEnabled()
      };
      startInspector().then(
        () => {
          try {
            startWorker(options);
          } catch (e) {
            logger.error("Failed to start worker", e);
          }
        },
        (e) => {
          logger.error("Failed to start inspector", e);
        }
      );
    },
    processEvent(event) {
      return addLocalVariablesToEvent(event);
    }
  };
});

// ../../node_modules/@sentry/node/build/esm/integrations/local-variables/local-variables-sync.js
init_esm_shims();
function createCallbackList(complete) {
  let callbacks = [];
  let completedCalled = false;
  function checkedComplete(result) {
    callbacks = [];
    if (completedCalled) {
      return;
    }
    completedCalled = true;
    complete(result);
  }
  callbacks.push(checkedComplete);
  function add(fn) {
    callbacks.push(fn);
  }
  function next(result) {
    const popped = callbacks.pop() || checkedComplete;
    try {
      popped(result);
    } catch (_) {
      checkedComplete(result);
    }
  }
  return { add, next };
}
var AsyncSession = class _AsyncSession {
  /** Throws if inspector API is not available */
  constructor(_session) {
    this._session = _session;
  }
  static async create(orDefault) {
    if (orDefault) {
      return orDefault;
    }
    const inspector = await import("node:inspector");
    return new _AsyncSession(new inspector.Session());
  }
  /** @inheritdoc */
  configureAndConnect(onPause, captureAll) {
    this._session.connect();
    this._session.on("Debugger.paused", (event) => {
      onPause(event, () => {
        this._session.post("Debugger.resume");
      });
    });
    this._session.post("Debugger.enable");
    this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
  }
  setPauseOnExceptions(captureAll) {
    this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
  }
  /** @inheritdoc */
  getLocalVariables(objectId, complete) {
    this._getProperties(objectId, (props) => {
      const { add, next } = createCallbackList(complete);
      for (const prop of props) {
        if (_optionalChain([prop, "optionalAccess", (_2) => _2.value, "optionalAccess", (_3) => _3.objectId]) && _optionalChain([prop, "optionalAccess", (_4) => _4.value, "access", (_5) => _5.className]) === "Array") {
          const id = prop.value.objectId;
          add((vars) => this._unrollArray(id, prop.name, vars, next));
        } else if (_optionalChain([prop, "optionalAccess", (_6) => _6.value, "optionalAccess", (_7) => _7.objectId]) && _optionalChain([prop, "optionalAccess", (_8) => _8.value, "optionalAccess", (_9) => _9.className]) === "Object") {
          const id = prop.value.objectId;
          add((vars) => this._unrollObject(id, prop.name, vars, next));
        } else if (_optionalChain([prop, "optionalAccess", (_10) => _10.value])) {
          add((vars) => this._unrollOther(prop, vars, next));
        }
      }
      next({});
    });
  }
  /**
   * Gets all the PropertyDescriptors of an object
   */
  _getProperties(objectId, next) {
    this._session.post(
      "Runtime.getProperties",
      {
        objectId,
        ownProperties: true
      },
      (err, params) => {
        if (err) {
          next([]);
        } else {
          next(params.result);
        }
      }
    );
  }
  /**
   * Unrolls an array property
   */
  _unrollArray(objectId, name, vars, next) {
    this._getProperties(objectId, (props) => {
      vars[name] = props.filter((v) => v.name !== "length" && !isNaN(parseInt(v.name, 10))).sort((a, b) => parseInt(a.name, 10) - parseInt(b.name, 10)).map((v) => _optionalChain([v, "optionalAccess", (_11) => _11.value, "optionalAccess", (_12) => _12.value]));
      next(vars);
    });
  }
  /**
   * Unrolls an object property
   */
  _unrollObject(objectId, name, vars, next) {
    this._getProperties(objectId, (props) => {
      vars[name] = props.map((v) => [v.name, _optionalChain([v, "optionalAccess", (_13) => _13.value, "optionalAccess", (_14) => _14.value])]).reduce((obj, [key, val]) => {
        obj[key] = val;
        return obj;
      }, {});
      next(vars);
    });
  }
  /**
   * Unrolls other properties
   */
  _unrollOther(prop, vars, next) {
    if (prop.value) {
      if ("value" in prop.value) {
        if (prop.value.value === void 0 || prop.value.value === null) {
          vars[prop.name] = `<${prop.value.value}>`;
        } else {
          vars[prop.name] = prop.value.value;
        }
      } else if ("description" in prop.value && prop.value.type !== "function") {
        vars[prop.name] = `<${prop.value.description}>`;
      } else if (prop.value.type === "undefined") {
        vars[prop.name] = "<undefined>";
      }
    }
    next(vars);
  }
};
var INTEGRATION_NAME5 = "LocalVariables";
var _localVariablesSyncIntegration = (options = {}, sessionOverride) => {
  const cachedFrames = new LRUMap(20);
  let rateLimiter;
  let shouldProcessEvent = false;
  function addLocalVariablesToException(exception) {
    const hash = hashFrames(_optionalChain([exception, "optionalAccess", (_15) => _15.stacktrace, "optionalAccess", (_16) => _16.frames]));
    if (hash === void 0) {
      return;
    }
    const cachedFrame = cachedFrames.remove(hash);
    if (cachedFrame === void 0) {
      return;
    }
    const frames = (_optionalChain([exception, "access", (_17) => _17.stacktrace, "optionalAccess", (_18) => _18.frames]) || []).filter((frame) => frame.function !== "new Promise");
    for (let i = 0; i < frames.length; i++) {
      const frameIndex = frames.length - i - 1;
      const cachedFrameVariable = cachedFrame[i];
      const frameVariable = frames[frameIndex];
      if (!frameVariable || !cachedFrameVariable) {
        break;
      }
      if (
        // We need to have vars to add
        cachedFrameVariable.vars === void 0 || // We're not interested in frames that are not in_app because the vars are not relevant
        frameVariable.in_app === false || // The function names need to match
        !functionNamesMatch(frameVariable.function, cachedFrameVariable.function)
      ) {
        continue;
      }
      frameVariable.vars = cachedFrameVariable.vars;
    }
  }
  function addLocalVariablesToEvent(event) {
    for (const exception of _optionalChain([event, "optionalAccess", (_19) => _19.exception, "optionalAccess", (_20) => _20.values]) || []) {
      addLocalVariablesToException(exception);
    }
    return event;
  }
  return {
    name: INTEGRATION_NAME5,
    setupOnce() {
      const client = getClient();
      const clientOptions = _optionalChain([client, "optionalAccess", (_21) => _21.getOptions, "call", (_22) => _22()]);
      if (!_optionalChain([clientOptions, "optionalAccess", (_23) => _23.includeLocalVariables])) {
        return;
      }
      const unsupportedNodeVersion = NODE_MAJOR < 18;
      if (unsupportedNodeVersion) {
        logger.log("The `LocalVariables` integration is only supported on Node >= v18.");
        return;
      }
      AsyncSession.create(sessionOverride).then(
        (session) => {
          function handlePaused(stackParser, { params: { reason, data, callFrames } }, complete) {
            if (reason !== "exception" && reason !== "promiseRejection") {
              complete();
              return;
            }
            _optionalChain([rateLimiter, "optionalCall", (_24) => _24()]);
            const exceptionHash = hashFromStack(stackParser, _optionalChain([data, "optionalAccess", (_25) => _25.description]));
            if (exceptionHash == void 0) {
              complete();
              return;
            }
            const { add, next } = createCallbackList((frames) => {
              cachedFrames.set(exceptionHash, frames);
              complete();
            });
            for (let i = 0; i < Math.min(callFrames.length, 5); i++) {
              const { scopeChain, functionName, this: obj } = callFrames[i];
              const localScope = scopeChain.find((scope) => scope.type === "local");
              const fn = obj.className === "global" || !obj.className ? functionName : `${obj.className}.${functionName}`;
              if (_optionalChain([localScope, "optionalAccess", (_26) => _26.object, "access", (_27) => _27.objectId]) === void 0) {
                add((frames) => {
                  frames[i] = { function: fn };
                  next(frames);
                });
              } else {
                const id = localScope.object.objectId;
                add(
                  (frames) => _optionalChain([session, "optionalAccess", (_28) => _28.getLocalVariables, "call", (_29) => _29(id, (vars) => {
                    frames[i] = { function: fn, vars };
                    next(frames);
                  })])
                );
              }
            }
            next([]);
          }
          const captureAll = options.captureAllExceptions !== false;
          session.configureAndConnect(
            (ev, complete) => handlePaused(clientOptions.stackParser, ev, complete),
            captureAll
          );
          if (captureAll) {
            const max = options.maxExceptionsPerSecond || 50;
            rateLimiter = createRateLimiter(
              max,
              () => {
                logger.log("Local variables rate-limit lifted.");
                _optionalChain([session, "optionalAccess", (_30) => _30.setPauseOnExceptions, "call", (_31) => _31(true)]);
              },
              (seconds) => {
                logger.log(
                  `Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${seconds} seconds.`
                );
                _optionalChain([session, "optionalAccess", (_32) => _32.setPauseOnExceptions, "call", (_33) => _33(false)]);
              }
            );
          }
          shouldProcessEvent = true;
        },
        (error) => {
          logger.log("The `LocalVariables` integration failed to start.", error);
        }
      );
    },
    processEvent(event) {
      if (shouldProcessEvent) {
        return addLocalVariablesToEvent(event);
      }
      return event;
    },
    // These are entirely for testing
    _getCachedFramesCount() {
      return cachedFrames.size;
    },
    _getFirstCachedFrame() {
      return cachedFrames.values()[0];
    }
  };
};
var localVariablesSyncIntegration = defineIntegration(_localVariablesSyncIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/local-variables/index.js
var localVariablesIntegration = (options = {}) => {
  return NODE_VERSION.major < 19 ? localVariablesSyncIntegration(options) : localVariablesAsyncIntegration(options);
};

// ../../node_modules/@sentry/node/build/esm/integrations/modules.js
init_esm_shims();
import { existsSync, readFileSync as readFileSync2 } from "node:fs";
import { dirname as dirname3, join as join3 } from "node:path";
var moduleCache;
var INTEGRATION_NAME6 = "Modules";
var _modulesIntegration = () => {
  return {
    name: INTEGRATION_NAME6,
    processEvent(event) {
      event.modules = {
        ...event.modules,
        ..._getModules()
      };
      return event;
    }
  };
};
var modulesIntegration = defineIntegration(_modulesIntegration);
function getPaths() {
  try {
    return __require.cache ? Object.keys(__require.cache) : [];
  } catch (e) {
    return [];
  }
}
function collectModules() {
  const mainPaths = __require.main && __require.main.paths || [];
  const paths = getPaths();
  const infos = {};
  const seen = {};
  paths.forEach((path3) => {
    let dir = path3;
    const updir = () => {
      const orig = dir;
      dir = dirname3(orig);
      if (!dir || orig === dir || seen[orig]) {
        return void 0;
      }
      if (mainPaths.indexOf(dir) < 0) {
        return updir();
      }
      const pkgfile = join3(orig, "package.json");
      seen[orig] = true;
      if (!existsSync(pkgfile)) {
        return updir();
      }
      try {
        const info = JSON.parse(readFileSync2(pkgfile, "utf8"));
        infos[info.name] = info.version;
      } catch (_oO) {
      }
    };
    updir();
  });
  return infos;
}
function _getModules() {
  if (!moduleCache) {
    moduleCache = collectModules();
  }
  return moduleCache;
}

// ../../node_modules/@sentry/node/build/esm/integrations/onuncaughtexception.js
init_esm_shims();

// ../../node_modules/@sentry/node/build/esm/utils/errorhandling.js
init_esm_shims();
var DEFAULT_SHUTDOWN_TIMEOUT = 2e3;
function logAndExitProcess(error) {
  consoleSandbox(() => {
    console.error(error);
  });
  const client = getClient();
  if (client === void 0) {
    DEBUG_BUILD && logger.warn("No NodeClient was defined, we are exiting the process now.");
    global.process.exit(1);
    return;
  }
  const options = client.getOptions();
  const timeout = options && options.shutdownTimeout && options.shutdownTimeout > 0 && options.shutdownTimeout || DEFAULT_SHUTDOWN_TIMEOUT;
  client.close(timeout).then(
    (result) => {
      if (!result) {
        DEBUG_BUILD && logger.warn("We reached the timeout for emptying the request buffer, still exiting now!");
      }
      global.process.exit(1);
    },
    (error2) => {
      DEBUG_BUILD && logger.error(error2);
    }
  );
}

// ../../node_modules/@sentry/node/build/esm/integrations/onuncaughtexception.js
var INTEGRATION_NAME7 = "OnUncaughtException";
var onUncaughtExceptionIntegration = defineIntegration((options = {}) => {
  const optionsWithDefaults = {
    exitEvenIfOtherHandlersAreRegistered: false,
    ...options
  };
  return {
    name: INTEGRATION_NAME7,
    setup(client) {
      global.process.on("uncaughtException", makeErrorHandler(client, optionsWithDefaults));
    }
  };
});
function makeErrorHandler(client, options) {
  const timeout = 2e3;
  let caughtFirstError = false;
  let caughtSecondError = false;
  let calledFatalError = false;
  let firstError;
  const clientOptions = client.getOptions();
  return Object.assign(
    (error) => {
      let onFatalError = logAndExitProcess;
      if (options.onFatalError) {
        onFatalError = options.onFatalError;
      } else if (clientOptions.onFatalError) {
        onFatalError = clientOptions.onFatalError;
      }
      const userProvidedListenersCount = global.process.listeners("uncaughtException").filter(
        (listener) => {
          return (
            // as soon as we're using domains this listener is attached by node itself
            listener.name !== "domainUncaughtExceptionClear" && // the handler we register for tracing
            listener.tag !== "sentry_tracingErrorCallback" && // the handler we register in this integration
            listener._errorHandler !== true
          );
        }
      ).length;
      const processWouldExit = userProvidedListenersCount === 0;
      const shouldApplyFatalHandlingLogic = options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;
      if (!caughtFirstError) {
        firstError = error;
        caughtFirstError = true;
        if (getClient() === client) {
          captureException(error, {
            originalException: error,
            captureContext: {
              level: "fatal"
            },
            mechanism: {
              handled: false,
              type: "onuncaughtexception"
            }
          });
        }
        if (!calledFatalError && shouldApplyFatalHandlingLogic) {
          calledFatalError = true;
          onFatalError(error);
        }
      } else {
        if (shouldApplyFatalHandlingLogic) {
          if (calledFatalError) {
            DEBUG_BUILD && logger.warn(
              "uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown"
            );
            logAndExitProcess(error);
          } else if (!caughtSecondError) {
            caughtSecondError = true;
            setTimeout(() => {
              if (!calledFatalError) {
                calledFatalError = true;
                onFatalError(firstError, error);
              }
            }, timeout);
          }
        }
      }
    },
    { _errorHandler: true }
  );
}

// ../../node_modules/@sentry/node/build/esm/integrations/onunhandledrejection.js
init_esm_shims();
var INTEGRATION_NAME8 = "OnUnhandledRejection";
var _onUnhandledRejectionIntegration = (options = {}) => {
  const mode = options.mode || "warn";
  return {
    name: INTEGRATION_NAME8,
    setup(client) {
      global.process.on("unhandledRejection", makeUnhandledPromiseHandler(client, { mode }));
    }
  };
};
var onUnhandledRejectionIntegration = defineIntegration(_onUnhandledRejectionIntegration);
function makeUnhandledPromiseHandler(client, options) {
  return function sendUnhandledPromise(reason, promise) {
    if (getClient() !== client) {
      return;
    }
    captureException(reason, {
      originalException: promise,
      captureContext: {
        extra: { unhandledPromiseRejection: true }
      },
      mechanism: {
        handled: false,
        type: "onunhandledrejection"
      }
    });
    handleRejection(reason, options);
  };
}
function handleRejection(reason, options) {
  const rejectionWarning = "This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:";
  if (options.mode === "warn") {
    consoleSandbox(() => {
      console.warn(rejectionWarning);
      console.error(reason && reason.stack ? reason.stack : reason);
    });
  } else if (options.mode === "strict") {
    consoleSandbox(() => {
      console.warn(rejectionWarning);
    });
    logAndExitProcess(reason);
  }
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/express.js
init_esm_shims();
var import_instrumentation_express = __toESM(require_src3(), 1);

// ../../node_modules/@sentry/node/build/esm/otel/instrument.js
init_esm_shims();
var INSTRUMENTED = {};
function generateInstrumentOnce(name, creator) {
  return Object.assign(
    (options) => {
      const instrumented = INSTRUMENTED[name];
      if (instrumented) {
        if (options) {
          instrumented.setConfig(options);
        }
        return;
      }
      const instrumentation = creator(options);
      INSTRUMENTED[name] = instrumentation;
      addOpenTelemetryInstrumentation(instrumentation);
    },
    { id: name }
  );
}

// ../../node_modules/@sentry/node/build/esm/utils/commonjs.js
init_esm_shims();
function isCjs() {
  return typeof __require !== "undefined";
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/express.js
var INTEGRATION_NAME9 = "Express";
var instrumentExpress = generateInstrumentOnce(
  INTEGRATION_NAME9,
  () => new import_instrumentation_express.ExpressInstrumentation({
    requestHook(span) {
      addOriginToSpan(span, "auto.http.otel.express");
      const attributes = spanToJSON(span).data || {};
      const type = attributes["express.type"];
      if (type) {
        span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, `${type}.express`);
      }
      const name = attributes["express.name"];
      if (typeof name === "string") {
        span.updateName(name);
      }
    },
    spanNameHook(info, defaultName) {
      if (getIsolationScope() === getDefaultIsolationScope()) {
        DEBUG_BUILD && logger.warn("Isolation scope is still default isolation scope - skipping setting transactionName");
        return defaultName;
      }
      if (info.layerType === "request_handler") {
        const req = info.request;
        const method = req.method ? req.method.toUpperCase() : "GET";
        getIsolationScope().setTransactionName(`${method} ${info.route}`);
      }
      return defaultName;
    }
  })
);
var _expressIntegration = () => {
  return {
    name: INTEGRATION_NAME9,
    setupOnce() {
      instrumentExpress();
    }
  };
};
var expressIntegration = defineIntegration(_expressIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/fastify.js
init_esm_shims();
var import_instrumentation_fastify = __toESM(require_src4(), 1);
var INTEGRATION_NAME10 = "Fastify";
var instrumentFastify = generateInstrumentOnce(
  INTEGRATION_NAME10,
  () => new import_instrumentation_fastify.FastifyInstrumentation({
    requestHook(span) {
      addFastifySpanAttributes(span);
    }
  })
);
var _fastifyIntegration = () => {
  return {
    name: INTEGRATION_NAME10,
    setupOnce() {
      instrumentFastify();
    }
  };
};
var fastifyIntegration = defineIntegration(_fastifyIntegration);
function addFastifySpanAttributes(span) {
  const attributes = spanToJSON(span).data || {};
  const type = attributes["fastify.type"];
  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] || !type) {
    return;
  }
  span.setAttributes({
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.otel.fastify",
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${type}.fastify`
  });
  const name = attributes["fastify.name"] || attributes["plugin.name"] || attributes["hook.name"];
  if (typeof name === "string") {
    span.updateName(name.replace(/^fastify -> /, ""));
  }
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/graphql.js
init_esm_shims();
var import_instrumentation_graphql = __toESM(require_src5(), 1);
var INTEGRATION_NAME11 = "Graphql";
var instrumentGraphql = generateInstrumentOnce(
  INTEGRATION_NAME11,
  (_options = {}) => {
    const options = {
      ignoreResolveSpans: true,
      ignoreTrivialResolveSpans: true,
      ..._options
    };
    return new import_instrumentation_graphql.GraphQLInstrumentation({
      ...options,
      responseHook(span) {
        addOriginToSpan(span, "auto.graphql.otel.graphql");
      }
    });
  }
);
var _graphqlIntegration = (options = {}) => {
  return {
    name: INTEGRATION_NAME11,
    setupOnce() {
      instrumentGraphql(options);
    }
  };
};
var graphqlIntegration = defineIntegration(_graphqlIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/mongo.js
init_esm_shims();
var import_instrumentation_mongodb = __toESM(require_src6(), 1);
var INTEGRATION_NAME12 = "Mongo";
var instrumentMongo = generateInstrumentOnce(
  INTEGRATION_NAME12,
  () => new import_instrumentation_mongodb.MongoDBInstrumentation({
    responseHook(span) {
      addOriginToSpan(span, "auto.db.otel.mongo");
    }
  })
);
var _mongoIntegration = () => {
  return {
    name: INTEGRATION_NAME12,
    setupOnce() {
      instrumentMongo();
    }
  };
};
var mongoIntegration = defineIntegration(_mongoIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/mongoose.js
init_esm_shims();
var import_instrumentation_mongoose = __toESM(require_src7(), 1);
var INTEGRATION_NAME13 = "Mongoose";
var instrumentMongoose = generateInstrumentOnce(
  INTEGRATION_NAME13,
  () => new import_instrumentation_mongoose.MongooseInstrumentation({
    responseHook(span) {
      addOriginToSpan(span, "auto.db.otel.mongoose");
    }
  })
);
var _mongooseIntegration = () => {
  return {
    name: INTEGRATION_NAME13,
    setupOnce() {
      instrumentMongoose();
    }
  };
};
var mongooseIntegration = defineIntegration(_mongooseIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/mysql.js
init_esm_shims();
var import_instrumentation_mysql = __toESM(require_src8(), 1);
var INTEGRATION_NAME14 = "Mysql";
var instrumentMysql = generateInstrumentOnce(INTEGRATION_NAME14, () => new import_instrumentation_mysql.MySQLInstrumentation({}));
var _mysqlIntegration = () => {
  return {
    name: INTEGRATION_NAME14,
    setupOnce() {
      instrumentMysql();
    }
  };
};
var mysqlIntegration = defineIntegration(_mysqlIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/mysql2.js
init_esm_shims();
var import_instrumentation_mysql2 = __toESM(require_src10(), 1);
var INTEGRATION_NAME15 = "Mysql2";
var instrumentMysql2 = generateInstrumentOnce(
  INTEGRATION_NAME15,
  () => new import_instrumentation_mysql2.MySQL2Instrumentation({
    responseHook(span) {
      addOriginToSpan(span, "auto.db.otel.mysql2");
    }
  })
);
var _mysql2Integration = () => {
  return {
    name: INTEGRATION_NAME15,
    setupOnce() {
      instrumentMysql2();
    }
  };
};
var mysql2Integration = defineIntegration(_mysql2Integration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/redis.js
init_esm_shims();
var import_instrumentation_ioredis = __toESM(require_src12(), 1);
var import_instrumentation_redis_4 = __toESM(require_src13(), 1);

// ../../node_modules/@sentry/node/build/esm/utils/redisCache.js
init_esm_shims();
var SINGLE_ARG_COMMANDS = ["get", "set", "setex"];
var GET_COMMANDS = ["get", "mget"];
var SET_COMMANDS = ["set", "setex"];
function isInCommands(redisCommands, command) {
  return redisCommands.includes(command.toLowerCase());
}
function getCacheOperation(command) {
  if (isInCommands(GET_COMMANDS, command)) {
    return "cache.get";
  } else if (isInCommands(SET_COMMANDS, command)) {
    return "cache.put";
  } else {
    return void 0;
  }
}
function keyHasPrefix(key, prefixes) {
  return prefixes.some((prefix) => key.startsWith(prefix));
}
function getCacheKeySafely(redisCommand, cmdArgs) {
  try {
    if (cmdArgs.length === 0) {
      return void 0;
    }
    const processArg = (arg) => {
      if (typeof arg === "string" || typeof arg === "number" || Buffer.isBuffer(arg)) {
        return [arg.toString()];
      } else if (Array.isArray(arg)) {
        return flatten(arg.map((arg2) => processArg(arg2)));
      } else {
        return ["<unknown>"];
      }
    };
    const firstArg = cmdArgs[0];
    if (isInCommands(SINGLE_ARG_COMMANDS, redisCommand) && firstArg != null) {
      return processArg(firstArg);
    }
    return flatten(cmdArgs.map((arg) => processArg(arg)));
  } catch (e) {
    return void 0;
  }
}
function shouldConsiderForCache(redisCommand, keys, prefixes) {
  if (!getCacheOperation(redisCommand)) {
    return false;
  }
  for (const key of keys) {
    if (keyHasPrefix(key, prefixes)) {
      return true;
    }
  }
  return false;
}
function calculateCacheItemSize(response) {
  const getSize = (value) => {
    try {
      if (Buffer.isBuffer(value)) return value.byteLength;
      else if (typeof value === "string") return value.length;
      else if (typeof value === "number") return value.toString().length;
      else if (value === null || value === void 0) return 0;
      return JSON.stringify(value).length;
    } catch (e) {
      return void 0;
    }
  };
  return Array.isArray(response) ? response.reduce((acc, curr) => {
    const size = getSize(curr);
    return typeof size === "number" ? acc !== void 0 ? acc + size : size : acc;
  }, 0) : getSize(response);
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/redis.js
var INTEGRATION_NAME16 = "Redis";
var _redisOptions = {};
var cacheResponseHook = (span, redisCommand, cmdArgs, response) => {
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.db.otel.redis");
  const safeKey = getCacheKeySafely(redisCommand, cmdArgs);
  const cacheOperation = getCacheOperation(redisCommand);
  if (!safeKey || !cacheOperation || !_optionalChain([_redisOptions, "optionalAccess", (_) => _.cachePrefixes]) || !shouldConsiderForCache(redisCommand, safeKey, _redisOptions.cachePrefixes)) {
    return;
  }
  const networkPeerAddress = _optionalChain([spanToJSON, "call", (_2) => _2(span), "access", (_3) => _3.data, "optionalAccess", (_4) => _4["net.peer.name"]]);
  const networkPeerPort = _optionalChain([spanToJSON, "call", (_5) => _5(span), "access", (_6) => _6.data, "optionalAccess", (_7) => _7["net.peer.port"]]);
  if (networkPeerPort && networkPeerAddress) {
    span.setAttributes({ "network.peer.address": networkPeerAddress, "network.peer.port": networkPeerPort });
  }
  const cacheItemSize = calculateCacheItemSize(response);
  if (cacheItemSize) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE, cacheItemSize);
  }
  if (isInCommands(GET_COMMANDS, redisCommand) && cacheItemSize !== void 0) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_CACHE_HIT, cacheItemSize > 0);
  }
  span.setAttributes({
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: cacheOperation,
    [SEMANTIC_ATTRIBUTE_CACHE_KEY]: safeKey
  });
  const spanDescription = safeKey.join(", ");
  span.updateName(truncate(spanDescription, 1024));
};
var instrumentIORedis = generateInstrumentOnce("IORedis", () => {
  return new import_instrumentation_ioredis.IORedisInstrumentation({
    responseHook: cacheResponseHook
  });
});
var instrumentRedis4 = generateInstrumentOnce("Redis-4", () => {
  return new import_instrumentation_redis_4.RedisInstrumentation({
    responseHook: cacheResponseHook
  });
});
var instrumentRedis = Object.assign(
  () => {
    instrumentIORedis();
    instrumentRedis4();
  },
  { id: INTEGRATION_NAME16 }
);
var _redisIntegration = (options = {}) => {
  return {
    name: INTEGRATION_NAME16,
    setupOnce() {
      _redisOptions = options;
      instrumentRedis();
    }
  };
};
var redisIntegration = defineIntegration(_redisIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/nest.js
init_esm_shims();
var import_instrumentation_nestjs_core = __toESM(require_src14(), 1);
var INTEGRATION_NAME17 = "Nest";
var instrumentNest = generateInstrumentOnce(INTEGRATION_NAME17, () => new import_instrumentation_nestjs_core.NestInstrumentation());
var _nestIntegration = () => {
  return {
    name: INTEGRATION_NAME17,
    setupOnce() {
      instrumentNest();
    }
  };
};
var nestIntegration = defineIntegration(_nestIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/postgres.js
init_esm_shims();
var import_instrumentation_pg = __toESM(require_src15(), 1);
var INTEGRATION_NAME18 = "Postgres";
var instrumentPostgres = generateInstrumentOnce(
  INTEGRATION_NAME18,
  () => new import_instrumentation_pg.PgInstrumentation({
    requireParentSpan: true,
    requestHook(span) {
      addOriginToSpan(span, "auto.db.otel.postgres");
    }
  })
);
var _postgresIntegration = () => {
  return {
    name: INTEGRATION_NAME18,
    setupOnce() {
      instrumentPostgres();
    }
  };
};
var postgresIntegration = defineIntegration(_postgresIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/hapi/index.js
init_esm_shims();
var import_instrumentation_hapi = __toESM(require_src16(), 1);
var INTEGRATION_NAME19 = "Hapi";
var instrumentHapi = generateInstrumentOnce(INTEGRATION_NAME19, () => new import_instrumentation_hapi.HapiInstrumentation());
var _hapiIntegration = () => {
  return {
    name: INTEGRATION_NAME19,
    setupOnce() {
      instrumentHapi();
    }
  };
};
var hapiIntegration = defineIntegration(_hapiIntegration);

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/koa.js
init_esm_shims();
var import_instrumentation_koa = __toESM(require_src17(), 1);
init_esm2();
var INTEGRATION_NAME20 = "Koa";
var instrumentKoa = generateInstrumentOnce(
  INTEGRATION_NAME20,
  () => new import_instrumentation_koa.KoaInstrumentation({
    requestHook(span, info) {
      addKoaSpanAttributes(span);
      if (getIsolationScope() === getDefaultIsolationScope()) {
        DEBUG_BUILD && logger.warn("Isolation scope is default isolation scope - skipping setting transactionName");
        return;
      }
      const attributes = spanToJSON(span).data;
      const route = attributes && attributes[SEMATTRS_HTTP_ROUTE];
      const method = _optionalChain([info, "optionalAccess", (_) => _.context, "optionalAccess", (_2) => _2.request, "optionalAccess", (_3) => _3.method, "optionalAccess", (_4) => _4.toUpperCase, "call", (_5) => _5()]) || "GET";
      if (route) {
        getIsolationScope().setTransactionName(`${method} ${route}`);
      }
    }
  })
);
var _koaIntegration = () => {
  return {
    name: INTEGRATION_NAME20,
    setupOnce() {
      instrumentKoa();
    }
  };
};
var koaIntegration = defineIntegration(_koaIntegration);
function addKoaSpanAttributes(span) {
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, "auto.http.otel.koa");
  const attributes = spanToJSON(span).data || {};
  const type = attributes["koa.type"];
  if (type) {
    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, `${type}.koa`);
  }
  const name = attributes["koa.name"];
  if (typeof name === "string") {
    span.updateName(name || "< unknown >");
  }
}

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/connect.js
init_esm_shims();
var import_instrumentation_connect = __toESM(require_src18(), 1);
var INTEGRATION_NAME21 = "Connect";
var instrumentConnect = generateInstrumentOnce(INTEGRATION_NAME21, () => new import_instrumentation_connect.ConnectInstrumentation());
var _connectIntegration = () => {
  return {
    name: INTEGRATION_NAME21,
    setupOnce() {
      instrumentConnect();
    }
  };
};
var connectIntegration = defineIntegration(_connectIntegration);

// ../../node_modules/@sentry/node/build/esm/sdk/index.js
init_esm_shims();

// ../../node_modules/@sentry/node/build/esm/integrations/tracing/index.js
init_esm_shims();
function getAutoPerformanceIntegrations() {
  return [
    expressIntegration(),
    fastifyIntegration(),
    graphqlIntegration(),
    mongoIntegration(),
    mongooseIntegration(),
    mysqlIntegration(),
    mysql2Integration(),
    redisIntegration(),
    postgresIntegration(),
    // For now, we do not include prisma by default because it has ESM issues
    // See https://github.com/prisma/prisma/issues/23410
    // TODO v8: Figure out a better solution for this, maybe only disable in ESM mode?
    // prismaIntegration(),
    nestIntegration(),
    hapiIntegration(),
    koaIntegration(),
    connectIntegration()
  ];
}

// ../../node_modules/@sentry/node/build/esm/transports/http.js
init_esm_shims();
import * as http2 from "node:http";
import * as https from "node:https";
import { Readable } from "node:stream";
import { createGzip } from "node:zlib";

// ../../node_modules/@sentry/node/build/esm/proxy/index.js
init_esm_shims();
import * as net from "node:net";
import * as tls from "node:tls";

// ../../node_modules/@sentry/node/build/esm/proxy/base.js
init_esm_shims();
import * as http from "node:http";
var INTERNAL = Symbol("AgentBaseInternalState");
var Agent2 = class extends http.Agent {
  // Set by `http.Agent` - missing from `@types/node`
  constructor(opts) {
    super(opts);
    this[INTERNAL] = {};
  }
  /**
   * Determine whether this is an `http` or `https` request.
   */
  isSecureEndpoint(options) {
    if (options) {
      if (typeof options.secureEndpoint === "boolean") {
        return options.secureEndpoint;
      }
      if (typeof options.protocol === "string") {
        return options.protocol === "https:";
      }
    }
    const { stack } = new Error();
    if (typeof stack !== "string") return false;
    return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
  }
  createSocket(req, options, cb) {
    const connectOpts = {
      ...options,
      secureEndpoint: this.isSecureEndpoint(options)
    };
    Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
      if (socket instanceof http.Agent) {
        return socket.addRequest(req, connectOpts);
      }
      this[INTERNAL].currentSocket = socket;
      super.createSocket(req, options, cb);
    }, cb);
  }
  createConnection() {
    const socket = this[INTERNAL].currentSocket;
    this[INTERNAL].currentSocket = void 0;
    if (!socket) {
      throw new Error("No socket was returned in the `connect()` function");
    }
    return socket;
  }
  get defaultPort() {
    return _nullishCoalesce(this[INTERNAL].defaultPort, () => this.protocol === "https:" ? 443 : 80);
  }
  set defaultPort(v) {
    if (this[INTERNAL]) {
      this[INTERNAL].defaultPort = v;
    }
  }
  get protocol() {
    return _nullishCoalesce(this[INTERNAL].protocol, () => this.isSecureEndpoint() ? "https:" : "http:");
  }
  set protocol(v) {
    if (this[INTERNAL]) {
      this[INTERNAL].protocol = v;
    }
  }
};

// ../../node_modules/@sentry/node/build/esm/proxy/parse-proxy-response.js
init_esm_shims();
function debug(...args) {
  logger.log("[https-proxy-agent:parse-proxy-response]", ...args);
}
function parseProxyResponse(socket) {
  return new Promise((resolve, reject) => {
    let buffersLength = 0;
    const buffers = [];
    function read() {
      const b = socket.read();
      if (b) ondata(b);
      else socket.once("readable", read);
    }
    function cleanup() {
      socket.removeListener("end", onend);
      socket.removeListener("error", onerror);
      socket.removeListener("readable", read);
    }
    function onend() {
      cleanup();
      debug("onend");
      reject(new Error("Proxy connection ended before receiving CONNECT response"));
    }
    function onerror(err) {
      cleanup();
      debug("onerror %o", err);
      reject(err);
    }
    function ondata(b) {
      buffers.push(b);
      buffersLength += b.length;
      const buffered = Buffer.concat(buffers, buffersLength);
      const endOfHeaders = buffered.indexOf("\r\n\r\n");
      if (endOfHeaders === -1) {
        debug("have not received end of HTTP headers yet...");
        read();
        return;
      }
      const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
      const firstLine = headerParts.shift();
      if (!firstLine) {
        socket.destroy();
        return reject(new Error("No header received from proxy CONNECT response"));
      }
      const firstLineParts = firstLine.split(" ");
      const statusCode = +(firstLineParts[1] || 0);
      const statusText = firstLineParts.slice(2).join(" ");
      const headers = {};
      for (const header of headerParts) {
        if (!header) continue;
        const firstColon = header.indexOf(":");
        if (firstColon === -1) {
          socket.destroy();
          return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
        }
        const key = header.slice(0, firstColon).toLowerCase();
        const value = header.slice(firstColon + 1).trimStart();
        const current = headers[key];
        if (typeof current === "string") {
          headers[key] = [current, value];
        } else if (Array.isArray(current)) {
          current.push(value);
        } else {
          headers[key] = value;
        }
      }
      debug("got proxy server response: %o %o", firstLine, headers);
      cleanup();
      resolve({
        connect: {
          statusCode,
          statusText,
          headers
        },
        buffered
      });
    }
    socket.on("error", onerror);
    socket.on("end", onend);
    read();
  });
}

// ../../node_modules/@sentry/node/build/esm/proxy/index.js
function debug2(...args) {
  logger.log("[https-proxy-agent]", ...args);
}
var HttpsProxyAgent = class extends Agent2 {
  static __initStatic() {
    this.protocols = ["http", "https"];
  }
  constructor(proxy, opts) {
    super(opts);
    this.options = {};
    this.proxy = typeof proxy === "string" ? new URL(proxy) : proxy;
    this.proxyHeaders = _nullishCoalesce(_optionalChain([opts, "optionalAccess", (_2) => _2.headers]), () => ({}));
    debug2("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      // Attempt to negotiate http/1.1 for proxy servers that support http/2
      ALPNProtocols: ["http/1.1"],
      ...opts ? omit(opts, "headers") : null,
      host,
      port
    };
  }
  /**
   * Called when the node-core HTTP client library is creating a
   * new HTTP request.
   */
  async connect(req, opts) {
    const { proxy } = this;
    if (!opts.host) {
      throw new TypeError('No "host" provided');
    }
    let socket;
    if (proxy.protocol === "https:") {
      debug2("Creating `tls.Socket`: %o", this.connectOpts);
      const servername = this.connectOpts.servername || this.connectOpts.host;
      socket = tls.connect({
        ...this.connectOpts,
        servername: servername && net.isIP(servername) ? void 0 : servername
      });
    } else {
      debug2("Creating `net.Socket`: %o", this.connectOpts);
      socket = net.connect(this.connectOpts);
    }
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
    let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    headers.Host = `${host}:${opts.port}`;
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name of Object.keys(headers)) {
      payload += `${name}: ${headers[name]}\r
`;
    }
    const proxyResponsePromise = parseProxyResponse(socket);
    socket.write(`${payload}\r
`);
    const { connect: connect3, buffered } = await proxyResponsePromise;
    req.emit("proxyConnect", connect3);
    this.emit("proxyConnect", connect3, req);
    if (connect3.statusCode === 200) {
      req.once("socket", resume);
      if (opts.secureEndpoint) {
        debug2("Upgrading socket connection to TLS");
        const servername = opts.servername || opts.host;
        return tls.connect({
          ...omit(opts, "host", "path", "port"),
          socket,
          servername: net.isIP(servername) ? void 0 : servername
        });
      }
      return socket;
    }
    socket.destroy();
    const fakeSocket = new net.Socket({ writable: false });
    fakeSocket.readable = true;
    req.once("socket", (s) => {
      debug2("Replaying proxy buffer for failed request");
      s.push(buffered);
      s.push(null);
    });
    return fakeSocket;
  }
};
HttpsProxyAgent.__initStatic();
function resume(socket) {
  socket.resume();
}
function omit(obj, ...keys) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}

// ../../node_modules/@sentry/node/build/esm/transports/http.js
var GZIP_THRESHOLD = 1024 * 32;
function streamFromBody(body) {
  return new Readable({
    read() {
      this.push(body);
      this.push(null);
    }
  });
}
function makeNodeTransport(options) {
  let urlSegments;
  try {
    urlSegments = new URL(options.url);
  } catch (e) {
    consoleSandbox(() => {
      console.warn(
        "[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used."
      );
    });
    return createTransport(options, () => Promise.resolve({}));
  }
  const isHttps = urlSegments.protocol === "https:";
  const proxy = applyNoProxyOption(
    urlSegments,
    options.proxy || (isHttps ? process.env.https_proxy : void 0) || process.env.http_proxy
  );
  const nativeHttpModule = isHttps ? https : http2;
  const keepAlive = options.keepAlive === void 0 ? false : options.keepAlive;
  const agent = proxy ? new HttpsProxyAgent(proxy) : new nativeHttpModule.Agent({ keepAlive, maxSockets: 30, timeout: 2e3 });
  return suppressTracing(() => {
    const requestExecutor = createRequestExecutor(options, _nullishCoalesce(options.httpModule, () => nativeHttpModule), agent);
    return createTransport(options, requestExecutor);
  });
}
function applyNoProxyOption(transportUrlSegments, proxy) {
  const { no_proxy } = process.env;
  const urlIsExemptFromProxy = no_proxy && no_proxy.split(",").some(
    (exemption) => transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption)
  );
  if (urlIsExemptFromProxy) {
    return void 0;
  } else {
    return proxy;
  }
}
function createRequestExecutor(options, httpModule, agent) {
  const { hostname: hostname2, pathname, port, protocol, search } = new URL(options.url);
  return function makeRequest(request) {
    return new Promise((resolve, reject) => {
      let body = streamFromBody(request.body);
      const headers = { ...options.headers };
      if (request.body.length > GZIP_THRESHOLD) {
        headers["content-encoding"] = "gzip";
        body = body.pipe(createGzip());
      }
      const req = httpModule.request(
        {
          method: "POST",
          agent,
          headers,
          hostname: hostname2,
          path: `${pathname}${search}`,
          port,
          protocol,
          ca: options.caCerts
        },
        (res) => {
          res.on("data", () => {
          });
          res.on("end", () => {
          });
          res.setEncoding("utf8");
          const retryAfterHeader = _nullishCoalesce(res.headers["retry-after"], () => null);
          const rateLimitsHeader = _nullishCoalesce(res.headers["x-sentry-rate-limits"], () => null);
          resolve({
            statusCode: res.statusCode,
            headers: {
              "retry-after": retryAfterHeader,
              "x-sentry-rate-limits": Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] || null : rateLimitsHeader
            }
          });
        }
      );
      req.on("error", reject);
      body.pipe(req);
    });
  };
}

// ../../node_modules/@sentry/node/build/esm/sdk/api.js
init_esm_shims();

// ../../node_modules/@sentry/node/build/esm/utils/module.js
init_esm_shims();
import { posix, sep as sep2 } from "node:path";
function normalizeWindowsPath(path3) {
  return path3.replace(/^[A-Z]:/, "").replace(/\\/g, "/");
}
function createGetModuleFromFilename(basePath = process.argv[1] ? dirname(process.argv[1]) : process.cwd(), isWindows = sep2 === "\\") {
  const normalizedBase = isWindows ? normalizeWindowsPath(basePath) : basePath;
  return (filename) => {
    if (!filename) {
      return;
    }
    const normalizedFilename = isWindows ? normalizeWindowsPath(filename) : filename;
    let { dir, base: file, ext } = posix.parse(normalizedFilename);
    if (ext === ".js" || ext === ".mjs" || ext === ".cjs") {
      file = file.slice(0, ext.length * -1);
    }
    if (!dir) {
      dir = ".";
    }
    const n = dir.lastIndexOf("/node_modules");
    if (n > -1) {
      return `${dir.slice(n + 14).replace(/\//g, ".")}:${file}`;
    }
    if (dir.startsWith(normalizedBase)) {
      let moduleName = dir.slice(normalizedBase.length + 1).replace(/\//g, ".");
      if (moduleName) {
        moduleName += ":";
      }
      moduleName += file;
      return moduleName;
    }
    return file;
  };
}

// ../../node_modules/@sentry/node/build/esm/sdk/api.js
var defaultStackParser = createStackParser(nodeStackLineParser(createGetModuleFromFilename()));

// ../../node_modules/@sentry/node/build/esm/sdk/client.js
init_esm_shims();
init_esm();
import * as os2 from "node:os";
import { isMainThread, threadId } from "worker_threads";
var DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS = 6e4;
var NodeClient = class extends ServerRuntimeClient {
  constructor(options) {
    const clientOptions = {
      ...options,
      platform: "node",
      runtime: { name: "node", version: global.process.version },
      serverName: options.serverName || global.process.env.SENTRY_NAME || os2.hostname()
    };
    applySdkMetadata(clientOptions, "node");
    logger.log(
      `Initializing Sentry: process: ${process.pid}, thread: ${isMainThread ? "main" : `worker-${threadId}`}.`
    );
    super(clientOptions);
  }
  /** Get the OTEL tracer. */
  get tracer() {
    if (this._tracer) {
      return this._tracer;
    }
    const name = "@sentry/node";
    const version = SDK_VERSION;
    const tracer = trace.getTracer(name, version);
    this._tracer = tracer;
    return tracer;
  }
  // Eslint ignore explanation: This is already documented in super.
  // eslint-disable-next-line jsdoc/require-jsdoc
  async flush(timeout) {
    const provider = this.traceProvider;
    const spanProcessor = _optionalChain([provider, "optionalAccess", (_) => _.activeSpanProcessor]);
    if (spanProcessor) {
      await spanProcessor.forceFlush();
    }
    if (this.getOptions().sendClientReports) {
      this._flushOutcomes();
    }
    return super.flush(timeout);
  }
  // Eslint ignore explanation: This is already documented in super.
  // eslint-disable-next-line jsdoc/require-jsdoc
  close(timeout) {
    if (this._clientReportInterval) {
      clearInterval(this._clientReportInterval);
    }
    if (this._clientReportOnExitFlushListener) {
      process.off("beforeExit", this._clientReportOnExitFlushListener);
    }
    return super.close(timeout);
  }
  /**
   * Will start tracking client reports for this client.
   *
   * NOTICE: This method will create an interval that is periodically called and attach a `process.on('beforeExit')`
   * hook. To clean up these resources, call `.close()` when you no longer intend to use the client. Not doing so will
   * result in a memory leak.
   */
  // The reason client reports need to be manually activated with this method instead of just enabling them in a
  // constructor, is that if users periodically and unboundedly create new clients, we will create more and more
  // intervals and beforeExit listeners, thus leaking memory. In these situations, users are required to call
  // `client.close()` in order to dispose of the acquired resources.
  // We assume that calling this method in Sentry.init() is a sensible default, because calling Sentry.init() over and
  // over again would also result in memory leaks.
  // Note: We have experimented with using `FinalizationRegisty` to clear the interval when the client is garbage
  // collected, but it did not work, because the cleanup function never got called.
  startClientReportTracking() {
    const clientOptions = this.getOptions();
    if (clientOptions.sendClientReports) {
      this._clientReportOnExitFlushListener = () => {
        this._flushOutcomes();
      };
      this._clientReportInterval = setInterval(
        () => {
          DEBUG_BUILD && logger.log("Flushing client reports based on interval.");
          this._flushOutcomes();
        },
        _nullishCoalesce(clientOptions.clientReportFlushInterval, () => DEFAULT_CLIENT_REPORT_FLUSH_INTERVAL_MS)
      ).unref();
      process.on("beforeExit", this._clientReportOnExitFlushListener);
    }
  }
};

// ../../node_modules/@sentry/node/build/esm/sdk/index.js
function getCjsOnlyIntegrations() {
  return isCjs() ? [modulesIntegration()] : [];
}
function getDefaultIntegrationsWithoutPerformance() {
  return [
    // Common
    inboundFiltersIntegration(),
    functionToStringIntegration(),
    linkedErrorsIntegration(),
    requestDataIntegration(),
    // Native Wrappers
    consoleIntegration(),
    httpIntegration(),
    nativeNodeFetchIntegration(),
    // Global Handlers
    onUncaughtExceptionIntegration(),
    onUnhandledRejectionIntegration(),
    // Event Info
    contextLinesIntegration(),
    localVariablesIntegration(),
    nodeContextIntegration(),
    ...getCjsOnlyIntegrations()
  ];
}
function getDefaultIntegrations(options) {
  return [
    ...getDefaultIntegrationsWithoutPerformance(),
    // We only add performance integrations if tracing is enabled
    // Note that this means that without tracing enabled, e.g. `expressIntegration()` will not be added
    // This means that generally request isolation will work (because that is done by httpIntegration)
    // But `transactionName` will not be set automatically
    ...shouldAddPerformanceIntegrations(options) ? getAutoPerformanceIntegrations() : []
  ];
}
function shouldAddPerformanceIntegrations(options) {
  if (!hasTracingEnabled(options)) {
    return false;
  }
  return options.enableTracing || options.tracesSampleRate != null || "tracesSampler" in options;
}

// ../cli-error-reporting/src/error-reporter.ts
var import_verror3 = __toESM(require_verror(), 1);
var import_ci_info = __toESM(require_ci_info(), 1);
import EventEmitter from "node:events";
var ReportErrorResult = (0, import_variant2.variant)({
  Reported: (0, import_variant2.fields)(),
  Ignored: {}
});
var reportError = (scope, originalError, { data } = {}) => {
  if (!isCliSystemError(originalError)) {
    return ReportErrorResult.Ignored();
  }
  const error = (0, import_variant2.isType)(originalError.cliCode, CliSystemErrorCode.UnknownFailure) ? originalError.cliCode.error : originalError;
  const eventId = scope.captureException(error, {
    data,
    captureContext: (localScope) => {
      const httpError = extractHttpError(error);
      if (httpError) {
        localScope.setTag("requestId", httpError.requestId);
        localScope.setContext("requestInfo", getHttpErrorInfo(httpError));
      }
      if (error instanceof Error) {
        localScope.setContext("error details", {
          info: import_verror3.default.info(error),
          fullStack: import_verror3.default.fullStack(error)
        });
      }
      localScope.setTag("ci", yesOrNo(import_ci_info.default.isCI));
      const ciName = import_ci_info.default.name ?? process.env.CI_NAME ?? null;
      localScope.setTag("ci.name", ciName);
      localScope.setContext("CI", {
        Name: ciName,
        "Is CI": yesOrNo(import_ci_info.default.isCI),
        "Is PR": yesOrNo(import_ci_info.default.isPR)
      });
      return localScope;
    }
  });
  return ReportErrorResult.Reported({ eventId });
};
function createErrorReporter({ dsn, release: release2 }) {
  const { sentryDsn: sentryDsnOverride } = getTestOverrides();
  const sentryClient = new NodeClient({
    enabled: sentryDsnOverride !== void 0 || true,
    dsn: sentryDsnOverride ?? dsn,
    release: release2,
    integrations: getDefaultIntegrations({}).filter(
      (integration) => integration.name !== "OnUnhandledRejection" && integration.name !== "OnUncaughtException" && // By default, @sentry/node adds metadata about installed packages.
      integration.name !== "Modules"
    ),
    stackParser: defaultStackParser,
    transport: makeNodeTransport,
    beforeSend(event) {
      delete event.server_name;
      return event;
    },
    // Since we pass `requestInfo`, the default depth of 3
    // redacts most useful info passed from API error responses
    // so we increase it to include more of the potential error http repsonse.
    normalizeDepth: 10
  });
  const sentryScope = new Scope();
  sentryScope.setClient(sentryClient);
  sentryClient.init();
  const emitter = new EventEmitter();
  return {
    on: emitter.on.bind(emitter),
    reportError: (originalError, { data } = {}) => {
      const error = normalizeError(originalError);
      const result = reportError(sentryScope, error, { data });
      emitter.emit("errorReported", error);
      return result;
    },
    reportUserFeedback: async ({ userId, eventId, feedback }) => {
      const { BrowserClient } = await import("./esm-KPR2HWDF.js");
      const client = new BrowserClient({
        enabled: sentryClient.getOptions().enabled,
        dsn: sentryClient.getOptions().dsn,
        integrations: [],
        transport: makeNodeTransport,
        stackParser: defaultStackParser
      });
      client.captureUserFeedback({
        event_id: eventId,
        name: "",
        email: `${userId}@wix.com`,
        comments: defaultOutdent`
          ---
          user: https://bo.wix.com/um/users/${userId}
          ---
          ${feedback}
        `
      });
    },
    setContext: (name, context2) => sentryScope.setContext(name, context2),
    setTag: (key, value) => sentryScope.setTag(key, value),
    setUser: (user) => sentryScope.setUser(user),
    getUser: () => {
      const user = sentryScope.getUser();
      if (typeof user?.id === "string") {
        return { id: user.id };
      }
    }
  };
}
function yesOrNo(value) {
  if (value == null) {
    return null;
  }
  return value ? "yes" : "no";
}

// ../cli-error-reporting/src/user-feedback.tsx
init_esm_shims();
var import_react11 = __toESM(require_react(), 1);
var import_variant4 = __toESM(require_lib(), 1);
import { stdin } from "node:process";

// ../cli-fs-cache/src/index.ts
init_esm_shims();
var import_variant3 = __toESM(require_lib(), 1);
import { join as join4 } from "node:path";
var CacheState = (0, import_variant3.variant)({
  Exists: (0, import_variant3.fields)(),
  NotExists: {}
});
var CacheData = z.object({
  data: z.unknown(),
  createdAt: z.number()
});
var isFileExpired = (createdAt, ttlInHours) => {
  return Date.now() - createdAt.valueOf() > ttlInHours * 60 * 60 * 1e3;
};
function getFsCacheFilePath(dirPath, fileName) {
  const testOverrides = getTestOverrides();
  if (testOverrides.fsCacheDir) {
    return join4(testOverrides.fsCacheDir, fileName);
  }
  return join4(dirPath, fileName);
}
function createFsCache({
  filePath,
  ttlInHours = 24 * 7
}) {
  const get = async () => {
    try {
      const isCacheExists = await pathExists(filePath);
      if (isCacheExists) {
        const cacheData = CacheData.parse(await readJson(filePath));
        if (!isFileExpired(cacheData.createdAt, ttlInHours)) {
          return CacheState.Exists({ data: cacheData.data });
        }
      }
      return CacheState.NotExists();
    } catch (e) {
      throw new CliError({
        code: CliErrorCode.FailedToReadCache({ path: filePath }),
        cause: e
      });
    }
  };
  const set = async (data) => {
    try {
      await writeJson(filePath, {
        data,
        createdAt: Date.now()
      });
      return CacheState.Exists({ data });
    } catch (e) {
      throw new CliError({
        code: CliErrorCode.FailedToWriteCache({ path: filePath }),
        cause: e
      });
    }
  };
  return {
    get,
    set
  };
}

// ../cli-error-reporting/src/components/UserFeedback/Form.tsx
init_esm_shims();
var import_react9 = __toESM(require_react(), 1);

// ../cli-error-reporting/src/components/UserFeedback/ContactUs.tsx
init_esm_shims();
var import_react8 = __toESM(require_react(), 1);
var ContactUs = () => /* @__PURE__ */ import_react8.default.createElement(
  Trans,
  {
    i18nKey: "user_feedback.contact_us",
    components: [/* @__PURE__ */ import_react8.default.createElement(Link, { url: "https://discord.gg/wixstudio" })]
  }
);

// ../cli-error-reporting/src/components/UserFeedback/Form.tsx
var UserFeedbackForm = ({ onSubmit }) => {
  const { t } = useTranslation();
  const [isSubmitted, setIsSubmitted] = (0, import_react9.useState)(false);
  const [consent, setConsent] = (0, import_react9.useState)();
  const handleConsentSubmit = (0, import_react9.useCallback)((value) => {
    setConsent(value);
    if (!value) {
      setIsSubmitted(true);
    }
  }, []);
  const handleSubmit = (0, import_react9.useCallback)(
    (feedback) => {
      setIsSubmitted(true);
      onSubmit({ feedback });
    },
    [onSubmit]
  );
  return /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement(Box_default, { flexDirection: "column", marginTop: 1, marginBottom: 1 }, /* @__PURE__ */ import_react9.default.createElement(Text, null, t("user_feedback.title")), /* @__PURE__ */ import_react9.default.createElement(Text, { skin: "secondary" }, t("user_feedback.subtitle"))), /* @__PURE__ */ import_react9.default.createElement(
    ConfirmInput,
    {
      initialValue: false,
      label: t("user_feedback.consent.label"),
      onSubmit: handleConsentSubmit
    }
  ), consent === true && /* @__PURE__ */ import_react9.default.createElement(
    TextInput,
    {
      label: t("user_feedback.comments.label"),
      onSubmit: handleSubmit
    }
  ), isSubmitted && /* @__PURE__ */ import_react9.default.createElement(Box_default, { flexDirection: "column", marginTop: 1 }, /* @__PURE__ */ import_react9.default.createElement(Text, null, consent ? t("user_feedback.submitted") : t("user_feedback.declined")), /* @__PURE__ */ import_react9.default.createElement(ContactUs, null)));
};

// ../cli-error-reporting/src/components/UserFeedback/Fallback.tsx
init_esm_shims();
var import_react10 = __toESM(require_react(), 1);
var UserFeedbackFallback = () => {
  return /* @__PURE__ */ import_react10.default.createElement(Box_default, { flexDirection: "column", marginTop: 1 }, /* @__PURE__ */ import_react10.default.createElement(ContactUs, null));
};

// ../cli-error-reporting/src/user-feedback.tsx
async function collectUserFeedback({
  cachePath,
  reportResult,
  errorReporter
}) {
  if (!stdin.isTTY || !cachePath || !(0, import_variant4.isType)(reportResult, ReportErrorResult.Reported)) {
    return;
  }
  const fsCache = createFsCache({
    filePath: cachePath,
    ttlInHours: 1
  });
  const cacheState = await fsCache.get();
  if ((0, import_variant4.isType)(cacheState, CacheState.Exists)) {
    return;
  }
  const user = errorReporter.getUser();
  if (user) {
    await render(
      /* @__PURE__ */ import_react11.default.createElement(I18nProvider, { messages: messages_default }, /* @__PURE__ */ import_react11.default.createElement(
        UserFeedbackForm,
        {
          onSubmit: ({ feedback }) => {
            void errorReporter.reportUserFeedback({
              userId: user.id,
              eventId: reportResult.eventId,
              feedback
            });
          }
        }
      ))
    );
  } else {
    renderSync(
      /* @__PURE__ */ import_react11.default.createElement(I18nProvider, { messages: messages_default }, /* @__PURE__ */ import_react11.default.createElement(UserFeedbackFallback, null))
    );
  }
  await fsCache.set({ reported: true });
}

// ../cli-error-reporting/src/create-error-handler.tsx
function createErrorHandler({
  debugOutputPath,
  userFeedbackCachePath,
  ...errorReporterOptions
}) {
  const errorReporter = createErrorReporter(errorReporterOptions);
  const handler = function({ error, data }) {
    const reportResult = errorReporter.reportError(error, { data });
    renderErrorSync(/* @__PURE__ */ import_react12.default.createElement(ErrorViewer, { error }));
    writeCrashReport(debugOutputPath, error);
    process2.exitCode = 1;
    collectUserFeedback({
      reportResult,
      errorReporter,
      cachePath: userFeedbackCachePath
    }).catch((e) => {
      writeCrashReport(debugOutputPath, e);
    });
  };
  const registerToProcessErrors = function() {
    process2.on("uncaughtException", (error) => {
      handler({
        error,
        data: { mechanism: { handled: false, type: "uncaughtException" } }
      });
    });
    process2.on("unhandledRejection", (error) => {
      if (error instanceof Error && error.message.startsWith("Build failed with") && error.stack?.includes("esbuild")) {
        return;
      }
      if (error instanceof Error && error.message.startsWith("Failed to load PostCSS config")) {
        return;
      }
      handler({
        error,
        data: { mechanism: { handled: false, type: "unhandledRejection" } }
      });
    });
  };
  return {
    handler,
    errorReporter,
    registerToProcessErrors
  };
}

// ../cli-error-reporting/src/error-reporter-context.tsx
init_esm_shims();
var import_react13 = __toESM(require_react(), 1);
var ErrorReporterContext = (0, import_react13.createContext)(null);
var ErrorReporterProvider = (props) => /* @__PURE__ */ import_react13.default.createElement(ErrorReporterContext.Provider, { ...props });
var useErrorReporter = () => {
  const context2 = (0, import_react13.useContext)(ErrorReporterContext);
  if (context2 == null) {
    throw new Error(
      "useErrorReporter() cannot be used without an <ErrorReporterProvider>"
    );
  }
  return context2;
};

// ../cli-error-reporting/src/index.ts
init_esm_shims();

export {
  extractHttpError,
  BiProvider,
  useBiLogger,
  writeCrashReport,
  DebugLogProvider,
  useDebugLog,
  OutdatedVersionMessage,
  ErrorViewer,
  require_parse,
  require_valid,
  require_clean,
  require_prerelease,
  require_semver2 as require_semver,
  require_is_core_module,
  getFsCacheFilePath,
  createFsCache,
  createErrorHandler,
  ErrorReporterProvider,
  useErrorReporter
};
//# sourceMappingURL=chunk-WWUS5636.js.map