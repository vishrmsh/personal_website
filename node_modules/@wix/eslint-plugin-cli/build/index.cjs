"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  configs: () => configs,
  rules: () => rules
});
module.exports = __toCommonJS(src_exports);

// src/rules/no-invalid-backend-import.ts
var import_node_path2 = __toESM(require("path"), 1);
var import_node_fs = __toESM(require("fs"), 1);

// src/util/get-project-root.ts
var import_node_path = __toESM(require("path"), 1);
var import_pkg_up = __toESM(require("pkg-up"), 1);
function getProjectRoot(context) {
  const packageJsonPath = import_pkg_up.default.sync({ cwd: context.getPhysicalFilename() });
  if (!packageJsonPath) {
    context.report({
      message: "The package.json file could not be found.",
      loc: { line: 0, column: 0 }
    });
    return null;
  }
  return import_node_path.default.dirname(packageJsonPath);
}

// src/util/module-visitor.ts
function moduleVisitor(visitor) {
  function checkSource(node) {
    if (node.source) {
      visitor(node.source, node);
    }
  }
  function checkImportCall(node) {
    if (node.source.type === "Literal") {
      visitor(node.source, node);
    }
  }
  function checkRequireCall(node) {
    if (node.callee.type !== "Identifier") {
      return;
    }
    if (node.callee.name !== "require") {
      return;
    }
    if (node.arguments.length !== 1) {
      return;
    }
    const modulePath = node.arguments[0];
    if (modulePath.type !== "Literal") {
      return;
    }
    if (typeof modulePath.value !== "string") {
      return;
    }
    visitor(modulePath, node);
  }
  return {
    // esm
    ImportDeclaration: checkSource,
    ExportNamedDeclaration: checkSource,
    ExportAllDeclaration: checkSource,
    ImportExpression: checkImportCall,
    // cjs
    CallExpression: checkRequireCall
  };
}

// src/rules/no-invalid-backend-import.ts
var getPathWithExtension = (fullPath) => {
  if (fullPath.endsWith(".web.js") || fullPath.endsWith(".jsw") || fullPath.endsWith(".js")) {
    return fullPath;
  }
  if (fullPath.endsWith(".web")) {
    return `${fullPath}.js`;
  }
  return `${fullPath}.jsw`;
};
var isPathToWebMethod = (pathWithExtension) => {
  if (pathWithExtension.endsWith(".js") && !pathWithExtension.endsWith(".web.js")) {
    return false;
  }
  return true;
};
var rule = {
  meta: {
    type: "problem",
    docs: {
      description: 'Disallow importing non ".jsw" or ".web.js" backend files from pages and public files.',
      recommended: true
    }
  },
  create(context) {
    const projectRootPath = getProjectRoot(context);
    if (!projectRootPath) {
      return {};
    }
    const srcFolder = import_node_path2.default.join(projectRootPath, "src");
    const relativeFileName = import_node_path2.default.relative(srcFolder, context.physicalFilename);
    return moduleVisitor((source, node) => {
      const { value } = source;
      if (typeof value === "string" && (relativeFileName.startsWith("pages/") || relativeFileName.startsWith("public/")) && value.startsWith("backend/")) {
        const filePath = getPathWithExtension(value);
        const fullImportPath = import_node_path2.default.join(srcFolder, filePath);
        if (!isPathToWebMethod(fullImportPath) || !import_node_fs.default.existsSync(fullImportPath)) {
          context.report({
            node,
            message: 'Importing non ".jsw" or ".web.js" backend files from pages or public files is not allowed.'
          });
        }
      }
    });
  }
};
var no_invalid_backend_import_default = rule;

// src/util/get-velo-dependencies.ts
var import_node_fs2 = __toESM(require("fs"), 1);
var import_node_path3 = __toESM(require("path"), 1);
function getVeloDependencies(context, projectRootPath) {
  try {
    const veloDependenciesJsonPath = import_node_path3.default.join(
      projectRootPath,
      "src/velo.dependencies.json"
    );
    if (!import_node_fs2.default.existsSync(veloDependenciesJsonPath)) {
      return { dependencies: {} };
    }
    return JSON.parse(import_node_fs2.default.readFileSync(veloDependenciesJsonPath, "utf8"));
  } catch (error) {
    if (error instanceof SyntaxError) {
      context.report({
        message: `The velo.dependencies.json file could not be parsed: ${error.message}`,
        loc: { line: 0, column: 0 }
      });
      return null;
    }
    throw error;
  }
}

// src/util/get-import-type.ts
var import_node_path4 = require("path");
var import_is_core_module = __toESM(require("is-core-module"), 1);
function isRelative(name) {
  return /^\./.test(name);
}
var coreWixModules = { backend: true, public: true };
function isWixModule(importValue) {
  const packageName = baseModule(importValue);
  return Object.hasOwn(coreWixModules, packageName);
}
function importType(importValue) {
  if ((0, import_node_path4.isAbsolute)(importValue)) {
    return "absolute";
  }
  if ((0, import_is_core_module.default)(importValue)) {
    return "core";
  }
  if (isWixModule(importValue)) {
    return "wix";
  }
  if (isRelative(importValue)) {
    return "relative";
  }
  return "external";
}
function baseModule(importValue) {
  const [first, second] = importValue.split("/");
  return first.startsWith("@") ? `${first}/${second}` : first;
}

// src/rules/no-wix-extraneous-dependencies.ts
var rule2 = {
  meta: {
    type: "problem",
    docs: {
      description: "Forbid the use of extraneous packages"
    }
  },
  create(context) {
    const projectRootPath = getProjectRoot(context);
    if (!projectRootPath) {
      return {};
    }
    const veloDependencies = getVeloDependencies(context, projectRootPath);
    if (!veloDependencies) {
      return {};
    }
    return moduleVisitor((source, node) => {
      const name = source.value;
      if (typeof name === "string" && importType(name) === "external") {
        const packageName = baseModule(name);
        if (!veloDependencies.dependencies[packageName]) {
          context.report({
            node,
            message: `'${packageName}' should be listed in the project's dependencies. Run 'wix install ${packageName}' to add it`
          });
        }
      }
    });
  }
};
var no_wix_extraneous_dependencies_default = rule2;

// src/rules/no-forbidden-relative-imports.ts
var import_node_path5 = __toESM(require("path"), 1);
var forbiddenFolders = ["backend", "public"];
var rule3 = {
  meta: {
    type: "problem",
    docs: {
      description: `Forbid relative imports to special folders (${forbiddenFolders.join(
        ", "
      )}) from \`pages\` directory`
    },
    fixable: "code"
  },
  create(context) {
    const projectRootPath = getProjectRoot(context);
    if (!projectRootPath) {
      return {};
    }
    const filename = context.getPhysicalFilename();
    const srcFolder = import_node_path5.default.join(projectRootPath, "src");
    const relativeFileName = import_node_path5.default.relative(srcFolder, filename);
    return moduleVisitor((source, node) => {
      const name = source.value;
      if (typeof name !== "string" || importType(name) !== "relative") {
        return;
      }
      if (!relativeFileName.startsWith("pages/")) {
        return;
      }
      const absolutePath = import_node_path5.default.resolve(import_node_path5.default.dirname(filename), name);
      const folder = forbiddenFolders.find((folder2) => {
        return absolutePath.startsWith(import_node_path5.default.join(srcFolder, folder2));
      });
      if (folder) {
        const folderPath = import_node_path5.default.join(srcFolder, folder);
        const fixedPath = absolutePath.replace(folderPath, folder);
        context.report({
          node,
          message: `Relative imports to the special \`${folder}\` folder are forbidden from the \`pages\` directory`,
          fix: (fixer) => fixer.replaceText(source, `'${fixedPath}'`)
        });
      }
    });
  }
};
var no_forbidden_relative_imports_default = rule3;

// src/index.ts
var rules = {
  "no-invalid-backend-import": no_invalid_backend_import_default,
  "no-wix-extraneous-dependencies": no_wix_extraneous_dependencies_default,
  "no-forbidden-relative-imports": no_forbidden_relative_imports_default
};
var configs = {
  recommended: {
    parserOptions: {
      ecmaVersion: "latest",
      sourceType: "module",
      ecmaFeatures: {
        jsx: true
      }
    },
    plugins: ["@wix/cli"],
    rules: {
      "@wix/cli/no-invalid-backend-import": "error",
      // Removed due to https://jira.wixpress.com/browse/FEDINF-10942, should be added back when it's fixed
      // '@wix/cli/no-wix-extraneous-dependencies': 'error',
      "@wix/cli/no-forbidden-relative-imports": "error"
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  configs,
  rules
});
